// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(BitcoinDevKitFFI)
import BitcoinDevKitFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_bdkffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_bdkffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureBdkffiInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterFloat: FfiConverterPrimitive {
    typealias FfiType = Float
    typealias SwiftType = Float

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Float {
        return try lift(readFloat(&buf))
    }

    public static func write(_ value: Float, into buf: inout [UInt8]) {
        writeFloat(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




public protocol AddressProtocol: AnyObject, Sendable {
    
    func isValidForNetwork(network: Network)  -> Bool
    
    func scriptPubkey()  -> Script
    
    func toAddressData()  -> AddressData
    
    func toQrUri()  -> String
    
}
open class Address: AddressProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_address(self.pointer, $0) }
    }
public convenience init(address: String, network: Network)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeAddressParseError_lift) {
    uniffi_bdkffi_fn_constructor_address_new(
        FfiConverterString.lower(address),
        FfiConverterTypeNetwork_lower(network),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_address(pointer, $0) }
    }

    
public static func fromScript(script: Script, network: Network)throws  -> Address  {
    return try  FfiConverterTypeAddress_lift(try rustCallWithError(FfiConverterTypeFromScriptError_lift) {
    uniffi_bdkffi_fn_constructor_address_from_script(
        FfiConverterTypeScript_lower(script),
        FfiConverterTypeNetwork_lower(network),$0
    )
})
}
    

    
open func isValidForNetwork(network: Network) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_address_is_valid_for_network(self.uniffiClonePointer(),
        FfiConverterTypeNetwork_lower(network),$0
    )
})
}
    
open func scriptPubkey() -> Script  {
    return try!  FfiConverterTypeScript_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_address_script_pubkey(self.uniffiClonePointer(),$0
    )
})
}
    
open func toAddressData() -> AddressData  {
    return try!  FfiConverterTypeAddressData_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_address_to_address_data(self.uniffiClonePointer(),$0
    )
})
}
    
open func toQrUri() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_address_to_qr_uri(self.uniffiClonePointer(),$0
    )
})
}
    
    open var description: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_address_uniffi_trait_display(self.uniffiClonePointer(),$0
    )
}
        )
    }

}
extension Address: CustomStringConvertible {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddress: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Address

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Address {
        return Address(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Address) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Address {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Address, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddress_lift(_ pointer: UnsafeMutableRawPointer) throws -> Address {
    return try FfiConverterTypeAddress.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddress_lower(_ value: Address) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAddress.lower(value)
}






/**
 * The Amount type can be used to express Bitcoin amounts that support arithmetic and conversion
 * to various denominations. The operations that Amount implements will panic when overflow or
 * underflow occurs. Also note that since the internal representation of amounts is unsigned,
 * subtracting below zero is considered an underflow and will cause a panic.
 */
public protocol AmountProtocol: AnyObject, Sendable {
    
    /**
     * Express this Amount as a floating-point value in Bitcoin. Please be aware of the risk of
     * using floating-point numbers.
     */
    func toBtc()  -> Double
    
    /**
     * Get the number of satoshis in this Amount.
     */
    func toSat()  -> UInt64
    
}
/**
 * The Amount type can be used to express Bitcoin amounts that support arithmetic and conversion
 * to various denominations. The operations that Amount implements will panic when overflow or
 * underflow occurs. Also note that since the internal representation of amounts is unsigned,
 * subtracting below zero is considered an underflow and will cause a panic.
 */
open class Amount: AmountProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_amount(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_amount(pointer, $0) }
    }

    
    /**
     * Convert from a value expressing bitcoins to an Amount.
     */
public static func fromBtc(btc: Double)throws  -> Amount  {
    return try  FfiConverterTypeAmount_lift(try rustCallWithError(FfiConverterTypeParseAmountError_lift) {
    uniffi_bdkffi_fn_constructor_amount_from_btc(
        FfiConverterDouble.lower(btc),$0
    )
})
}
    
    /**
     * Create an Amount with satoshi precision and the given number of satoshis.
     */
public static func fromSat(satoshi: UInt64) -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_amount_from_sat(
        FfiConverterUInt64.lower(satoshi),$0
    )
})
}
    

    
    /**
     * Express this Amount as a floating-point value in Bitcoin. Please be aware of the risk of
     * using floating-point numbers.
     */
open func toBtc() -> Double  {
    return try!  FfiConverterDouble.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_amount_to_btc(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get the number of satoshis in this Amount.
     */
open func toSat() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_amount_to_sat(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAmount: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Amount

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Amount {
        return Amount(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Amount) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Amount {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Amount, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAmount_lift(_ pointer: UnsafeMutableRawPointer) throws -> Amount {
    return try FfiConverterTypeAmount.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAmount_lower(_ value: Amount) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAmount.lower(value)
}






/**
 * A `BumpFeeTxBuilder` is created by calling `build_fee_bump` on a wallet. After assigning it, you set options on it
 * until finally calling `finish` to consume the builder and generate the transaction.
 */
public protocol BumpFeeTxBuilderProtocol: AnyObject, Sendable {
    
    /**
     * Set whether the dust limit is checked.
     *
     * Note: by avoiding a dust limit check you may end up with a transaction that is non-standard.
     */
    func allowDust(allowDust: Bool)  -> BumpFeeTxBuilder
    
    /**
     * Set the current blockchain height.
     *
     * This will be used to:
     *
     * 1. Set the `nLockTime` for preventing fee sniping. Note: This will be ignored if you manually specify a
     * `nlocktime` using `TxBuilder::nlocktime`.
     *
     * 2. Decide whether coinbase outputs are mature or not. If the coinbase outputs are not mature at `current_height`,
     * we ignore them in the coin selection. If you want to create a transaction that spends immature coinbase inputs,
     * manually add them using `TxBuilder::add_utxos`.
     * In both cases, if you don’t provide a current height, we use the last sync height.
     */
    func currentHeight(height: UInt32)  -> BumpFeeTxBuilder
    
    /**
     * Finish building the transaction.
     *
     * Uses the thread-local random number generator (rng).
     *
     * Returns a new `Psbt` per BIP174.
     *
     * WARNING: To avoid change address reuse you must persist the changes resulting from one or more calls to this
     * method before closing the wallet. See `Wallet::reveal_next_address`.
     */
    func finish(wallet: Wallet) throws  -> Psbt
    
    /**
     * Use a specific nLockTime while creating the transaction.
     *
     * This can cause conflicts if the wallet’s descriptors contain an "after" (`OP_CLTV`) operator.
     */
    func nlocktime(locktime: LockTime)  -> BumpFeeTxBuilder
    
    /**
     * Set an exact `nSequence` value.
     *
     * This can cause conflicts if the wallet’s descriptors contain an "older" (`OP_CSV`) operator and the given
     * `nsequence` is lower than the CSV value.
     */
    func setExactSequence(nsequence: UInt32)  -> BumpFeeTxBuilder
    
    /**
     * Build a transaction with a specific version.
     *
     * The version should always be greater than 0 and greater than 1 if the wallet’s descriptors contain an "older"
     * (`OP_CSV`) operator.
     */
    func version(version: Int32)  -> BumpFeeTxBuilder
    
}
/**
 * A `BumpFeeTxBuilder` is created by calling `build_fee_bump` on a wallet. After assigning it, you set options on it
 * until finally calling `finish` to consume the builder and generate the transaction.
 */
open class BumpFeeTxBuilder: BumpFeeTxBuilderProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_bumpfeetxbuilder(self.pointer, $0) }
    }
public convenience init(txid: String, feeRate: FeeRate) {
    let pointer =
        try! rustCall() {
    uniffi_bdkffi_fn_constructor_bumpfeetxbuilder_new(
        FfiConverterString.lower(txid),
        FfiConverterTypeFeeRate_lower(feeRate),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_bumpfeetxbuilder(pointer, $0) }
    }

    

    
    /**
     * Set whether the dust limit is checked.
     *
     * Note: by avoiding a dust limit check you may end up with a transaction that is non-standard.
     */
open func allowDust(allowDust: Bool) -> BumpFeeTxBuilder  {
    return try!  FfiConverterTypeBumpFeeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_bumpfeetxbuilder_allow_dust(self.uniffiClonePointer(),
        FfiConverterBool.lower(allowDust),$0
    )
})
}
    
    /**
     * Set the current blockchain height.
     *
     * This will be used to:
     *
     * 1. Set the `nLockTime` for preventing fee sniping. Note: This will be ignored if you manually specify a
     * `nlocktime` using `TxBuilder::nlocktime`.
     *
     * 2. Decide whether coinbase outputs are mature or not. If the coinbase outputs are not mature at `current_height`,
     * we ignore them in the coin selection. If you want to create a transaction that spends immature coinbase inputs,
     * manually add them using `TxBuilder::add_utxos`.
     * In both cases, if you don’t provide a current height, we use the last sync height.
     */
open func currentHeight(height: UInt32) -> BumpFeeTxBuilder  {
    return try!  FfiConverterTypeBumpFeeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_bumpfeetxbuilder_current_height(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(height),$0
    )
})
}
    
    /**
     * Finish building the transaction.
     *
     * Uses the thread-local random number generator (rng).
     *
     * Returns a new `Psbt` per BIP174.
     *
     * WARNING: To avoid change address reuse you must persist the changes resulting from one or more calls to this
     * method before closing the wallet. See `Wallet::reveal_next_address`.
     */
open func finish(wallet: Wallet)throws  -> Psbt  {
    return try  FfiConverterTypePsbt_lift(try rustCallWithError(FfiConverterTypeCreateTxError_lift) {
    uniffi_bdkffi_fn_method_bumpfeetxbuilder_finish(self.uniffiClonePointer(),
        FfiConverterTypeWallet_lower(wallet),$0
    )
})
}
    
    /**
     * Use a specific nLockTime while creating the transaction.
     *
     * This can cause conflicts if the wallet’s descriptors contain an "after" (`OP_CLTV`) operator.
     */
open func nlocktime(locktime: LockTime) -> BumpFeeTxBuilder  {
    return try!  FfiConverterTypeBumpFeeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_bumpfeetxbuilder_nlocktime(self.uniffiClonePointer(),
        FfiConverterTypeLockTime_lower(locktime),$0
    )
})
}
    
    /**
     * Set an exact `nSequence` value.
     *
     * This can cause conflicts if the wallet’s descriptors contain an "older" (`OP_CSV`) operator and the given
     * `nsequence` is lower than the CSV value.
     */
open func setExactSequence(nsequence: UInt32) -> BumpFeeTxBuilder  {
    return try!  FfiConverterTypeBumpFeeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_bumpfeetxbuilder_set_exact_sequence(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(nsequence),$0
    )
})
}
    
    /**
     * Build a transaction with a specific version.
     *
     * The version should always be greater than 0 and greater than 1 if the wallet’s descriptors contain an "older"
     * (`OP_CSV`) operator.
     */
open func version(version: Int32) -> BumpFeeTxBuilder  {
    return try!  FfiConverterTypeBumpFeeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_bumpfeetxbuilder_version(self.uniffiClonePointer(),
        FfiConverterInt32.lower(version),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBumpFeeTxBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BumpFeeTxBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BumpFeeTxBuilder {
        return BumpFeeTxBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BumpFeeTxBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BumpFeeTxBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BumpFeeTxBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBumpFeeTxBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> BumpFeeTxBuilder {
    return try FfiConverterTypeBumpFeeTxBuilder.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBumpFeeTxBuilder_lower(_ value: BumpFeeTxBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBumpFeeTxBuilder.lower(value)
}






/**
 * Build a BIP 157/158 light client to fetch transactions for a `Wallet`.
 *
 * Options:
 * * List of `Peer`: Bitcoin full-nodes for the light client to connect to. May be empty.
 * * `connections`: The number of connections for the light client to maintain.
 * * `scan_type`: Sync, recover, or start a new wallet. For more information see [`ScanType`].
 * * `data_dir`: Optional directory to store block headers and peers.
 *
 * A note on recovering wallets. Developers should allow users to provide an
 * approximate recovery height and an estimated number of transactions for the
 * wallet. When determining how many scripts to check filters for, the `Wallet`
 * `lookahead` value will be used. To ensure all transactions are recovered, the
 * `lookahead` should be roughly the number of transactions in the wallet history.
 */
public protocol CbfBuilderProtocol: AnyObject, Sendable {
    
    /**
     * Construct a [`CbfComponents`] for a [`Wallet`].
     */
    func build(wallet: Wallet) throws  -> CbfComponents
    
    /**
     * The number of connections for the light client to maintain. Default is two.
     */
    func connections(connections: UInt8)  -> CbfBuilder
    
    /**
     * Directory to store block headers and peers. If none is provided, the current
     * working directory will be used.
     */
    func dataDir(dataDir: String)  -> CbfBuilder
    
    /**
     * Configure a custom DNS resolver when querying DNS seeds. Default is `1.1.1.1` managed by
     * CloudFlare.
     */
    func dnsResolver(dnsResolver: IpAddress)  -> CbfBuilder
    
    /**
     * Set the log level for the node. Production applications may want to omit `Debug` messages
     * to avoid heap allocations.
     */
    func logLevel(logLevel: LogLevel)  -> CbfBuilder
    
    /**
     * Bitcoin full-nodes to attempt a connection with.
     */
    func peers(peers: [Peer])  -> CbfBuilder
    
    /**
     * Select between syncing, recovering, or scanning for new wallets.
     */
    func scanType(scanType: ScanType)  -> CbfBuilder
    
}
/**
 * Build a BIP 157/158 light client to fetch transactions for a `Wallet`.
 *
 * Options:
 * * List of `Peer`: Bitcoin full-nodes for the light client to connect to. May be empty.
 * * `connections`: The number of connections for the light client to maintain.
 * * `scan_type`: Sync, recover, or start a new wallet. For more information see [`ScanType`].
 * * `data_dir`: Optional directory to store block headers and peers.
 *
 * A note on recovering wallets. Developers should allow users to provide an
 * approximate recovery height and an estimated number of transactions for the
 * wallet. When determining how many scripts to check filters for, the `Wallet`
 * `lookahead` value will be used. To ensure all transactions are recovered, the
 * `lookahead` should be roughly the number of transactions in the wallet history.
 */
open class CbfBuilder: CbfBuilderProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_cbfbuilder(self.pointer, $0) }
    }
    /**
     * Start a new [`CbfBuilder`]
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_bdkffi_fn_constructor_cbfbuilder_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_cbfbuilder(pointer, $0) }
    }

    

    
    /**
     * Construct a [`CbfComponents`] for a [`Wallet`].
     */
open func build(wallet: Wallet)throws  -> CbfComponents  {
    return try  FfiConverterTypeCbfComponents_lift(try rustCallWithError(FfiConverterTypeCbfBuilderError_lift) {
    uniffi_bdkffi_fn_method_cbfbuilder_build(self.uniffiClonePointer(),
        FfiConverterTypeWallet_lower(wallet),$0
    )
})
}
    
    /**
     * The number of connections for the light client to maintain. Default is two.
     */
open func connections(connections: UInt8) -> CbfBuilder  {
    return try!  FfiConverterTypeCbfBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_cbfbuilder_connections(self.uniffiClonePointer(),
        FfiConverterUInt8.lower(connections),$0
    )
})
}
    
    /**
     * Directory to store block headers and peers. If none is provided, the current
     * working directory will be used.
     */
open func dataDir(dataDir: String) -> CbfBuilder  {
    return try!  FfiConverterTypeCbfBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_cbfbuilder_data_dir(self.uniffiClonePointer(),
        FfiConverterString.lower(dataDir),$0
    )
})
}
    
    /**
     * Configure a custom DNS resolver when querying DNS seeds. Default is `1.1.1.1` managed by
     * CloudFlare.
     */
open func dnsResolver(dnsResolver: IpAddress) -> CbfBuilder  {
    return try!  FfiConverterTypeCbfBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_cbfbuilder_dns_resolver(self.uniffiClonePointer(),
        FfiConverterTypeIpAddress_lower(dnsResolver),$0
    )
})
}
    
    /**
     * Set the log level for the node. Production applications may want to omit `Debug` messages
     * to avoid heap allocations.
     */
open func logLevel(logLevel: LogLevel) -> CbfBuilder  {
    return try!  FfiConverterTypeCbfBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_cbfbuilder_log_level(self.uniffiClonePointer(),
        FfiConverterTypeLogLevel_lower(logLevel),$0
    )
})
}
    
    /**
     * Bitcoin full-nodes to attempt a connection with.
     */
open func peers(peers: [Peer]) -> CbfBuilder  {
    return try!  FfiConverterTypeCbfBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_cbfbuilder_peers(self.uniffiClonePointer(),
        FfiConverterSequenceTypePeer.lower(peers),$0
    )
})
}
    
    /**
     * Select between syncing, recovering, or scanning for new wallets.
     */
open func scanType(scanType: ScanType) -> CbfBuilder  {
    return try!  FfiConverterTypeCbfBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_cbfbuilder_scan_type(self.uniffiClonePointer(),
        FfiConverterTypeScanType_lower(scanType),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCbfBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = CbfBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> CbfBuilder {
        return CbfBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: CbfBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CbfBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: CbfBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCbfBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> CbfBuilder {
    return try FfiConverterTypeCbfBuilder.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCbfBuilder_lower(_ value: CbfBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeCbfBuilder.lower(value)
}






/**
 * A [`CbfClient`] handles wallet updates from a [`CbfNode`].
 */
public protocol CbfClientProtocol: AnyObject, Sendable {
    
    /**
     * Add scripts for the node to watch for as they are revealed. Typically used after creating
     * a transaction or revealing a receive address.
     *
     * Note that only future blocks will be checked for these scripts, not past blocks.
     */
    func addRevealedScripts(wallet: Wallet) async throws 
    
    /**
     * Broadcast a transaction to the network, erroring if the node has stopped running.
     */
    func broadcast(transaction: Transaction) async throws 
    
    /**
     * Check if the node is still running in the background.
     */
    func isRunning() async  -> Bool
    
    /**
     * The minimum fee rate required to broadcast a transcation to all connected peers.
     */
    func minBroadcastFeerate() async throws  -> FeeRate
    
    /**
     * Return the next available log message from a node. If none is returned, the node has stopped.
     */
    func nextLog() async throws  -> Log
    
    /**
     * Return the next available warning message from a node. If none is returned, the node has stopped.
     */
    func nextWarning() async throws  -> Warning
    
    /**
     * Stop the [`CbfNode`]. Errors if the node is already stopped.
     */
    func shutdown() async throws 
    
    /**
     * Return an [`Update`]. This is method returns once the node syncs to the rest of
     * the network or a new block has been gossiped.
     */
    func update() async  -> Update?
    
}
/**
 * A [`CbfClient`] handles wallet updates from a [`CbfNode`].
 */
open class CbfClient: CbfClientProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_cbfclient(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_cbfclient(pointer, $0) }
    }

    

    
    /**
     * Add scripts for the node to watch for as they are revealed. Typically used after creating
     * a transaction or revealing a receive address.
     *
     * Note that only future blocks will be checked for these scripts, not past blocks.
     */
open func addRevealedScripts(wallet: Wallet)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bdkffi_fn_method_cbfclient_add_revealed_scripts(
                    self.uniffiClonePointer(),
                    FfiConverterTypeWallet_lower(wallet)
                )
            },
            pollFunc: ffi_bdkffi_rust_future_poll_void,
            completeFunc: ffi_bdkffi_rust_future_complete_void,
            freeFunc: ffi_bdkffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCbfError_lift
        )
}
    
    /**
     * Broadcast a transaction to the network, erroring if the node has stopped running.
     */
open func broadcast(transaction: Transaction)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bdkffi_fn_method_cbfclient_broadcast(
                    self.uniffiClonePointer(),
                    FfiConverterTypeTransaction_lower(transaction)
                )
            },
            pollFunc: ffi_bdkffi_rust_future_poll_void,
            completeFunc: ffi_bdkffi_rust_future_complete_void,
            freeFunc: ffi_bdkffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCbfError_lift
        )
}
    
    /**
     * Check if the node is still running in the background.
     */
open func isRunning()async  -> Bool  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bdkffi_fn_method_cbfclient_is_running(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_bdkffi_rust_future_poll_i8,
            completeFunc: ffi_bdkffi_rust_future_complete_i8,
            freeFunc: ffi_bdkffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * The minimum fee rate required to broadcast a transcation to all connected peers.
     */
open func minBroadcastFeerate()async throws  -> FeeRate  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bdkffi_fn_method_cbfclient_min_broadcast_feerate(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_bdkffi_rust_future_poll_pointer,
            completeFunc: ffi_bdkffi_rust_future_complete_pointer,
            freeFunc: ffi_bdkffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFeeRate_lift,
            errorHandler: FfiConverterTypeCbfError_lift
        )
}
    
    /**
     * Return the next available log message from a node. If none is returned, the node has stopped.
     */
open func nextLog()async throws  -> Log  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bdkffi_fn_method_cbfclient_next_log(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_bdkffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_bdkffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_bdkffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeLog_lift,
            errorHandler: FfiConverterTypeCbfError_lift
        )
}
    
    /**
     * Return the next available warning message from a node. If none is returned, the node has stopped.
     */
open func nextWarning()async throws  -> Warning  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bdkffi_fn_method_cbfclient_next_warning(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_bdkffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_bdkffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_bdkffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeWarning_lift,
            errorHandler: FfiConverterTypeCbfError_lift
        )
}
    
    /**
     * Stop the [`CbfNode`]. Errors if the node is already stopped.
     */
open func shutdown()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bdkffi_fn_method_cbfclient_shutdown(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_bdkffi_rust_future_poll_void,
            completeFunc: ffi_bdkffi_rust_future_complete_void,
            freeFunc: ffi_bdkffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCbfError_lift
        )
}
    
    /**
     * Return an [`Update`]. This is method returns once the node syncs to the rest of
     * the network or a new block has been gossiped.
     */
open func update()async  -> Update?  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bdkffi_fn_method_cbfclient_update(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_bdkffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_bdkffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_bdkffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeUpdate.lift,
            errorHandler: nil
            
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCbfClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = CbfClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> CbfClient {
        return CbfClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: CbfClient) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CbfClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: CbfClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCbfClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> CbfClient {
    return try FfiConverterTypeCbfClient.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCbfClient_lower(_ value: CbfClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeCbfClient.lower(value)
}






/**
 * A [`CbfNode`] gathers transactions for a [`Wallet`].
 * To receive [`Update`] for [`Wallet`], refer to the
 * [`CbfClient`]. The [`CbfNode`] will run until instructed
 * to stop.
 */
public protocol CbfNodeProtocol: AnyObject, Sendable {
    
    /**
     * Start the node on a detached OS thread and immediately return.
     */
    func run() 
    
}
/**
 * A [`CbfNode`] gathers transactions for a [`Wallet`].
 * To receive [`Update`] for [`Wallet`], refer to the
 * [`CbfClient`]. The [`CbfNode`] will run until instructed
 * to stop.
 */
open class CbfNode: CbfNodeProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_cbfnode(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_cbfnode(pointer, $0) }
    }

    

    
    /**
     * Start the node on a detached OS thread and immediately return.
     */
open func run()  {try! rustCall() {
    uniffi_bdkffi_fn_method_cbfnode_run(self.uniffiClonePointer(),$0
    )
}
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCbfNode: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = CbfNode

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> CbfNode {
        return CbfNode(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: CbfNode) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CbfNode {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: CbfNode, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCbfNode_lift(_ pointer: UnsafeMutableRawPointer) throws -> CbfNode {
    return try FfiConverterTypeCbfNode.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCbfNode_lower(_ value: CbfNode) -> UnsafeMutableRawPointer {
    return FfiConverterTypeCbfNode.lower(value)
}






/**
 * A changeset for [`Wallet`].
 */
public protocol ChangeSetProtocol: AnyObject, Sendable {
    
}
/**
 * A changeset for [`Wallet`].
 */
open class ChangeSet: ChangeSetProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_changeset(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_changeset(pointer, $0) }
    }

    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeChangeSet: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ChangeSet

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ChangeSet {
        return ChangeSet(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ChangeSet) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChangeSet {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ChangeSet, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChangeSet_lift(_ pointer: UnsafeMutableRawPointer) throws -> ChangeSet {
    return try FfiConverterTypeChangeSet.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChangeSet_lower(_ value: ChangeSet) -> UnsafeMutableRawPointer {
    return FfiConverterTypeChangeSet.lower(value)
}






public protocol ConnectionProtocol: AnyObject, Sendable {
    
}
open class Connection: ConnectionProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_connection(self.pointer, $0) }
    }
public convenience init(path: String)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeSqliteError_lift) {
    uniffi_bdkffi_fn_constructor_connection_new(
        FfiConverterString.lower(path),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_connection(pointer, $0) }
    }

    
public static func newInMemory()throws  -> Connection  {
    return try  FfiConverterTypeConnection_lift(try rustCallWithError(FfiConverterTypeSqliteError_lift) {
    uniffi_bdkffi_fn_constructor_connection_new_in_memory($0
    )
})
}
    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConnection: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Connection

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Connection {
        return Connection(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Connection) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Connection {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Connection, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConnection_lift(_ pointer: UnsafeMutableRawPointer) throws -> Connection {
    return try FfiConverterTypeConnection.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConnection_lower(_ value: Connection) -> UnsafeMutableRawPointer {
    return FfiConverterTypeConnection.lower(value)
}






public protocol DerivationPathProtocol: AnyObject, Sendable {
    
}
open class DerivationPath: DerivationPathProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_derivationpath(self.pointer, $0) }
    }
public convenience init(path: String)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeBip32Error_lift) {
    uniffi_bdkffi_fn_constructor_derivationpath_new(
        FfiConverterString.lower(path),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_derivationpath(pointer, $0) }
    }

    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDerivationPath: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = DerivationPath

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> DerivationPath {
        return DerivationPath(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: DerivationPath) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DerivationPath {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: DerivationPath, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDerivationPath_lift(_ pointer: UnsafeMutableRawPointer) throws -> DerivationPath {
    return try FfiConverterTypeDerivationPath.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDerivationPath_lower(_ value: DerivationPath) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDerivationPath.lower(value)
}






public protocol DescriptorProtocol: AnyObject, Sendable {
    
    /**
     * Whether or not this key has multiple derivation paths.
     */
    func isMultipath()  -> Bool
    
    /**
     * Get as many descriptors as different paths in this descriptor.
     *
     * For multipath descriptors it will return as many descriptors as there is
     * "parallel" paths. For regular descriptors it will just return itself.
     */
    func toSingleDescriptors() throws  -> [Descriptor]
    
    func toStringWithSecret()  -> String
    
}
open class Descriptor: DescriptorProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_descriptor(self.pointer, $0) }
    }
public convenience init(descriptor: String, network: Network)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeDescriptorError_lift) {
    uniffi_bdkffi_fn_constructor_descriptor_new(
        FfiConverterString.lower(descriptor),
        FfiConverterTypeNetwork_lower(network),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_descriptor(pointer, $0) }
    }

    
public static func newBip44(secretKey: DescriptorSecretKey, keychain: KeychainKind, network: Network) -> Descriptor  {
    return try!  FfiConverterTypeDescriptor_lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_descriptor_new_bip44(
        FfiConverterTypeDescriptorSecretKey_lower(secretKey),
        FfiConverterTypeKeychainKind_lower(keychain),
        FfiConverterTypeNetwork_lower(network),$0
    )
})
}
    
public static func newBip44Public(publicKey: DescriptorPublicKey, fingerprint: String, keychain: KeychainKind, network: Network) -> Descriptor  {
    return try!  FfiConverterTypeDescriptor_lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_descriptor_new_bip44_public(
        FfiConverterTypeDescriptorPublicKey_lower(publicKey),
        FfiConverterString.lower(fingerprint),
        FfiConverterTypeKeychainKind_lower(keychain),
        FfiConverterTypeNetwork_lower(network),$0
    )
})
}
    
public static func newBip49(secretKey: DescriptorSecretKey, keychain: KeychainKind, network: Network) -> Descriptor  {
    return try!  FfiConverterTypeDescriptor_lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_descriptor_new_bip49(
        FfiConverterTypeDescriptorSecretKey_lower(secretKey),
        FfiConverterTypeKeychainKind_lower(keychain),
        FfiConverterTypeNetwork_lower(network),$0
    )
})
}
    
public static func newBip49Public(publicKey: DescriptorPublicKey, fingerprint: String, keychain: KeychainKind, network: Network) -> Descriptor  {
    return try!  FfiConverterTypeDescriptor_lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_descriptor_new_bip49_public(
        FfiConverterTypeDescriptorPublicKey_lower(publicKey),
        FfiConverterString.lower(fingerprint),
        FfiConverterTypeKeychainKind_lower(keychain),
        FfiConverterTypeNetwork_lower(network),$0
    )
})
}
    
public static func newBip84(secretKey: DescriptorSecretKey, keychain: KeychainKind, network: Network) -> Descriptor  {
    return try!  FfiConverterTypeDescriptor_lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_descriptor_new_bip84(
        FfiConverterTypeDescriptorSecretKey_lower(secretKey),
        FfiConverterTypeKeychainKind_lower(keychain),
        FfiConverterTypeNetwork_lower(network),$0
    )
})
}
    
public static func newBip84Public(publicKey: DescriptorPublicKey, fingerprint: String, keychain: KeychainKind, network: Network) -> Descriptor  {
    return try!  FfiConverterTypeDescriptor_lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_descriptor_new_bip84_public(
        FfiConverterTypeDescriptorPublicKey_lower(publicKey),
        FfiConverterString.lower(fingerprint),
        FfiConverterTypeKeychainKind_lower(keychain),
        FfiConverterTypeNetwork_lower(network),$0
    )
})
}
    
public static func newBip86(secretKey: DescriptorSecretKey, keychain: KeychainKind, network: Network) -> Descriptor  {
    return try!  FfiConverterTypeDescriptor_lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_descriptor_new_bip86(
        FfiConverterTypeDescriptorSecretKey_lower(secretKey),
        FfiConverterTypeKeychainKind_lower(keychain),
        FfiConverterTypeNetwork_lower(network),$0
    )
})
}
    
public static func newBip86Public(publicKey: DescriptorPublicKey, fingerprint: String, keychain: KeychainKind, network: Network) -> Descriptor  {
    return try!  FfiConverterTypeDescriptor_lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_descriptor_new_bip86_public(
        FfiConverterTypeDescriptorPublicKey_lower(publicKey),
        FfiConverterString.lower(fingerprint),
        FfiConverterTypeKeychainKind_lower(keychain),
        FfiConverterTypeNetwork_lower(network),$0
    )
})
}
    

    
    /**
     * Whether or not this key has multiple derivation paths.
     */
open func isMultipath() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_descriptor_is_multipath(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get as many descriptors as different paths in this descriptor.
     *
     * For multipath descriptors it will return as many descriptors as there is
     * "parallel" paths. For regular descriptors it will just return itself.
     */
open func toSingleDescriptors()throws  -> [Descriptor]  {
    return try  FfiConverterSequenceTypeDescriptor.lift(try rustCallWithError(FfiConverterTypeMiniscriptError_lift) {
    uniffi_bdkffi_fn_method_descriptor_to_single_descriptors(self.uniffiClonePointer(),$0
    )
})
}
    
open func toStringWithSecret() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_descriptor_to_string_with_secret(self.uniffiClonePointer(),$0
    )
})
}
    
    open var description: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_descriptor_uniffi_trait_display(self.uniffiClonePointer(),$0
    )
}
        )
    }

}
extension Descriptor: CustomStringConvertible {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDescriptor: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Descriptor

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Descriptor {
        return Descriptor(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Descriptor) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Descriptor {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Descriptor, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDescriptor_lift(_ pointer: UnsafeMutableRawPointer) throws -> Descriptor {
    return try FfiConverterTypeDescriptor.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDescriptor_lower(_ value: Descriptor) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDescriptor.lower(value)
}






public protocol DescriptorPublicKeyProtocol: AnyObject, Sendable {
    
    func asString()  -> String
    
    func derive(path: DerivationPath) throws  -> DescriptorPublicKey
    
    func extend(path: DerivationPath) throws  -> DescriptorPublicKey
    
    /**
     * Whether or not this key has multiple derivation paths.
     */
    func isMultipath()  -> Bool
    
    /**
     * The fingerprint of the master key associated with this key, `0x00000000` if none.
     */
    func masterFingerprint()  -> String
    
}
open class DescriptorPublicKey: DescriptorPublicKeyProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_descriptorpublickey(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_descriptorpublickey(pointer, $0) }
    }

    
public static func fromString(publicKey: String)throws  -> DescriptorPublicKey  {
    return try  FfiConverterTypeDescriptorPublicKey_lift(try rustCallWithError(FfiConverterTypeDescriptorKeyError_lift) {
    uniffi_bdkffi_fn_constructor_descriptorpublickey_from_string(
        FfiConverterString.lower(publicKey),$0
    )
})
}
    

    
open func asString() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_descriptorpublickey_as_string(self.uniffiClonePointer(),$0
    )
})
}
    
open func derive(path: DerivationPath)throws  -> DescriptorPublicKey  {
    return try  FfiConverterTypeDescriptorPublicKey_lift(try rustCallWithError(FfiConverterTypeDescriptorKeyError_lift) {
    uniffi_bdkffi_fn_method_descriptorpublickey_derive(self.uniffiClonePointer(),
        FfiConverterTypeDerivationPath_lower(path),$0
    )
})
}
    
open func extend(path: DerivationPath)throws  -> DescriptorPublicKey  {
    return try  FfiConverterTypeDescriptorPublicKey_lift(try rustCallWithError(FfiConverterTypeDescriptorKeyError_lift) {
    uniffi_bdkffi_fn_method_descriptorpublickey_extend(self.uniffiClonePointer(),
        FfiConverterTypeDerivationPath_lower(path),$0
    )
})
}
    
    /**
     * Whether or not this key has multiple derivation paths.
     */
open func isMultipath() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_descriptorpublickey_is_multipath(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The fingerprint of the master key associated with this key, `0x00000000` if none.
     */
open func masterFingerprint() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_descriptorpublickey_master_fingerprint(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDescriptorPublicKey: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = DescriptorPublicKey

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> DescriptorPublicKey {
        return DescriptorPublicKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: DescriptorPublicKey) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DescriptorPublicKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: DescriptorPublicKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDescriptorPublicKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> DescriptorPublicKey {
    return try FfiConverterTypeDescriptorPublicKey.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDescriptorPublicKey_lower(_ value: DescriptorPublicKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDescriptorPublicKey.lower(value)
}






public protocol DescriptorSecretKeyProtocol: AnyObject, Sendable {
    
    func asPublic()  -> DescriptorPublicKey
    
    func asString()  -> String
    
    func derive(path: DerivationPath) throws  -> DescriptorSecretKey
    
    func extend(path: DerivationPath) throws  -> DescriptorSecretKey
    
    func secretBytes()  -> [UInt8]
    
}
open class DescriptorSecretKey: DescriptorSecretKeyProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_descriptorsecretkey(self.pointer, $0) }
    }
public convenience init(network: Network, mnemonic: Mnemonic, password: String?) {
    let pointer =
        try! rustCall() {
    uniffi_bdkffi_fn_constructor_descriptorsecretkey_new(
        FfiConverterTypeNetwork_lower(network),
        FfiConverterTypeMnemonic_lower(mnemonic),
        FfiConverterOptionString.lower(password),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_descriptorsecretkey(pointer, $0) }
    }

    
public static func fromString(secretKey: String)throws  -> DescriptorSecretKey  {
    return try  FfiConverterTypeDescriptorSecretKey_lift(try rustCallWithError(FfiConverterTypeDescriptorKeyError_lift) {
    uniffi_bdkffi_fn_constructor_descriptorsecretkey_from_string(
        FfiConverterString.lower(secretKey),$0
    )
})
}
    

    
open func asPublic() -> DescriptorPublicKey  {
    return try!  FfiConverterTypeDescriptorPublicKey_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_descriptorsecretkey_as_public(self.uniffiClonePointer(),$0
    )
})
}
    
open func asString() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_descriptorsecretkey_as_string(self.uniffiClonePointer(),$0
    )
})
}
    
open func derive(path: DerivationPath)throws  -> DescriptorSecretKey  {
    return try  FfiConverterTypeDescriptorSecretKey_lift(try rustCallWithError(FfiConverterTypeDescriptorKeyError_lift) {
    uniffi_bdkffi_fn_method_descriptorsecretkey_derive(self.uniffiClonePointer(),
        FfiConverterTypeDerivationPath_lower(path),$0
    )
})
}
    
open func extend(path: DerivationPath)throws  -> DescriptorSecretKey  {
    return try  FfiConverterTypeDescriptorSecretKey_lift(try rustCallWithError(FfiConverterTypeDescriptorKeyError_lift) {
    uniffi_bdkffi_fn_method_descriptorsecretkey_extend(self.uniffiClonePointer(),
        FfiConverterTypeDerivationPath_lower(path),$0
    )
})
}
    
open func secretBytes() -> [UInt8]  {
    return try!  FfiConverterSequenceUInt8.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_descriptorsecretkey_secret_bytes(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDescriptorSecretKey: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = DescriptorSecretKey

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> DescriptorSecretKey {
        return DescriptorSecretKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: DescriptorSecretKey) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DescriptorSecretKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: DescriptorSecretKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDescriptorSecretKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> DescriptorSecretKey {
    return try FfiConverterTypeDescriptorSecretKey.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDescriptorSecretKey_lower(_ value: DescriptorSecretKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDescriptorSecretKey.lower(value)
}






/**
 * Wrapper around an electrum_client::ElectrumApi which includes an internal in-memory transaction
 * cache to avoid re-fetching already downloaded transactions.
 */
public protocol ElectrumClientProtocol: AnyObject, Sendable {
    
    /**
     * Subscribes to notifications for new block headers, by sending a blockchain.headers.subscribe call.
     */
    func blockHeadersSubscribe() throws  -> HeaderNotification
    
    /**
     * Estimates the fee required in bitcoin per kilobyte to confirm a transaction in `number` blocks.
     */
    func estimateFee(number: UInt64) throws  -> Double
    
    /**
     * Full scan the keychain scripts specified with the blockchain (via an Electrum client) and
     * returns updates for bdk_chain data structures.
     *
     * - `request`: struct with data required to perform a spk-based blockchain client
     *   full scan, see `FullScanRequest`.
     * - `stop_gap`: the full scan for each keychain stops after a gap of script pubkeys with no
     *   associated transactions.
     * - `batch_size`: specifies the max number of script pubkeys to request for in a single batch
     *   request.
     * - `fetch_prev_txouts`: specifies whether we want previous `TxOuts` for fee calculation. Note
     *   that this requires additional calls to the Electrum server, but is necessary for
     *   calculating the fee on a transaction if your wallet does not own the inputs. Methods like
     *   `Wallet.calculate_fee` and `Wallet.calculate_fee_rate` will return a
     *   `CalculateFeeError::MissingTxOut` error if those TxOuts are not present in the transaction
     *   graph.
     */
    func fullScan(request: FullScanRequest, stopGap: UInt64, batchSize: UInt64, fetchPrevTxouts: Bool) throws  -> Update
    
    /**
     * Pings the server.
     */
    func ping() throws 
    
    /**
     * Returns the capabilities of the server.
     */
    func serverFeatures() throws  -> ServerFeaturesRes
    
    /**
     * Sync a set of scripts with the blockchain (via an Electrum client) for the data specified and returns updates for bdk_chain data structures.
     *
     * - `request`: struct with data required to perform a spk-based blockchain client
     *   sync, see `SyncRequest`.
     * - `batch_size`: specifies the max number of script pubkeys to request for in a single batch
     *   request.
     * - `fetch_prev_txouts`: specifies whether we want previous `TxOuts` for fee calculation. Note
     *   that this requires additional calls to the Electrum server, but is necessary for
     *   calculating the fee on a transaction if your wallet does not own the inputs. Methods like
     *   `Wallet.calculate_fee` and `Wallet.calculate_fee_rate` will return a
     *   `CalculateFeeError::MissingTxOut` error if those TxOuts are not present in the transaction
     *   graph.
     *
     * If the scripts to sync are unknown, such as when restoring or importing a keychain that may
     * include scripts that have been used, use full_scan with the keychain.
     */
    func sync(request: SyncRequest, batchSize: UInt64, fetchPrevTxouts: Bool) throws  -> Update
    
    /**
     * Broadcasts a transaction to the network.
     */
    func transactionBroadcast(tx: Transaction) throws  -> String
    
}
/**
 * Wrapper around an electrum_client::ElectrumApi which includes an internal in-memory transaction
 * cache to avoid re-fetching already downloaded transactions.
 */
open class ElectrumClient: ElectrumClientProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_electrumclient(self.pointer, $0) }
    }
    /**
     * Creates a new bdk client from a electrum_client::ElectrumApi
     * Optional: Set the proxy of the builder
     */
public convenience init(url: String, socks5: String? = nil)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeElectrumError_lift) {
    uniffi_bdkffi_fn_constructor_electrumclient_new(
        FfiConverterString.lower(url),
        FfiConverterOptionString.lower(socks5),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_electrumclient(pointer, $0) }
    }

    

    
    /**
     * Subscribes to notifications for new block headers, by sending a blockchain.headers.subscribe call.
     */
open func blockHeadersSubscribe()throws  -> HeaderNotification  {
    return try  FfiConverterTypeHeaderNotification_lift(try rustCallWithError(FfiConverterTypeElectrumError_lift) {
    uniffi_bdkffi_fn_method_electrumclient_block_headers_subscribe(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Estimates the fee required in bitcoin per kilobyte to confirm a transaction in `number` blocks.
     */
open func estimateFee(number: UInt64)throws  -> Double  {
    return try  FfiConverterDouble.lift(try rustCallWithError(FfiConverterTypeElectrumError_lift) {
    uniffi_bdkffi_fn_method_electrumclient_estimate_fee(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(number),$0
    )
})
}
    
    /**
     * Full scan the keychain scripts specified with the blockchain (via an Electrum client) and
     * returns updates for bdk_chain data structures.
     *
     * - `request`: struct with data required to perform a spk-based blockchain client
     *   full scan, see `FullScanRequest`.
     * - `stop_gap`: the full scan for each keychain stops after a gap of script pubkeys with no
     *   associated transactions.
     * - `batch_size`: specifies the max number of script pubkeys to request for in a single batch
     *   request.
     * - `fetch_prev_txouts`: specifies whether we want previous `TxOuts` for fee calculation. Note
     *   that this requires additional calls to the Electrum server, but is necessary for
     *   calculating the fee on a transaction if your wallet does not own the inputs. Methods like
     *   `Wallet.calculate_fee` and `Wallet.calculate_fee_rate` will return a
     *   `CalculateFeeError::MissingTxOut` error if those TxOuts are not present in the transaction
     *   graph.
     */
open func fullScan(request: FullScanRequest, stopGap: UInt64, batchSize: UInt64, fetchPrevTxouts: Bool)throws  -> Update  {
    return try  FfiConverterTypeUpdate_lift(try rustCallWithError(FfiConverterTypeElectrumError_lift) {
    uniffi_bdkffi_fn_method_electrumclient_full_scan(self.uniffiClonePointer(),
        FfiConverterTypeFullScanRequest_lower(request),
        FfiConverterUInt64.lower(stopGap),
        FfiConverterUInt64.lower(batchSize),
        FfiConverterBool.lower(fetchPrevTxouts),$0
    )
})
}
    
    /**
     * Pings the server.
     */
open func ping()throws   {try rustCallWithError(FfiConverterTypeElectrumError_lift) {
    uniffi_bdkffi_fn_method_electrumclient_ping(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Returns the capabilities of the server.
     */
open func serverFeatures()throws  -> ServerFeaturesRes  {
    return try  FfiConverterTypeServerFeaturesRes_lift(try rustCallWithError(FfiConverterTypeElectrumError_lift) {
    uniffi_bdkffi_fn_method_electrumclient_server_features(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Sync a set of scripts with the blockchain (via an Electrum client) for the data specified and returns updates for bdk_chain data structures.
     *
     * - `request`: struct with data required to perform a spk-based blockchain client
     *   sync, see `SyncRequest`.
     * - `batch_size`: specifies the max number of script pubkeys to request for in a single batch
     *   request.
     * - `fetch_prev_txouts`: specifies whether we want previous `TxOuts` for fee calculation. Note
     *   that this requires additional calls to the Electrum server, but is necessary for
     *   calculating the fee on a transaction if your wallet does not own the inputs. Methods like
     *   `Wallet.calculate_fee` and `Wallet.calculate_fee_rate` will return a
     *   `CalculateFeeError::MissingTxOut` error if those TxOuts are not present in the transaction
     *   graph.
     *
     * If the scripts to sync are unknown, such as when restoring or importing a keychain that may
     * include scripts that have been used, use full_scan with the keychain.
     */
open func sync(request: SyncRequest, batchSize: UInt64, fetchPrevTxouts: Bool)throws  -> Update  {
    return try  FfiConverterTypeUpdate_lift(try rustCallWithError(FfiConverterTypeElectrumError_lift) {
    uniffi_bdkffi_fn_method_electrumclient_sync(self.uniffiClonePointer(),
        FfiConverterTypeSyncRequest_lower(request),
        FfiConverterUInt64.lower(batchSize),
        FfiConverterBool.lower(fetchPrevTxouts),$0
    )
})
}
    
    /**
     * Broadcasts a transaction to the network.
     */
open func transactionBroadcast(tx: Transaction)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeElectrumError_lift) {
    uniffi_bdkffi_fn_method_electrumclient_transaction_broadcast(self.uniffiClonePointer(),
        FfiConverterTypeTransaction_lower(tx),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeElectrumClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ElectrumClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ElectrumClient {
        return ElectrumClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ElectrumClient) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ElectrumClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ElectrumClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeElectrumClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> ElectrumClient {
    return try FfiConverterTypeElectrumClient.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeElectrumClient_lower(_ value: ElectrumClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeElectrumClient.lower(value)
}






/**
 * Wrapper around an esplora_client::BlockingClient which includes an internal in-memory transaction
 * cache to avoid re-fetching already downloaded transactions.
 */
public protocol EsploraClientProtocol: AnyObject, Sendable {
    
    /**
     * Broadcast a [`Transaction`] to Esplora.
     */
    func broadcast(transaction: Transaction) throws 
    
    /**
     * Scan keychain scripts for transactions against Esplora, returning an update that can be
     * applied to the receiving structures.
     *
     * `request` provides the data required to perform a script-pubkey-based full scan
     * (see [`FullScanRequest`]). The full scan for each keychain (`K`) stops after a gap of
     * `stop_gap` script pubkeys with no associated transactions. `parallel_requests` specifies
     * the maximum number of HTTP requests to make in parallel.
     */
    func fullScan(request: FullScanRequest, stopGap: UInt64, parallelRequests: UInt64) throws  -> Update
    
    /**
     * Get the [`BlockHash`] of a specific block height
     */
    func getBlockHash(blockHeight: UInt32) throws  -> String
    
    /**
     * Get a map where the key is the confirmation target (in number of
     * blocks) and the value is the estimated feerate (in sat/vB).
     */
    func getFeeEstimates() throws  -> [UInt16: Double]
    
    /**
     * Get the height of the current blockchain tip.
     */
    func getHeight() throws  -> UInt32
    
    /**
     * Get a [`Transaction`] option given its [`Txid`].
     */
    func getTx(txid: String) throws  -> Transaction?
    
    /**
     * Get transaction info given it's [`Txid`].
     */
    func getTxInfo(txid: String) throws  -> Tx?
    
    /**
     * Get the status of a [`Transaction`] given its [`Txid`].
     */
    func getTxStatus(txid: String) throws  -> TxStatus
    
    /**
     * Sync a set of scripts, txids, and/or outpoints against Esplora.
     *
     * `request` provides the data required to perform a script-pubkey-based sync (see
     * [`SyncRequest`]). `parallel_requests` specifies the maximum number of HTTP requests to make
     * in parallel.
     */
    func sync(request: SyncRequest, parallelRequests: UInt64) throws  -> Update
    
}
/**
 * Wrapper around an esplora_client::BlockingClient which includes an internal in-memory transaction
 * cache to avoid re-fetching already downloaded transactions.
 */
open class EsploraClient: EsploraClientProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_esploraclient(self.pointer, $0) }
    }
    /**
     * Creates a new bdk client from a esplora_client::BlockingClient
     * Optional: Set the proxy of the builder
     */
public convenience init(url: String, proxy: String? = nil) {
    let pointer =
        try! rustCall() {
    uniffi_bdkffi_fn_constructor_esploraclient_new(
        FfiConverterString.lower(url),
        FfiConverterOptionString.lower(proxy),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_esploraclient(pointer, $0) }
    }

    

    
    /**
     * Broadcast a [`Transaction`] to Esplora.
     */
open func broadcast(transaction: Transaction)throws   {try rustCallWithError(FfiConverterTypeEsploraError_lift) {
    uniffi_bdkffi_fn_method_esploraclient_broadcast(self.uniffiClonePointer(),
        FfiConverterTypeTransaction_lower(transaction),$0
    )
}
}
    
    /**
     * Scan keychain scripts for transactions against Esplora, returning an update that can be
     * applied to the receiving structures.
     *
     * `request` provides the data required to perform a script-pubkey-based full scan
     * (see [`FullScanRequest`]). The full scan for each keychain (`K`) stops after a gap of
     * `stop_gap` script pubkeys with no associated transactions. `parallel_requests` specifies
     * the maximum number of HTTP requests to make in parallel.
     */
open func fullScan(request: FullScanRequest, stopGap: UInt64, parallelRequests: UInt64)throws  -> Update  {
    return try  FfiConverterTypeUpdate_lift(try rustCallWithError(FfiConverterTypeEsploraError_lift) {
    uniffi_bdkffi_fn_method_esploraclient_full_scan(self.uniffiClonePointer(),
        FfiConverterTypeFullScanRequest_lower(request),
        FfiConverterUInt64.lower(stopGap),
        FfiConverterUInt64.lower(parallelRequests),$0
    )
})
}
    
    /**
     * Get the [`BlockHash`] of a specific block height
     */
open func getBlockHash(blockHeight: UInt32)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeEsploraError_lift) {
    uniffi_bdkffi_fn_method_esploraclient_get_block_hash(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(blockHeight),$0
    )
})
}
    
    /**
     * Get a map where the key is the confirmation target (in number of
     * blocks) and the value is the estimated feerate (in sat/vB).
     */
open func getFeeEstimates()throws  -> [UInt16: Double]  {
    return try  FfiConverterDictionaryUInt16Double.lift(try rustCallWithError(FfiConverterTypeEsploraError_lift) {
    uniffi_bdkffi_fn_method_esploraclient_get_fee_estimates(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get the height of the current blockchain tip.
     */
open func getHeight()throws  -> UInt32  {
    return try  FfiConverterUInt32.lift(try rustCallWithError(FfiConverterTypeEsploraError_lift) {
    uniffi_bdkffi_fn_method_esploraclient_get_height(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get a [`Transaction`] option given its [`Txid`].
     */
open func getTx(txid: String)throws  -> Transaction?  {
    return try  FfiConverterOptionTypeTransaction.lift(try rustCallWithError(FfiConverterTypeEsploraError_lift) {
    uniffi_bdkffi_fn_method_esploraclient_get_tx(self.uniffiClonePointer(),
        FfiConverterString.lower(txid),$0
    )
})
}
    
    /**
     * Get transaction info given it's [`Txid`].
     */
open func getTxInfo(txid: String)throws  -> Tx?  {
    return try  FfiConverterOptionTypeTx.lift(try rustCallWithError(FfiConverterTypeEsploraError_lift) {
    uniffi_bdkffi_fn_method_esploraclient_get_tx_info(self.uniffiClonePointer(),
        FfiConverterString.lower(txid),$0
    )
})
}
    
    /**
     * Get the status of a [`Transaction`] given its [`Txid`].
     */
open func getTxStatus(txid: String)throws  -> TxStatus  {
    return try  FfiConverterTypeTxStatus_lift(try rustCallWithError(FfiConverterTypeEsploraError_lift) {
    uniffi_bdkffi_fn_method_esploraclient_get_tx_status(self.uniffiClonePointer(),
        FfiConverterString.lower(txid),$0
    )
})
}
    
    /**
     * Sync a set of scripts, txids, and/or outpoints against Esplora.
     *
     * `request` provides the data required to perform a script-pubkey-based sync (see
     * [`SyncRequest`]). `parallel_requests` specifies the maximum number of HTTP requests to make
     * in parallel.
     */
open func sync(request: SyncRequest, parallelRequests: UInt64)throws  -> Update  {
    return try  FfiConverterTypeUpdate_lift(try rustCallWithError(FfiConverterTypeEsploraError_lift) {
    uniffi_bdkffi_fn_method_esploraclient_sync(self.uniffiClonePointer(),
        FfiConverterTypeSyncRequest_lower(request),
        FfiConverterUInt64.lower(parallelRequests),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEsploraClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = EsploraClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EsploraClient {
        return EsploraClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: EsploraClient) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EsploraClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: EsploraClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEsploraClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> EsploraClient {
    return try FfiConverterTypeEsploraClient.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEsploraClient_lower(_ value: EsploraClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEsploraClient.lower(value)
}






/**
 * Represents fee rate.
 *
 * This is an integer type representing fee rate in sat/kwu. It provides protection against mixing
 * up the types as well as basic formatting features.
 */
public protocol FeeRateProtocol: AnyObject, Sendable {
    
    func toSatPerKwu()  -> UInt64
    
    func toSatPerVbCeil()  -> UInt64
    
    func toSatPerVbFloor()  -> UInt64
    
}
/**
 * Represents fee rate.
 *
 * This is an integer type representing fee rate in sat/kwu. It provides protection against mixing
 * up the types as well as basic formatting features.
 */
open class FeeRate: FeeRateProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_feerate(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_feerate(pointer, $0) }
    }

    
public static func fromSatPerKwu(satKwu: UInt64) -> FeeRate  {
    return try!  FfiConverterTypeFeeRate_lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_feerate_from_sat_per_kwu(
        FfiConverterUInt64.lower(satKwu),$0
    )
})
}
    
public static func fromSatPerVb(satVb: UInt64)throws  -> FeeRate  {
    return try  FfiConverterTypeFeeRate_lift(try rustCallWithError(FfiConverterTypeFeeRateError_lift) {
    uniffi_bdkffi_fn_constructor_feerate_from_sat_per_vb(
        FfiConverterUInt64.lower(satVb),$0
    )
})
}
    

    
open func toSatPerKwu() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_feerate_to_sat_per_kwu(self.uniffiClonePointer(),$0
    )
})
}
    
open func toSatPerVbCeil() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_feerate_to_sat_per_vb_ceil(self.uniffiClonePointer(),$0
    )
})
}
    
open func toSatPerVbFloor() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_feerate_to_sat_per_vb_floor(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFeeRate: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FeeRate

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRate {
        return FeeRate(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FeeRate) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeRate {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FeeRate, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRate_lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRate {
    return try FfiConverterTypeFeeRate.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRate_lower(_ value: FeeRate) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFeeRate.lower(value)
}






public protocol FullScanRequestProtocol: AnyObject, Sendable {
    
}
open class FullScanRequest: FullScanRequestProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_fullscanrequest(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_fullscanrequest(pointer, $0) }
    }

    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFullScanRequest: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FullScanRequest

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FullScanRequest {
        return FullScanRequest(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FullScanRequest) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FullScanRequest {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FullScanRequest, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFullScanRequest_lift(_ pointer: UnsafeMutableRawPointer) throws -> FullScanRequest {
    return try FfiConverterTypeFullScanRequest.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFullScanRequest_lower(_ value: FullScanRequest) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFullScanRequest.lower(value)
}






/**
 * Builds a [`FullScanRequest`].
 */
public protocol FullScanRequestBuilderProtocol: AnyObject, Sendable {
    
    func build() throws  -> FullScanRequest
    
    func inspectSpksForAllKeychains(inspector: FullScanScriptInspector) throws  -> FullScanRequestBuilder
    
}
/**
 * Builds a [`FullScanRequest`].
 */
open class FullScanRequestBuilder: FullScanRequestBuilderProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_fullscanrequestbuilder(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_fullscanrequestbuilder(pointer, $0) }
    }

    

    
open func build()throws  -> FullScanRequest  {
    return try  FfiConverterTypeFullScanRequest_lift(try rustCallWithError(FfiConverterTypeRequestBuilderError_lift) {
    uniffi_bdkffi_fn_method_fullscanrequestbuilder_build(self.uniffiClonePointer(),$0
    )
})
}
    
open func inspectSpksForAllKeychains(inspector: FullScanScriptInspector)throws  -> FullScanRequestBuilder  {
    return try  FfiConverterTypeFullScanRequestBuilder_lift(try rustCallWithError(FfiConverterTypeRequestBuilderError_lift) {
    uniffi_bdkffi_fn_method_fullscanrequestbuilder_inspect_spks_for_all_keychains(self.uniffiClonePointer(),
        FfiConverterTypeFullScanScriptInspector_lower(inspector),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFullScanRequestBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FullScanRequestBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FullScanRequestBuilder {
        return FullScanRequestBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FullScanRequestBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FullScanRequestBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FullScanRequestBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFullScanRequestBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> FullScanRequestBuilder {
    return try FfiConverterTypeFullScanRequestBuilder.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFullScanRequestBuilder_lower(_ value: FullScanRequestBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFullScanRequestBuilder.lower(value)
}






public protocol FullScanScriptInspector: AnyObject, Sendable {
    
    func inspect(keychain: KeychainKind, index: UInt32, script: Script) 
    
}
open class FullScanScriptInspectorImpl: FullScanScriptInspector, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_fullscanscriptinspector(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_fullscanscriptinspector(pointer, $0) }
    }

    

    
open func inspect(keychain: KeychainKind, index: UInt32, script: Script)  {try! rustCall() {
    uniffi_bdkffi_fn_method_fullscanscriptinspector_inspect(self.uniffiClonePointer(),
        FfiConverterTypeKeychainKind_lower(keychain),
        FfiConverterUInt32.lower(index),
        FfiConverterTypeScript_lower(script),$0
    )
}
}
    

}
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceFullScanScriptInspector {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceFullScanScriptInspector] = [UniffiVTableCallbackInterfaceFullScanScriptInspector(
        inspect: { (
            uniffiHandle: UInt64,
            keychain: RustBuffer,
            index: UInt32,
            script: UnsafeMutableRawPointer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeFullScanScriptInspector.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.inspect(
                     keychain: try FfiConverterTypeKeychainKind_lift(keychain),
                     index: try FfiConverterUInt32.lift(index),
                     script: try FfiConverterTypeScript_lift(script)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeFullScanScriptInspector.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface FullScanScriptInspector: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitFullScanScriptInspector() {
    uniffi_bdkffi_fn_init_callback_vtable_fullscanscriptinspector(UniffiCallbackInterfaceFullScanScriptInspector.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFullScanScriptInspector: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<FullScanScriptInspector>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FullScanScriptInspector

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FullScanScriptInspector {
        return FullScanScriptInspectorImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FullScanScriptInspector) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FullScanScriptInspector {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FullScanScriptInspector, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFullScanScriptInspector_lift(_ pointer: UnsafeMutableRawPointer) throws -> FullScanScriptInspector {
    return try FfiConverterTypeFullScanScriptInspector.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFullScanScriptInspector_lower(_ value: FullScanScriptInspector) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFullScanScriptInspector.lower(value)
}






/**
 * An IP address to connect to over TCP.
 */
public protocol IpAddressProtocol: AnyObject, Sendable {
    
}
/**
 * An IP address to connect to over TCP.
 */
open class IpAddress: IpAddressProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_ipaddress(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_ipaddress(pointer, $0) }
    }

    
    /**
     * Build an IPv4 address.
     */
public static func fromIpv4(q1: UInt8, q2: UInt8, q3: UInt8, q4: UInt8) -> IpAddress  {
    return try!  FfiConverterTypeIpAddress_lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_ipaddress_from_ipv4(
        FfiConverterUInt8.lower(q1),
        FfiConverterUInt8.lower(q2),
        FfiConverterUInt8.lower(q3),
        FfiConverterUInt8.lower(q4),$0
    )
})
}
    
    /**
     * Build an IPv6 address.
     */
public static func fromIpv6(a: UInt16, b: UInt16, c: UInt16, d: UInt16, e: UInt16, f: UInt16, g: UInt16, h: UInt16) -> IpAddress  {
    return try!  FfiConverterTypeIpAddress_lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_ipaddress_from_ipv6(
        FfiConverterUInt16.lower(a),
        FfiConverterUInt16.lower(b),
        FfiConverterUInt16.lower(c),
        FfiConverterUInt16.lower(d),
        FfiConverterUInt16.lower(e),
        FfiConverterUInt16.lower(f),
        FfiConverterUInt16.lower(g),
        FfiConverterUInt16.lower(h),$0
    )
})
}
    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIpAddress: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = IpAddress

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> IpAddress {
        return IpAddress(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: IpAddress) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IpAddress {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: IpAddress, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIpAddress_lift(_ pointer: UnsafeMutableRawPointer) throws -> IpAddress {
    return try FfiConverterTypeIpAddress.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIpAddress_lower(_ value: IpAddress) -> UnsafeMutableRawPointer {
    return FfiConverterTypeIpAddress.lower(value)
}






public protocol MnemonicProtocol: AnyObject, Sendable {
    
}
open class Mnemonic: MnemonicProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_mnemonic(self.pointer, $0) }
    }
public convenience init(wordCount: WordCount) {
    let pointer =
        try! rustCall() {
    uniffi_bdkffi_fn_constructor_mnemonic_new(
        FfiConverterTypeWordCount_lower(wordCount),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_mnemonic(pointer, $0) }
    }

    
public static func fromEntropy(entropy: [UInt8])throws  -> Mnemonic  {
    return try  FfiConverterTypeMnemonic_lift(try rustCallWithError(FfiConverterTypeBip39Error_lift) {
    uniffi_bdkffi_fn_constructor_mnemonic_from_entropy(
        FfiConverterSequenceUInt8.lower(entropy),$0
    )
})
}
    
public static func fromString(mnemonic: String)throws  -> Mnemonic  {
    return try  FfiConverterTypeMnemonic_lift(try rustCallWithError(FfiConverterTypeBip39Error_lift) {
    uniffi_bdkffi_fn_constructor_mnemonic_from_string(
        FfiConverterString.lower(mnemonic),$0
    )
})
}
    

    
    open var description: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_mnemonic_uniffi_trait_display(self.uniffiClonePointer(),$0
    )
}
        )
    }

}
extension Mnemonic: CustomStringConvertible {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMnemonic: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Mnemonic

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Mnemonic {
        return Mnemonic(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Mnemonic) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Mnemonic {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Mnemonic, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMnemonic_lift(_ pointer: UnsafeMutableRawPointer) throws -> Mnemonic {
    return try FfiConverterTypeMnemonic.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMnemonic_lower(_ value: Mnemonic) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMnemonic.lower(value)
}






public protocol PolicyProtocol: AnyObject, Sendable {
    
    func asString()  -> String
    
    func contribution()  -> Satisfaction
    
    func id()  -> String
    
    func item()  -> SatisfiableItem
    
    func requiresPath()  -> Bool
    
    func satisfaction()  -> Satisfaction
    
}
open class Policy: PolicyProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_policy(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_policy(pointer, $0) }
    }

    

    
open func asString() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_policy_as_string(self.uniffiClonePointer(),$0
    )
})
}
    
open func contribution() -> Satisfaction  {
    return try!  FfiConverterTypeSatisfaction_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_policy_contribution(self.uniffiClonePointer(),$0
    )
})
}
    
open func id() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_policy_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func item() -> SatisfiableItem  {
    return try!  FfiConverterTypeSatisfiableItem_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_policy_item(self.uniffiClonePointer(),$0
    )
})
}
    
open func requiresPath() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_policy_requires_path(self.uniffiClonePointer(),$0
    )
})
}
    
open func satisfaction() -> Satisfaction  {
    return try!  FfiConverterTypeSatisfaction_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_policy_satisfaction(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePolicy: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Policy

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Policy {
        return Policy(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Policy) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Policy {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Policy, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePolicy_lift(_ pointer: UnsafeMutableRawPointer) throws -> Policy {
    return try FfiConverterTypePolicy.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePolicy_lower(_ value: Policy) -> UnsafeMutableRawPointer {
    return FfiConverterTypePolicy.lower(value)
}






public protocol PsbtProtocol: AnyObject, Sendable {
    
    func combine(other: Psbt) throws  -> Psbt
    
    func extractTx() throws  -> Transaction
    
    func fee() throws  -> UInt64
    
    func finalize()  -> FinalizedPsbtResult
    
    func jsonSerialize()  -> String
    
    func serialize()  -> String
    
}
open class Psbt: PsbtProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_psbt(self.pointer, $0) }
    }
public convenience init(psbtBase64: String)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypePsbtParseError_lift) {
    uniffi_bdkffi_fn_constructor_psbt_new(
        FfiConverterString.lower(psbtBase64),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_psbt(pointer, $0) }
    }

    

    
open func combine(other: Psbt)throws  -> Psbt  {
    return try  FfiConverterTypePsbt_lift(try rustCallWithError(FfiConverterTypePsbtError_lift) {
    uniffi_bdkffi_fn_method_psbt_combine(self.uniffiClonePointer(),
        FfiConverterTypePsbt_lower(other),$0
    )
})
}
    
open func extractTx()throws  -> Transaction  {
    return try  FfiConverterTypeTransaction_lift(try rustCallWithError(FfiConverterTypeExtractTxError_lift) {
    uniffi_bdkffi_fn_method_psbt_extract_tx(self.uniffiClonePointer(),$0
    )
})
}
    
open func fee()throws  -> UInt64  {
    return try  FfiConverterUInt64.lift(try rustCallWithError(FfiConverterTypePsbtError_lift) {
    uniffi_bdkffi_fn_method_psbt_fee(self.uniffiClonePointer(),$0
    )
})
}
    
open func finalize() -> FinalizedPsbtResult  {
    return try!  FfiConverterTypeFinalizedPsbtResult_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_psbt_finalize(self.uniffiClonePointer(),$0
    )
})
}
    
open func jsonSerialize() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_psbt_json_serialize(self.uniffiClonePointer(),$0
    )
})
}
    
open func serialize() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_psbt_serialize(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePsbt: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Psbt

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Psbt {
        return Psbt(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Psbt) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Psbt {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Psbt, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePsbt_lift(_ pointer: UnsafeMutableRawPointer) throws -> Psbt {
    return try FfiConverterTypePsbt.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePsbt_lower(_ value: Psbt) -> UnsafeMutableRawPointer {
    return FfiConverterTypePsbt.lower(value)
}






public protocol ScriptProtocol: AnyObject, Sendable {
    
    func toBytes()  -> [UInt8]
    
}
open class Script: ScriptProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_script(self.pointer, $0) }
    }
public convenience init(rawOutputScript: [UInt8]) {
    let pointer =
        try! rustCall() {
    uniffi_bdkffi_fn_constructor_script_new(
        FfiConverterSequenceUInt8.lower(rawOutputScript),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_script(pointer, $0) }
    }

    

    
open func toBytes() -> [UInt8]  {
    return try!  FfiConverterSequenceUInt8.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_script_to_bytes(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeScript: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Script

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Script {
        return Script(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Script) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Script {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Script, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeScript_lift(_ pointer: UnsafeMutableRawPointer) throws -> Script {
    return try FfiConverterTypeScript.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeScript_lower(_ value: Script) -> UnsafeMutableRawPointer {
    return FfiConverterTypeScript.lower(value)
}






public protocol SyncRequestProtocol: AnyObject, Sendable {
    
}
open class SyncRequest: SyncRequestProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_syncrequest(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_syncrequest(pointer, $0) }
    }

    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSyncRequest: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SyncRequest

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SyncRequest {
        return SyncRequest(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SyncRequest) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncRequest {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SyncRequest, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncRequest_lift(_ pointer: UnsafeMutableRawPointer) throws -> SyncRequest {
    return try FfiConverterTypeSyncRequest.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncRequest_lower(_ value: SyncRequest) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSyncRequest.lower(value)
}






/**
 * Builds a [`SyncRequest`].
 */
public protocol SyncRequestBuilderProtocol: AnyObject, Sendable {
    
    func build() throws  -> SyncRequest
    
    func inspectSpks(inspector: SyncScriptInspector) throws  -> SyncRequestBuilder
    
}
/**
 * Builds a [`SyncRequest`].
 */
open class SyncRequestBuilder: SyncRequestBuilderProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_syncrequestbuilder(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_syncrequestbuilder(pointer, $0) }
    }

    

    
open func build()throws  -> SyncRequest  {
    return try  FfiConverterTypeSyncRequest_lift(try rustCallWithError(FfiConverterTypeRequestBuilderError_lift) {
    uniffi_bdkffi_fn_method_syncrequestbuilder_build(self.uniffiClonePointer(),$0
    )
})
}
    
open func inspectSpks(inspector: SyncScriptInspector)throws  -> SyncRequestBuilder  {
    return try  FfiConverterTypeSyncRequestBuilder_lift(try rustCallWithError(FfiConverterTypeRequestBuilderError_lift) {
    uniffi_bdkffi_fn_method_syncrequestbuilder_inspect_spks(self.uniffiClonePointer(),
        FfiConverterTypeSyncScriptInspector_lower(inspector),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSyncRequestBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SyncRequestBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SyncRequestBuilder {
        return SyncRequestBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SyncRequestBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncRequestBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SyncRequestBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncRequestBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> SyncRequestBuilder {
    return try FfiConverterTypeSyncRequestBuilder.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncRequestBuilder_lower(_ value: SyncRequestBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSyncRequestBuilder.lower(value)
}






public protocol SyncScriptInspector: AnyObject, Sendable {
    
    func inspect(script: Script, total: UInt64) 
    
}
open class SyncScriptInspectorImpl: SyncScriptInspector, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_syncscriptinspector(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_syncscriptinspector(pointer, $0) }
    }

    

    
open func inspect(script: Script, total: UInt64)  {try! rustCall() {
    uniffi_bdkffi_fn_method_syncscriptinspector_inspect(self.uniffiClonePointer(),
        FfiConverterTypeScript_lower(script),
        FfiConverterUInt64.lower(total),$0
    )
}
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceSyncScriptInspector {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceSyncScriptInspector] = [UniffiVTableCallbackInterfaceSyncScriptInspector(
        inspect: { (
            uniffiHandle: UInt64,
            script: UnsafeMutableRawPointer,
            total: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeSyncScriptInspector.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.inspect(
                     script: try FfiConverterTypeScript_lift(script),
                     total: try FfiConverterUInt64.lift(total)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeSyncScriptInspector.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface SyncScriptInspector: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitSyncScriptInspector() {
    uniffi_bdkffi_fn_init_callback_vtable_syncscriptinspector(UniffiCallbackInterfaceSyncScriptInspector.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSyncScriptInspector: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<SyncScriptInspector>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SyncScriptInspector

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SyncScriptInspector {
        return SyncScriptInspectorImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SyncScriptInspector) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncScriptInspector {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SyncScriptInspector, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncScriptInspector_lift(_ pointer: UnsafeMutableRawPointer) throws -> SyncScriptInspector {
    return try FfiConverterTypeSyncScriptInspector.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncScriptInspector_lower(_ value: SyncScriptInspector) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSyncScriptInspector.lower(value)
}






public protocol TransactionProtocol: AnyObject, Sendable {
    
    func computeTxid()  -> String
    
    func input()  -> [TxIn]
    
    func isCoinbase()  -> Bool
    
    func isExplicitlyRbf()  -> Bool
    
    func isLockTimeEnabled()  -> Bool
    
    func lockTime()  -> UInt32
    
    func output()  -> [TxOut]
    
    func serialize()  -> [UInt8]
    
    func totalSize()  -> UInt64
    
    func version()  -> Int32
    
    func vsize()  -> UInt64
    
    func weight()  -> UInt64
    
}
open class Transaction: TransactionProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_transaction(self.pointer, $0) }
    }
public convenience init(transactionBytes: [UInt8])throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeTransactionError_lift) {
    uniffi_bdkffi_fn_constructor_transaction_new(
        FfiConverterSequenceUInt8.lower(transactionBytes),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_transaction(pointer, $0) }
    }

    

    
open func computeTxid() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_compute_txid(self.uniffiClonePointer(),$0
    )
})
}
    
open func input() -> [TxIn]  {
    return try!  FfiConverterSequenceTypeTxIn.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_input(self.uniffiClonePointer(),$0
    )
})
}
    
open func isCoinbase() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_is_coinbase(self.uniffiClonePointer(),$0
    )
})
}
    
open func isExplicitlyRbf() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_is_explicitly_rbf(self.uniffiClonePointer(),$0
    )
})
}
    
open func isLockTimeEnabled() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_is_lock_time_enabled(self.uniffiClonePointer(),$0
    )
})
}
    
open func lockTime() -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_lock_time(self.uniffiClonePointer(),$0
    )
})
}
    
open func output() -> [TxOut]  {
    return try!  FfiConverterSequenceTypeTxOut.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_output(self.uniffiClonePointer(),$0
    )
})
}
    
open func serialize() -> [UInt8]  {
    return try!  FfiConverterSequenceUInt8.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_serialize(self.uniffiClonePointer(),$0
    )
})
}
    
open func totalSize() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_total_size(self.uniffiClonePointer(),$0
    )
})
}
    
open func version() -> Int32  {
    return try!  FfiConverterInt32.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_version(self.uniffiClonePointer(),$0
    )
})
}
    
open func vsize() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_vsize(self.uniffiClonePointer(),$0
    )
})
}
    
open func weight() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_weight(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransaction: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Transaction

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Transaction {
        return Transaction(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Transaction) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Transaction {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Transaction, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransaction_lift(_ pointer: UnsafeMutableRawPointer) throws -> Transaction {
    return try FfiConverterTypeTransaction.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransaction_lower(_ value: Transaction) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTransaction.lower(value)
}






/**
 * A `TxBuilder` is created by calling `build_tx` on a wallet. After assigning it, you set options on it until finally
 * calling `finish` to consume the builder and generate the transaction.
 */
public protocol TxBuilderProtocol: AnyObject, Sendable {
    
    /**
     * Add data as an output using `OP_RETURN`.
     */
    func addData(data: Data)  -> TxBuilder
    
    /**
     * Fill-in the `PSBT_GLOBAL_XPUB` field with the extended keys contained in both the external and internal
     * descriptors.
     *
     * This is useful for offline signers that take part to a multisig. Some hardware wallets like BitBox and ColdCard
     * are known to require this.
     */
    func addGlobalXpubs()  -> TxBuilder
    
    /**
     * Add a recipient to the internal list of recipients.
     */
    func addRecipient(script: Script, amount: Amount)  -> TxBuilder
    
    /**
     * Add a utxo to the internal list of unspendable utxos.
     *
     * It’s important to note that the "must-be-spent" utxos added with `TxBuilder::add_utxo` have priority over this.
     */
    func addUnspendable(unspendable: OutPoint)  -> TxBuilder
    
    /**
     * Add a utxo to the internal list of utxos that must be spent.
     *
     * These have priority over the "unspendable" utxos, meaning that if a utxo is present both in the "utxos" and the
     * "unspendable" list, it will be spent.
     */
    func addUtxo(outpoint: OutPoint)  -> TxBuilder
    
    /**
     * Add the list of outpoints to the internal list of UTXOs that must be spent.
     */
    func addUtxos(outpoints: [OutPoint])  -> TxBuilder
    
    /**
     * Set whether or not the dust limit is checked.
     *
     * Note: by avoiding a dust limit check you may end up with a transaction that is non-standard.
     */
    func allowDust(allowDust: Bool)  -> TxBuilder
    
    /**
     * Set a specific `ChangeSpendPolicy`. See `TxBuilder::do_not_spend_change` and `TxBuilder::only_spend_change` for
     * some shortcuts. This method assumes the presence of an internal keychain, otherwise it has no effect.
     */
    func changePolicy(changePolicy: ChangeSpendPolicy)  -> TxBuilder
    
    /**
     * Set the current blockchain height.
     *
     * This will be used to:
     *
     * 1. Set the `nLockTime` for preventing fee sniping. Note: This will be ignored if you manually specify a
     * `nlocktime` using `TxBuilder::nlocktime`.
     *
     * 2. Decide whether coinbase outputs are mature or not. If the coinbase outputs are not mature at `current_height`,
     * we ignore them in the coin selection. If you want to create a transaction that spends immature coinbase inputs,
     * manually add them using `TxBuilder::add_utxos`.
     * In both cases, if you don’t provide a current height, we use the last sync height.
     */
    func currentHeight(height: UInt32)  -> TxBuilder
    
    /**
     * Do not spend change outputs.
     *
     * This effectively adds all the change outputs to the "unspendable" list. See `TxBuilder::unspendable`. This method
     * assumes the presence of an internal keychain, otherwise it has no effect.
     */
    func doNotSpendChange()  -> TxBuilder
    
    /**
     * Sets the address to drain excess coins to.
     *
     * Usually, when there are excess coins they are sent to a change address generated by the wallet. This option
     * replaces the usual change address with an arbitrary script_pubkey of your choosing. Just as with a change output,
     * if the drain output is not needed (the excess coins are too small) it will not be included in the resulting
     * transaction. The only difference is that it is valid to use `drain_to` without setting any ordinary recipients
     * with `add_recipient` (but it is perfectly fine to add recipients as well).
     *
     * If you choose not to set any recipients, you should provide the utxos that the transaction should spend via
     * `add_utxos`. `drain_to` is very useful for draining all the coins in a wallet with `drain_wallet` to a single
     * address.
     */
    func drainTo(script: Script)  -> TxBuilder
    
    /**
     * Spend all the available inputs. This respects filters like `TxBuilder::unspendable` and the change policy.
     */
    func drainWallet()  -> TxBuilder
    
    /**
     * Set an absolute fee The `fee_absolute` method refers to the absolute transaction fee in `Amount`. If anyone sets
     * both the `fee_absolute` method and the `fee_rate` method, the `FeePolicy` enum will be set by whichever method was
     * called last, as the `FeeRate` and `FeeAmount` are mutually exclusive.
     *
     * Note that this is really a minimum absolute fee – it’s possible to overshoot it slightly since adding a change output to drain the remaining excess might not be viable.
     */
    func feeAbsolute(feeAmount: Amount)  -> TxBuilder
    
    /**
     * Set a custom fee rate.
     *
     * This method sets the mining fee paid by the transaction as a rate on its size. This means that the total fee paid
     * is equal to fee_rate times the size of the transaction. Default is 1 sat/vB in accordance with Bitcoin Core’s
     * default relay policy.
     *
     * Note that this is really a minimum feerate – it’s possible to overshoot it slightly since adding a change output
     * to drain the remaining excess might not be viable.
     */
    func feeRate(feeRate: FeeRate)  -> TxBuilder
    
    /**
     * Finish building the transaction.
     *
     * Uses the thread-local random number generator (rng).
     *
     * Returns a new `Psbt` per BIP174.
     *
     * WARNING: To avoid change address reuse you must persist the changes resulting from one or more calls to this
     * method before closing the wallet. See `Wallet::reveal_next_address`.
     */
    func finish(wallet: Wallet) throws  -> Psbt
    
    /**
     * Only spend utxos added by `TxBuilder::add_utxo`.
     *
     * The wallet will not add additional utxos to the transaction even if they are needed to make the transaction valid.
     */
    func manuallySelectedOnly()  -> TxBuilder
    
    /**
     * Use a specific nLockTime while creating the transaction.
     *
     * This can cause conflicts if the wallet’s descriptors contain an "after" (`OP_CLTV`) operator.
     */
    func nlocktime(locktime: LockTime)  -> TxBuilder
    
    /**
     * Only spend change outputs.
     *
     * This effectively adds all the non-change outputs to the "unspendable" list. See `TxBuilder::unspendable`. This
     * method assumes the presence of an internal keychain, otherwise it has no effect.
     */
    func onlySpendChange()  -> TxBuilder
    
    /**
     * The TxBuilder::policy_path is a complex API. See the Rust docs for complete       information: https://docs.rs/bdk_wallet/latest/bdk_wallet/struct.TxBuilder.html#method.policy_path
     */
    func policyPath(policyPath: [String: [UInt64]], keychain: KeychainKind)  -> TxBuilder
    
    /**
     * Set an exact `nSequence` value.
     *
     * This can cause conflicts if the wallet’s descriptors contain an "older" (`OP_CSV`) operator and the given
     * `nsequence` is lower than the CSV value.
     */
    func setExactSequence(nsequence: UInt32)  -> TxBuilder
    
    /**
     * Replace the recipients already added with a new list of recipients.
     */
    func setRecipients(recipients: [ScriptAmount])  -> TxBuilder
    
    /**
     * Replace the internal list of unspendable utxos with a new list.
     *
     * It’s important to note that the "must-be-spent" utxos added with `TxBuilder::add_utxo` have priority over these.
     */
    func unspendable(unspendable: [OutPoint])  -> TxBuilder
    
    /**
     * Build a transaction with a specific version.
     *
     * The version should always be greater than 0 and greater than 1 if the wallet’s descriptors contain an "older"
     * (`OP_CSV`) operator.
     */
    func version(version: Int32)  -> TxBuilder
    
}
/**
 * A `TxBuilder` is created by calling `build_tx` on a wallet. After assigning it, you set options on it until finally
 * calling `finish` to consume the builder and generate the transaction.
 */
open class TxBuilder: TxBuilderProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_txbuilder(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_bdkffi_fn_constructor_txbuilder_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_txbuilder(pointer, $0) }
    }

    

    
    /**
     * Add data as an output using `OP_RETURN`.
     */
open func addData(data: Data) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_add_data(self.uniffiClonePointer(),
        FfiConverterData.lower(data),$0
    )
})
}
    
    /**
     * Fill-in the `PSBT_GLOBAL_XPUB` field with the extended keys contained in both the external and internal
     * descriptors.
     *
     * This is useful for offline signers that take part to a multisig. Some hardware wallets like BitBox and ColdCard
     * are known to require this.
     */
open func addGlobalXpubs() -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_add_global_xpubs(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Add a recipient to the internal list of recipients.
     */
open func addRecipient(script: Script, amount: Amount) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_add_recipient(self.uniffiClonePointer(),
        FfiConverterTypeScript_lower(script),
        FfiConverterTypeAmount_lower(amount),$0
    )
})
}
    
    /**
     * Add a utxo to the internal list of unspendable utxos.
     *
     * It’s important to note that the "must-be-spent" utxos added with `TxBuilder::add_utxo` have priority over this.
     */
open func addUnspendable(unspendable: OutPoint) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_add_unspendable(self.uniffiClonePointer(),
        FfiConverterTypeOutPoint_lower(unspendable),$0
    )
})
}
    
    /**
     * Add a utxo to the internal list of utxos that must be spent.
     *
     * These have priority over the "unspendable" utxos, meaning that if a utxo is present both in the "utxos" and the
     * "unspendable" list, it will be spent.
     */
open func addUtxo(outpoint: OutPoint) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_add_utxo(self.uniffiClonePointer(),
        FfiConverterTypeOutPoint_lower(outpoint),$0
    )
})
}
    
    /**
     * Add the list of outpoints to the internal list of UTXOs that must be spent.
     */
open func addUtxos(outpoints: [OutPoint]) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_add_utxos(self.uniffiClonePointer(),
        FfiConverterSequenceTypeOutPoint.lower(outpoints),$0
    )
})
}
    
    /**
     * Set whether or not the dust limit is checked.
     *
     * Note: by avoiding a dust limit check you may end up with a transaction that is non-standard.
     */
open func allowDust(allowDust: Bool) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_allow_dust(self.uniffiClonePointer(),
        FfiConverterBool.lower(allowDust),$0
    )
})
}
    
    /**
     * Set a specific `ChangeSpendPolicy`. See `TxBuilder::do_not_spend_change` and `TxBuilder::only_spend_change` for
     * some shortcuts. This method assumes the presence of an internal keychain, otherwise it has no effect.
     */
open func changePolicy(changePolicy: ChangeSpendPolicy) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_change_policy(self.uniffiClonePointer(),
        FfiConverterTypeChangeSpendPolicy_lower(changePolicy),$0
    )
})
}
    
    /**
     * Set the current blockchain height.
     *
     * This will be used to:
     *
     * 1. Set the `nLockTime` for preventing fee sniping. Note: This will be ignored if you manually specify a
     * `nlocktime` using `TxBuilder::nlocktime`.
     *
     * 2. Decide whether coinbase outputs are mature or not. If the coinbase outputs are not mature at `current_height`,
     * we ignore them in the coin selection. If you want to create a transaction that spends immature coinbase inputs,
     * manually add them using `TxBuilder::add_utxos`.
     * In both cases, if you don’t provide a current height, we use the last sync height.
     */
open func currentHeight(height: UInt32) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_current_height(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(height),$0
    )
})
}
    
    /**
     * Do not spend change outputs.
     *
     * This effectively adds all the change outputs to the "unspendable" list. See `TxBuilder::unspendable`. This method
     * assumes the presence of an internal keychain, otherwise it has no effect.
     */
open func doNotSpendChange() -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_do_not_spend_change(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Sets the address to drain excess coins to.
     *
     * Usually, when there are excess coins they are sent to a change address generated by the wallet. This option
     * replaces the usual change address with an arbitrary script_pubkey of your choosing. Just as with a change output,
     * if the drain output is not needed (the excess coins are too small) it will not be included in the resulting
     * transaction. The only difference is that it is valid to use `drain_to` without setting any ordinary recipients
     * with `add_recipient` (but it is perfectly fine to add recipients as well).
     *
     * If you choose not to set any recipients, you should provide the utxos that the transaction should spend via
     * `add_utxos`. `drain_to` is very useful for draining all the coins in a wallet with `drain_wallet` to a single
     * address.
     */
open func drainTo(script: Script) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_drain_to(self.uniffiClonePointer(),
        FfiConverterTypeScript_lower(script),$0
    )
})
}
    
    /**
     * Spend all the available inputs. This respects filters like `TxBuilder::unspendable` and the change policy.
     */
open func drainWallet() -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_drain_wallet(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Set an absolute fee The `fee_absolute` method refers to the absolute transaction fee in `Amount`. If anyone sets
     * both the `fee_absolute` method and the `fee_rate` method, the `FeePolicy` enum will be set by whichever method was
     * called last, as the `FeeRate` and `FeeAmount` are mutually exclusive.
     *
     * Note that this is really a minimum absolute fee – it’s possible to overshoot it slightly since adding a change output to drain the remaining excess might not be viable.
     */
open func feeAbsolute(feeAmount: Amount) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_fee_absolute(self.uniffiClonePointer(),
        FfiConverterTypeAmount_lower(feeAmount),$0
    )
})
}
    
    /**
     * Set a custom fee rate.
     *
     * This method sets the mining fee paid by the transaction as a rate on its size. This means that the total fee paid
     * is equal to fee_rate times the size of the transaction. Default is 1 sat/vB in accordance with Bitcoin Core’s
     * default relay policy.
     *
     * Note that this is really a minimum feerate – it’s possible to overshoot it slightly since adding a change output
     * to drain the remaining excess might not be viable.
     */
open func feeRate(feeRate: FeeRate) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_fee_rate(self.uniffiClonePointer(),
        FfiConverterTypeFeeRate_lower(feeRate),$0
    )
})
}
    
    /**
     * Finish building the transaction.
     *
     * Uses the thread-local random number generator (rng).
     *
     * Returns a new `Psbt` per BIP174.
     *
     * WARNING: To avoid change address reuse you must persist the changes resulting from one or more calls to this
     * method before closing the wallet. See `Wallet::reveal_next_address`.
     */
open func finish(wallet: Wallet)throws  -> Psbt  {
    return try  FfiConverterTypePsbt_lift(try rustCallWithError(FfiConverterTypeCreateTxError_lift) {
    uniffi_bdkffi_fn_method_txbuilder_finish(self.uniffiClonePointer(),
        FfiConverterTypeWallet_lower(wallet),$0
    )
})
}
    
    /**
     * Only spend utxos added by `TxBuilder::add_utxo`.
     *
     * The wallet will not add additional utxos to the transaction even if they are needed to make the transaction valid.
     */
open func manuallySelectedOnly() -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_manually_selected_only(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Use a specific nLockTime while creating the transaction.
     *
     * This can cause conflicts if the wallet’s descriptors contain an "after" (`OP_CLTV`) operator.
     */
open func nlocktime(locktime: LockTime) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_nlocktime(self.uniffiClonePointer(),
        FfiConverterTypeLockTime_lower(locktime),$0
    )
})
}
    
    /**
     * Only spend change outputs.
     *
     * This effectively adds all the non-change outputs to the "unspendable" list. See `TxBuilder::unspendable`. This
     * method assumes the presence of an internal keychain, otherwise it has no effect.
     */
open func onlySpendChange() -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_only_spend_change(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The TxBuilder::policy_path is a complex API. See the Rust docs for complete       information: https://docs.rs/bdk_wallet/latest/bdk_wallet/struct.TxBuilder.html#method.policy_path
     */
open func policyPath(policyPath: [String: [UInt64]], keychain: KeychainKind) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_policy_path(self.uniffiClonePointer(),
        FfiConverterDictionaryStringSequenceUInt64.lower(policyPath),
        FfiConverterTypeKeychainKind_lower(keychain),$0
    )
})
}
    
    /**
     * Set an exact `nSequence` value.
     *
     * This can cause conflicts if the wallet’s descriptors contain an "older" (`OP_CSV`) operator and the given
     * `nsequence` is lower than the CSV value.
     */
open func setExactSequence(nsequence: UInt32) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_set_exact_sequence(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(nsequence),$0
    )
})
}
    
    /**
     * Replace the recipients already added with a new list of recipients.
     */
open func setRecipients(recipients: [ScriptAmount]) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_set_recipients(self.uniffiClonePointer(),
        FfiConverterSequenceTypeScriptAmount.lower(recipients),$0
    )
})
}
    
    /**
     * Replace the internal list of unspendable utxos with a new list.
     *
     * It’s important to note that the "must-be-spent" utxos added with `TxBuilder::add_utxo` have priority over these.
     */
open func unspendable(unspendable: [OutPoint]) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_unspendable(self.uniffiClonePointer(),
        FfiConverterSequenceTypeOutPoint.lower(unspendable),$0
    )
})
}
    
    /**
     * Build a transaction with a specific version.
     *
     * The version should always be greater than 0 and greater than 1 if the wallet’s descriptors contain an "older"
     * (`OP_CSV`) operator.
     */
open func version(version: Int32) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_version(self.uniffiClonePointer(),
        FfiConverterInt32.lower(version),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTxBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TxBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TxBuilder {
        return TxBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TxBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TxBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> TxBuilder {
    return try FfiConverterTypeTxBuilder.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxBuilder_lower(_ value: TxBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTxBuilder.lower(value)
}






public protocol UpdateProtocol: AnyObject, Sendable {
    
}
open class Update: UpdateProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_update(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_update(pointer, $0) }
    }

    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUpdate: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Update

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Update {
        return Update(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Update) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Update {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Update, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUpdate_lift(_ pointer: UnsafeMutableRawPointer) throws -> Update {
    return try FfiConverterTypeUpdate.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUpdate_lower(_ value: Update) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUpdate.lower(value)
}






public protocol WalletProtocol: AnyObject, Sendable {
    
    /**
     * Apply relevant unconfirmed transactions to the wallet.
     * Transactions that are not relevant are filtered out.
     */
    func applyUnconfirmedTxs(unconfirmedTxs: [UnconfirmedTx]) 
    
    /**
     * Applies an update to the wallet and stages the changes (but does not persist them).
     *
     * Usually you create an `update` by interacting with some blockchain data source and inserting
     * transactions related to your wallet into it.
     *
     * After applying updates you should persist the staged wallet changes. For an example of how
     * to persist staged wallet changes see [`Wallet::reveal_next_address`].
     */
    func applyUpdate(update: Update) throws 
    
    /**
     * Return the balance, separated into available, trusted-pending, untrusted-pending and immature
     * values.
     */
    func balance()  -> Balance
    
    /**
     * Calculates the fee of a given transaction. Returns [`Amount::ZERO`] if `tx` is a coinbase transaction.
     *
     * To calculate the fee for a [`Transaction`] with inputs not owned by this wallet you must
     * manually insert the TxOut(s) into the tx graph using the [`insert_txout`] function.
     *
     * Note `tx` does not have to be in the graph for this to work.
     */
    func calculateFee(tx: Transaction) throws  -> Amount
    
    /**
     * Calculate the [`FeeRate`] for a given transaction.
     *
     * To calculate the fee rate for a [`Transaction`] with inputs not owned by this wallet you must
     * manually insert the TxOut(s) into the tx graph using the [`insert_txout`] function.
     *
     * Note `tx` does not have to be in the graph for this to work.
     */
    func calculateFeeRate(tx: Transaction) throws  -> FeeRate
    
    /**
     * Informs the wallet that you no longer intend to broadcast a tx that was built from it.
     *
     * This frees up the change address used when creating the tx for use in future transactions.
     */
    func cancelTx(tx: Transaction) 
    
    /**
     * The derivation index of this wallet. It will return `None` if it has not derived any addresses.
     * Otherwise, it will return the index of the highest address it has derived.
     */
    func derivationIndex(keychain: KeychainKind)  -> UInt32?
    
    /**
     * Finds how the wallet derived the script pubkey `spk`.
     *
     * Will only return `Some(_)` if the wallet has given out the spk.
     */
    func derivationOfSpk(spk: Script)  -> KeychainAndIndex?
    
    /**
     * Return the checksum of the public descriptor associated to `keychain`
     *
     * Internally calls [`Self::public_descriptor`] to fetch the right descriptor
     */
    func descriptorChecksum(keychain: KeychainKind)  -> String
    
    /**
     * Finalize a PSBT, i.e., for each input determine if sufficient data is available to pass
     * validation and construct the respective `scriptSig` or `scriptWitness`. Please refer to
     * [BIP174](https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki#Input_Finalizer),
     * and [BIP371](https://github.com/bitcoin/bips/blob/master/bip-0371.mediawiki)
     * for further information.
     *
     * Returns `true` if the PSBT could be finalized, and `false` otherwise.
     *
     * The [`SignOptions`] can be used to tweak the behavior of the finalizer.
     */
    func finalizePsbt(psbt: Psbt, signOptions: SignOptions?) throws  -> Bool
    
    /**
     * Get a single transaction from the wallet as a [`WalletTx`] (if the transaction exists).
     *
     * `WalletTx` contains the full transaction alongside meta-data such as:
     * * Blocks that the transaction is [`Anchor`]ed in. These may or may not be blocks that exist
     *   in the best chain.
     * * The [`ChainPosition`] of the transaction in the best chain - whether the transaction is
     *   confirmed or unconfirmed. If the transaction is confirmed, the anchor which proves the
     *   confirmation is provided. If the transaction is unconfirmed, the unix timestamp of when
     *   the transaction was last seen in the mempool is provided.
     */
    func getTx(txid: String) throws  -> CanonicalTx?
    
    /**
     * Returns the utxo owned by this wallet corresponding to `outpoint` if it exists in the
     * wallet's database.
     */
    func getUtxo(op: OutPoint)  -> LocalOutput?
    
    /**
     * Return whether or not a `script` is part of this wallet (either internal or external)
     */
    func isMine(script: Script)  -> Bool
    
    /**
     * List all relevant outputs (includes both spent and unspent, confirmed and unconfirmed).
     *
     * To list only unspent outputs (UTXOs), use [`Wallet::list_unspent`] instead.
     */
    func listOutput()  -> [LocalOutput]
    
    /**
     * Return the list of unspent outputs of this wallet
     */
    func listUnspent()  -> [LocalOutput]
    
    /**
     * List addresses that are revealed but unused.
     *
     * Note if the returned iterator is empty you can reveal more addresses
     * by using [`reveal_next_address`](Self::reveal_next_address) or
     * [`reveal_addresses_to`](Self::reveal_addresses_to).
     */
    func listUnusedAddresses(keychain: KeychainKind)  -> [AddressInfo]
    
    /**
     * Marks an address used of the given `keychain` at `index`.
     *
     * Returns whether the given index was present and then removed from the unused set.
     */
    func markUsed(keychain: KeychainKind, index: UInt32)  -> Bool
    
    /**
     * Get the Bitcoin network the wallet is using.
     */
    func network()  -> Network
    
    /**
     * The index of the next address that you would get if you were to ask the wallet for a new address
     */
    func nextDerivationIndex(keychain: KeychainKind)  -> UInt32
    
    /**
     * Get the next unused address for the given `keychain`, i.e. the address with the lowest
     * derivation index that hasn't been used in a transaction.
     *
     * This will attempt to reveal a new address if all previously revealed addresses have
     * been used, in which case the returned address will be the same as calling [`Wallet::reveal_next_address`].
     *
     * **WARNING**: To avoid address reuse you must persist the changes resulting from one or more
     * calls to this method before closing the wallet. See [`Wallet::reveal_next_address`].
     */
    func nextUnusedAddress(keychain: KeychainKind)  -> AddressInfo
    
    /**
     * Peek an address of the given `keychain` at `index` without revealing it.
     *
     * For non-wildcard descriptors this returns the same address at every provided index.
     *
     * # Panics
     *
     * This panics when the caller requests for an address of derivation index greater than the
     * [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) max index.
     */
    func peekAddress(keychain: KeychainKind, index: UInt32)  -> AddressInfo
    
    func persist(connection: Connection) throws  -> Bool
    
    func policies(keychain: KeychainKind) throws  -> Policy?
    
    /**
     * Reveal addresses up to and including the target `index` and return an iterator
     * of newly revealed addresses.
     *
     * If the target `index` is unreachable, we make a best effort to reveal up to the last
     * possible index. If all addresses up to the given `index` are already revealed, then
     * no new addresses are returned.
     *
     * **WARNING**: To avoid address reuse you must persist the changes resulting from one or more
     * calls to this method before closing the wallet. See [`Wallet::reveal_next_address`].
     */
    func revealAddressesTo(keychain: KeychainKind, index: UInt32)  -> [AddressInfo]
    
    /**
     * Attempt to reveal the next address of the given `keychain`.
     *
     * This will increment the keychain's derivation index. If the keychain's descriptor doesn't
     * contain a wildcard or every address is already revealed up to the maximum derivation
     * index defined in [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki),
     * then the last revealed address will be returned.
     */
    func revealNextAddress(keychain: KeychainKind)  -> AddressInfo
    
    /**
     * Compute the `tx`'s sent and received [`Amount`]s.
     *
     * This method returns a tuple `(sent, received)`. Sent is the sum of the txin amounts
     * that spend from previous txouts tracked by this wallet. Received is the summation
     * of this tx's outputs that send to script pubkeys tracked by this wallet.
     */
    func sentAndReceived(tx: Transaction)  -> SentAndReceivedValues
    
    /**
     * Sign a transaction with all the wallet's signers, in the order specified by every signer's
     * [`SignerOrdering`]. This function returns the `Result` type with an encapsulated `bool` that has the value true if the PSBT was finalized, or false otherwise.
     *
     * The [`SignOptions`] can be used to tweak the behavior of the software signers, and the way
     * the transaction is finalized at the end. Note that it can't be guaranteed that *every*
     * signers will follow the options, but the "software signers" (WIF keys and `xprv`) defined
     * in this library will.
     */
    func sign(psbt: Psbt, signOptions: SignOptions?) throws  -> Bool
    
    /**
     * Create a [`FullScanRequest] for this wallet.
     *
     * This is the first step when performing a spk-based wallet full scan, the returned
     * [`FullScanRequest] collects iterators for the wallet's keychain script pub keys needed to
     * start a blockchain full scan with a spk based blockchain client.
     *
     * This operation is generally only used when importing or restoring a previously used wallet
     * in which the list of used scripts is not known.
     */
    func startFullScan()  -> FullScanRequestBuilder
    
    /**
     * Create a partial [`SyncRequest`] for this wallet for all revealed spks.
     *
     * This is the first step when performing a spk-based wallet partial sync, the returned
     * [`SyncRequest`] collects all revealed script pubkeys from the wallet keychain needed to
     * start a blockchain sync with a spk based blockchain client.
     */
    func startSyncWithRevealedSpks()  -> SyncRequestBuilder
    
    /**
     * Iterate over the transactions in the wallet.
     */
    func transactions()  -> [CanonicalTx]
    
}
open class Wallet: WalletProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_wallet(self.pointer, $0) }
    }
public convenience init(descriptor: Descriptor, changeDescriptor: Descriptor, network: Network, connection: Connection)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeCreateWithPersistError_lift) {
    uniffi_bdkffi_fn_constructor_wallet_new(
        FfiConverterTypeDescriptor_lower(descriptor),
        FfiConverterTypeDescriptor_lower(changeDescriptor),
        FfiConverterTypeNetwork_lower(network),
        FfiConverterTypeConnection_lower(connection),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_wallet(pointer, $0) }
    }

    
public static func load(descriptor: Descriptor, changeDescriptor: Descriptor, connection: Connection)throws  -> Wallet  {
    return try  FfiConverterTypeWallet_lift(try rustCallWithError(FfiConverterTypeLoadWithPersistError_lift) {
    uniffi_bdkffi_fn_constructor_wallet_load(
        FfiConverterTypeDescriptor_lower(descriptor),
        FfiConverterTypeDescriptor_lower(changeDescriptor),
        FfiConverterTypeConnection_lower(connection),$0
    )
})
}
    

    
    /**
     * Apply relevant unconfirmed transactions to the wallet.
     * Transactions that are not relevant are filtered out.
     */
open func applyUnconfirmedTxs(unconfirmedTxs: [UnconfirmedTx])  {try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_apply_unconfirmed_txs(self.uniffiClonePointer(),
        FfiConverterSequenceTypeUnconfirmedTx.lower(unconfirmedTxs),$0
    )
}
}
    
    /**
     * Applies an update to the wallet and stages the changes (but does not persist them).
     *
     * Usually you create an `update` by interacting with some blockchain data source and inserting
     * transactions related to your wallet into it.
     *
     * After applying updates you should persist the staged wallet changes. For an example of how
     * to persist staged wallet changes see [`Wallet::reveal_next_address`].
     */
open func applyUpdate(update: Update)throws   {try rustCallWithError(FfiConverterTypeCannotConnectError_lift) {
    uniffi_bdkffi_fn_method_wallet_apply_update(self.uniffiClonePointer(),
        FfiConverterTypeUpdate_lower(update),$0
    )
}
}
    
    /**
     * Return the balance, separated into available, trusted-pending, untrusted-pending and immature
     * values.
     */
open func balance() -> Balance  {
    return try!  FfiConverterTypeBalance_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_balance(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Calculates the fee of a given transaction. Returns [`Amount::ZERO`] if `tx` is a coinbase transaction.
     *
     * To calculate the fee for a [`Transaction`] with inputs not owned by this wallet you must
     * manually insert the TxOut(s) into the tx graph using the [`insert_txout`] function.
     *
     * Note `tx` does not have to be in the graph for this to work.
     */
open func calculateFee(tx: Transaction)throws  -> Amount  {
    return try  FfiConverterTypeAmount_lift(try rustCallWithError(FfiConverterTypeCalculateFeeError_lift) {
    uniffi_bdkffi_fn_method_wallet_calculate_fee(self.uniffiClonePointer(),
        FfiConverterTypeTransaction_lower(tx),$0
    )
})
}
    
    /**
     * Calculate the [`FeeRate`] for a given transaction.
     *
     * To calculate the fee rate for a [`Transaction`] with inputs not owned by this wallet you must
     * manually insert the TxOut(s) into the tx graph using the [`insert_txout`] function.
     *
     * Note `tx` does not have to be in the graph for this to work.
     */
open func calculateFeeRate(tx: Transaction)throws  -> FeeRate  {
    return try  FfiConverterTypeFeeRate_lift(try rustCallWithError(FfiConverterTypeCalculateFeeError_lift) {
    uniffi_bdkffi_fn_method_wallet_calculate_fee_rate(self.uniffiClonePointer(),
        FfiConverterTypeTransaction_lower(tx),$0
    )
})
}
    
    /**
     * Informs the wallet that you no longer intend to broadcast a tx that was built from it.
     *
     * This frees up the change address used when creating the tx for use in future transactions.
     */
open func cancelTx(tx: Transaction)  {try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_cancel_tx(self.uniffiClonePointer(),
        FfiConverterTypeTransaction_lower(tx),$0
    )
}
}
    
    /**
     * The derivation index of this wallet. It will return `None` if it has not derived any addresses.
     * Otherwise, it will return the index of the highest address it has derived.
     */
open func derivationIndex(keychain: KeychainKind) -> UInt32?  {
    return try!  FfiConverterOptionUInt32.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_derivation_index(self.uniffiClonePointer(),
        FfiConverterTypeKeychainKind_lower(keychain),$0
    )
})
}
    
    /**
     * Finds how the wallet derived the script pubkey `spk`.
     *
     * Will only return `Some(_)` if the wallet has given out the spk.
     */
open func derivationOfSpk(spk: Script) -> KeychainAndIndex?  {
    return try!  FfiConverterOptionTypeKeychainAndIndex.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_derivation_of_spk(self.uniffiClonePointer(),
        FfiConverterTypeScript_lower(spk),$0
    )
})
}
    
    /**
     * Return the checksum of the public descriptor associated to `keychain`
     *
     * Internally calls [`Self::public_descriptor`] to fetch the right descriptor
     */
open func descriptorChecksum(keychain: KeychainKind) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_descriptor_checksum(self.uniffiClonePointer(),
        FfiConverterTypeKeychainKind_lower(keychain),$0
    )
})
}
    
    /**
     * Finalize a PSBT, i.e., for each input determine if sufficient data is available to pass
     * validation and construct the respective `scriptSig` or `scriptWitness`. Please refer to
     * [BIP174](https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki#Input_Finalizer),
     * and [BIP371](https://github.com/bitcoin/bips/blob/master/bip-0371.mediawiki)
     * for further information.
     *
     * Returns `true` if the PSBT could be finalized, and `false` otherwise.
     *
     * The [`SignOptions`] can be used to tweak the behavior of the finalizer.
     */
open func finalizePsbt(psbt: Psbt, signOptions: SignOptions? = nil)throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeSignerError_lift) {
    uniffi_bdkffi_fn_method_wallet_finalize_psbt(self.uniffiClonePointer(),
        FfiConverterTypePsbt_lower(psbt),
        FfiConverterOptionTypeSignOptions.lower(signOptions),$0
    )
})
}
    
    /**
     * Get a single transaction from the wallet as a [`WalletTx`] (if the transaction exists).
     *
     * `WalletTx` contains the full transaction alongside meta-data such as:
     * * Blocks that the transaction is [`Anchor`]ed in. These may or may not be blocks that exist
     *   in the best chain.
     * * The [`ChainPosition`] of the transaction in the best chain - whether the transaction is
     *   confirmed or unconfirmed. If the transaction is confirmed, the anchor which proves the
     *   confirmation is provided. If the transaction is unconfirmed, the unix timestamp of when
     *   the transaction was last seen in the mempool is provided.
     */
open func getTx(txid: String)throws  -> CanonicalTx?  {
    return try  FfiConverterOptionTypeCanonicalTx.lift(try rustCallWithError(FfiConverterTypeTxidParseError_lift) {
    uniffi_bdkffi_fn_method_wallet_get_tx(self.uniffiClonePointer(),
        FfiConverterString.lower(txid),$0
    )
})
}
    
    /**
     * Returns the utxo owned by this wallet corresponding to `outpoint` if it exists in the
     * wallet's database.
     */
open func getUtxo(op: OutPoint) -> LocalOutput?  {
    return try!  FfiConverterOptionTypeLocalOutput.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_get_utxo(self.uniffiClonePointer(),
        FfiConverterTypeOutPoint_lower(op),$0
    )
})
}
    
    /**
     * Return whether or not a `script` is part of this wallet (either internal or external)
     */
open func isMine(script: Script) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_is_mine(self.uniffiClonePointer(),
        FfiConverterTypeScript_lower(script),$0
    )
})
}
    
    /**
     * List all relevant outputs (includes both spent and unspent, confirmed and unconfirmed).
     *
     * To list only unspent outputs (UTXOs), use [`Wallet::list_unspent`] instead.
     */
open func listOutput() -> [LocalOutput]  {
    return try!  FfiConverterSequenceTypeLocalOutput.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_list_output(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the list of unspent outputs of this wallet
     */
open func listUnspent() -> [LocalOutput]  {
    return try!  FfiConverterSequenceTypeLocalOutput.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_list_unspent(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * List addresses that are revealed but unused.
     *
     * Note if the returned iterator is empty you can reveal more addresses
     * by using [`reveal_next_address`](Self::reveal_next_address) or
     * [`reveal_addresses_to`](Self::reveal_addresses_to).
     */
open func listUnusedAddresses(keychain: KeychainKind) -> [AddressInfo]  {
    return try!  FfiConverterSequenceTypeAddressInfo.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_list_unused_addresses(self.uniffiClonePointer(),
        FfiConverterTypeKeychainKind_lower(keychain),$0
    )
})
}
    
    /**
     * Marks an address used of the given `keychain` at `index`.
     *
     * Returns whether the given index was present and then removed from the unused set.
     */
open func markUsed(keychain: KeychainKind, index: UInt32) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_mark_used(self.uniffiClonePointer(),
        FfiConverterTypeKeychainKind_lower(keychain),
        FfiConverterUInt32.lower(index),$0
    )
})
}
    
    /**
     * Get the Bitcoin network the wallet is using.
     */
open func network() -> Network  {
    return try!  FfiConverterTypeNetwork_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_network(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The index of the next address that you would get if you were to ask the wallet for a new address
     */
open func nextDerivationIndex(keychain: KeychainKind) -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_next_derivation_index(self.uniffiClonePointer(),
        FfiConverterTypeKeychainKind_lower(keychain),$0
    )
})
}
    
    /**
     * Get the next unused address for the given `keychain`, i.e. the address with the lowest
     * derivation index that hasn't been used in a transaction.
     *
     * This will attempt to reveal a new address if all previously revealed addresses have
     * been used, in which case the returned address will be the same as calling [`Wallet::reveal_next_address`].
     *
     * **WARNING**: To avoid address reuse you must persist the changes resulting from one or more
     * calls to this method before closing the wallet. See [`Wallet::reveal_next_address`].
     */
open func nextUnusedAddress(keychain: KeychainKind) -> AddressInfo  {
    return try!  FfiConverterTypeAddressInfo_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_next_unused_address(self.uniffiClonePointer(),
        FfiConverterTypeKeychainKind_lower(keychain),$0
    )
})
}
    
    /**
     * Peek an address of the given `keychain` at `index` without revealing it.
     *
     * For non-wildcard descriptors this returns the same address at every provided index.
     *
     * # Panics
     *
     * This panics when the caller requests for an address of derivation index greater than the
     * [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) max index.
     */
open func peekAddress(keychain: KeychainKind, index: UInt32) -> AddressInfo  {
    return try!  FfiConverterTypeAddressInfo_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_peek_address(self.uniffiClonePointer(),
        FfiConverterTypeKeychainKind_lower(keychain),
        FfiConverterUInt32.lower(index),$0
    )
})
}
    
open func persist(connection: Connection)throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeSqliteError_lift) {
    uniffi_bdkffi_fn_method_wallet_persist(self.uniffiClonePointer(),
        FfiConverterTypeConnection_lower(connection),$0
    )
})
}
    
open func policies(keychain: KeychainKind)throws  -> Policy?  {
    return try  FfiConverterOptionTypePolicy.lift(try rustCallWithError(FfiConverterTypeDescriptorError_lift) {
    uniffi_bdkffi_fn_method_wallet_policies(self.uniffiClonePointer(),
        FfiConverterTypeKeychainKind_lower(keychain),$0
    )
})
}
    
    /**
     * Reveal addresses up to and including the target `index` and return an iterator
     * of newly revealed addresses.
     *
     * If the target `index` is unreachable, we make a best effort to reveal up to the last
     * possible index. If all addresses up to the given `index` are already revealed, then
     * no new addresses are returned.
     *
     * **WARNING**: To avoid address reuse you must persist the changes resulting from one or more
     * calls to this method before closing the wallet. See [`Wallet::reveal_next_address`].
     */
open func revealAddressesTo(keychain: KeychainKind, index: UInt32) -> [AddressInfo]  {
    return try!  FfiConverterSequenceTypeAddressInfo.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_reveal_addresses_to(self.uniffiClonePointer(),
        FfiConverterTypeKeychainKind_lower(keychain),
        FfiConverterUInt32.lower(index),$0
    )
})
}
    
    /**
     * Attempt to reveal the next address of the given `keychain`.
     *
     * This will increment the keychain's derivation index. If the keychain's descriptor doesn't
     * contain a wildcard or every address is already revealed up to the maximum derivation
     * index defined in [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki),
     * then the last revealed address will be returned.
     */
open func revealNextAddress(keychain: KeychainKind) -> AddressInfo  {
    return try!  FfiConverterTypeAddressInfo_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_reveal_next_address(self.uniffiClonePointer(),
        FfiConverterTypeKeychainKind_lower(keychain),$0
    )
})
}
    
    /**
     * Compute the `tx`'s sent and received [`Amount`]s.
     *
     * This method returns a tuple `(sent, received)`. Sent is the sum of the txin amounts
     * that spend from previous txouts tracked by this wallet. Received is the summation
     * of this tx's outputs that send to script pubkeys tracked by this wallet.
     */
open func sentAndReceived(tx: Transaction) -> SentAndReceivedValues  {
    return try!  FfiConverterTypeSentAndReceivedValues_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_sent_and_received(self.uniffiClonePointer(),
        FfiConverterTypeTransaction_lower(tx),$0
    )
})
}
    
    /**
     * Sign a transaction with all the wallet's signers, in the order specified by every signer's
     * [`SignerOrdering`]. This function returns the `Result` type with an encapsulated `bool` that has the value true if the PSBT was finalized, or false otherwise.
     *
     * The [`SignOptions`] can be used to tweak the behavior of the software signers, and the way
     * the transaction is finalized at the end. Note that it can't be guaranteed that *every*
     * signers will follow the options, but the "software signers" (WIF keys and `xprv`) defined
     * in this library will.
     */
open func sign(psbt: Psbt, signOptions: SignOptions? = nil)throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeSignerError_lift) {
    uniffi_bdkffi_fn_method_wallet_sign(self.uniffiClonePointer(),
        FfiConverterTypePsbt_lower(psbt),
        FfiConverterOptionTypeSignOptions.lower(signOptions),$0
    )
})
}
    
    /**
     * Create a [`FullScanRequest] for this wallet.
     *
     * This is the first step when performing a spk-based wallet full scan, the returned
     * [`FullScanRequest] collects iterators for the wallet's keychain script pub keys needed to
     * start a blockchain full scan with a spk based blockchain client.
     *
     * This operation is generally only used when importing or restoring a previously used wallet
     * in which the list of used scripts is not known.
     */
open func startFullScan() -> FullScanRequestBuilder  {
    return try!  FfiConverterTypeFullScanRequestBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_start_full_scan(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Create a partial [`SyncRequest`] for this wallet for all revealed spks.
     *
     * This is the first step when performing a spk-based wallet partial sync, the returned
     * [`SyncRequest`] collects all revealed script pubkeys from the wallet keychain needed to
     * start a blockchain sync with a spk based blockchain client.
     */
open func startSyncWithRevealedSpks() -> SyncRequestBuilder  {
    return try!  FfiConverterTypeSyncRequestBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_start_sync_with_revealed_spks(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Iterate over the transactions in the wallet.
     */
open func transactions() -> [CanonicalTx]  {
    return try!  FfiConverterSequenceTypeCanonicalTx.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_transactions(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWallet: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Wallet

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Wallet {
        return Wallet(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Wallet) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Wallet {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Wallet, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWallet_lift(_ pointer: UnsafeMutableRawPointer) throws -> Wallet {
    return try FfiConverterTypeWallet.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWallet_lower(_ value: Wallet) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWallet.lower(value)
}




/**
 * A derived address and the index it was found at.
 */
public struct AddressInfo {
    /**
     * Child index of this address
     */
    public var index: UInt32
    /**
     * Address
     */
    public var address: Address
    /**
     * Type of keychain
     */
    public var keychain: KeychainKind

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Child index of this address
         */index: UInt32, 
        /**
         * Address
         */address: Address, 
        /**
         * Type of keychain
         */keychain: KeychainKind) {
        self.index = index
        self.address = address
        self.keychain = keychain
    }
}

#if compiler(>=6)
extension AddressInfo: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddressInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressInfo {
        return
            try AddressInfo(
                index: FfiConverterUInt32.read(from: &buf), 
                address: FfiConverterTypeAddress.read(from: &buf), 
                keychain: FfiConverterTypeKeychainKind.read(from: &buf)
        )
    }

    public static func write(_ value: AddressInfo, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.index, into: &buf)
        FfiConverterTypeAddress.write(value.address, into: &buf)
        FfiConverterTypeKeychainKind.write(value.keychain, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressInfo_lift(_ buf: RustBuffer) throws -> AddressInfo {
    return try FfiConverterTypeAddressInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressInfo_lower(_ value: AddressInfo) -> RustBuffer {
    return FfiConverterTypeAddressInfo.lower(value)
}


/**
 * Balance, differentiated into various categories.
 */
public struct Balance {
    /**
     * All coinbase outputs not yet matured
     */
    public var immature: Amount
    /**
     * Unconfirmed UTXOs generated by a wallet tx
     */
    public var trustedPending: Amount
    /**
     * Unconfirmed UTXOs received from an external wallet
     */
    public var untrustedPending: Amount
    /**
     * Confirmed and immediately spendable balance
     */
    public var confirmed: Amount
    /**
     * Get sum of trusted_pending and confirmed coins.
     *
     * This is the balance you can spend right now that shouldn't get cancelled via another party
     * double spending it.
     */
    public var trustedSpendable: Amount
    /**
     * Get the whole balance visible to the wallet.
     */
    public var total: Amount

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * All coinbase outputs not yet matured
         */immature: Amount, 
        /**
         * Unconfirmed UTXOs generated by a wallet tx
         */trustedPending: Amount, 
        /**
         * Unconfirmed UTXOs received from an external wallet
         */untrustedPending: Amount, 
        /**
         * Confirmed and immediately spendable balance
         */confirmed: Amount, 
        /**
         * Get sum of trusted_pending and confirmed coins.
         *
         * This is the balance you can spend right now that shouldn't get cancelled via another party
         * double spending it.
         */trustedSpendable: Amount, 
        /**
         * Get the whole balance visible to the wallet.
         */total: Amount) {
        self.immature = immature
        self.trustedPending = trustedPending
        self.untrustedPending = untrustedPending
        self.confirmed = confirmed
        self.trustedSpendable = trustedSpendable
        self.total = total
    }
}

#if compiler(>=6)
extension Balance: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBalance: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Balance {
        return
            try Balance(
                immature: FfiConverterTypeAmount.read(from: &buf), 
                trustedPending: FfiConverterTypeAmount.read(from: &buf), 
                untrustedPending: FfiConverterTypeAmount.read(from: &buf), 
                confirmed: FfiConverterTypeAmount.read(from: &buf), 
                trustedSpendable: FfiConverterTypeAmount.read(from: &buf), 
                total: FfiConverterTypeAmount.read(from: &buf)
        )
    }

    public static func write(_ value: Balance, into buf: inout [UInt8]) {
        FfiConverterTypeAmount.write(value.immature, into: &buf)
        FfiConverterTypeAmount.write(value.trustedPending, into: &buf)
        FfiConverterTypeAmount.write(value.untrustedPending, into: &buf)
        FfiConverterTypeAmount.write(value.confirmed, into: &buf)
        FfiConverterTypeAmount.write(value.trustedSpendable, into: &buf)
        FfiConverterTypeAmount.write(value.total, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBalance_lift(_ buf: RustBuffer) throws -> Balance {
    return try FfiConverterTypeBalance.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBalance_lower(_ value: Balance) -> RustBuffer {
    return FfiConverterTypeBalance.lower(value)
}


public struct BlockId {
    public var height: UInt32
    public var hash: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(height: UInt32, hash: String) {
        self.height = height
        self.hash = hash
    }
}

#if compiler(>=6)
extension BlockId: Sendable {}
#endif


extension BlockId: Equatable, Hashable {
    public static func ==(lhs: BlockId, rhs: BlockId) -> Bool {
        if lhs.height != rhs.height {
            return false
        }
        if lhs.hash != rhs.hash {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(height)
        hasher.combine(hash)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBlockId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlockId {
        return
            try BlockId(
                height: FfiConverterUInt32.read(from: &buf), 
                hash: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: BlockId, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.height, into: &buf)
        FfiConverterString.write(value.hash, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlockId_lift(_ buf: RustBuffer) throws -> BlockId {
    return try FfiConverterTypeBlockId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlockId_lower(_ value: BlockId) -> RustBuffer {
    return FfiConverterTypeBlockId.lower(value)
}


public struct CanonicalTx {
    public var transaction: Transaction
    public var chainPosition: ChainPosition

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(transaction: Transaction, chainPosition: ChainPosition) {
        self.transaction = transaction
        self.chainPosition = chainPosition
    }
}

#if compiler(>=6)
extension CanonicalTx: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCanonicalTx: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CanonicalTx {
        return
            try CanonicalTx(
                transaction: FfiConverterTypeTransaction.read(from: &buf), 
                chainPosition: FfiConverterTypeChainPosition.read(from: &buf)
        )
    }

    public static func write(_ value: CanonicalTx, into buf: inout [UInt8]) {
        FfiConverterTypeTransaction.write(value.transaction, into: &buf)
        FfiConverterTypeChainPosition.write(value.chainPosition, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCanonicalTx_lift(_ buf: RustBuffer) throws -> CanonicalTx {
    return try FfiConverterTypeCanonicalTx.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCanonicalTx_lower(_ value: CanonicalTx) -> RustBuffer {
    return FfiConverterTypeCanonicalTx.lower(value)
}


/**
 * Receive a [`CbfClient`] and [`CbfNode`].
 */
public struct CbfComponents {
    /**
     * Publish events to the node, like broadcasting transactions or adding scripts.
     */
    public var client: CbfClient
    /**
     * The node to run and fetch transactions for a [`Wallet`].
     */
    public var node: CbfNode

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Publish events to the node, like broadcasting transactions or adding scripts.
         */client: CbfClient, 
        /**
         * The node to run and fetch transactions for a [`Wallet`].
         */node: CbfNode) {
        self.client = client
        self.node = node
    }
}

#if compiler(>=6)
extension CbfComponents: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCbfComponents: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CbfComponents {
        return
            try CbfComponents(
                client: FfiConverterTypeCbfClient.read(from: &buf), 
                node: FfiConverterTypeCbfNode.read(from: &buf)
        )
    }

    public static func write(_ value: CbfComponents, into buf: inout [UInt8]) {
        FfiConverterTypeCbfClient.write(value.client, into: &buf)
        FfiConverterTypeCbfNode.write(value.node, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCbfComponents_lift(_ buf: RustBuffer) throws -> CbfComponents {
    return try FfiConverterTypeCbfComponents.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCbfComponents_lower(_ value: CbfComponents) -> RustBuffer {
    return FfiConverterTypeCbfComponents.lower(value)
}


public struct Condition {
    public var csv: UInt32?
    public var timelock: LockTime?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(csv: UInt32?, timelock: LockTime?) {
        self.csv = csv
        self.timelock = timelock
    }
}

#if compiler(>=6)
extension Condition: Sendable {}
#endif


extension Condition: Equatable, Hashable {
    public static func ==(lhs: Condition, rhs: Condition) -> Bool {
        if lhs.csv != rhs.csv {
            return false
        }
        if lhs.timelock != rhs.timelock {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(csv)
        hasher.combine(timelock)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCondition: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Condition {
        return
            try Condition(
                csv: FfiConverterOptionUInt32.read(from: &buf), 
                timelock: FfiConverterOptionTypeLockTime.read(from: &buf)
        )
    }

    public static func write(_ value: Condition, into buf: inout [UInt8]) {
        FfiConverterOptionUInt32.write(value.csv, into: &buf)
        FfiConverterOptionTypeLockTime.write(value.timelock, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCondition_lift(_ buf: RustBuffer) throws -> Condition {
    return try FfiConverterTypeCondition.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCondition_lower(_ value: Condition) -> RustBuffer {
    return FfiConverterTypeCondition.lower(value)
}


public struct ConfirmationBlockTime {
    public var blockId: BlockId
    public var confirmationTime: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(blockId: BlockId, confirmationTime: UInt64) {
        self.blockId = blockId
        self.confirmationTime = confirmationTime
    }
}

#if compiler(>=6)
extension ConfirmationBlockTime: Sendable {}
#endif


extension ConfirmationBlockTime: Equatable, Hashable {
    public static func ==(lhs: ConfirmationBlockTime, rhs: ConfirmationBlockTime) -> Bool {
        if lhs.blockId != rhs.blockId {
            return false
        }
        if lhs.confirmationTime != rhs.confirmationTime {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(blockId)
        hasher.combine(confirmationTime)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConfirmationBlockTime: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfirmationBlockTime {
        return
            try ConfirmationBlockTime(
                blockId: FfiConverterTypeBlockId.read(from: &buf), 
                confirmationTime: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ConfirmationBlockTime, into buf: inout [UInt8]) {
        FfiConverterTypeBlockId.write(value.blockId, into: &buf)
        FfiConverterUInt64.write(value.confirmationTime, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfirmationBlockTime_lift(_ buf: RustBuffer) throws -> ConfirmationBlockTime {
    return try FfiConverterTypeConfirmationBlockTime.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfirmationBlockTime_lower(_ value: ConfirmationBlockTime) -> RustBuffer {
    return FfiConverterTypeConfirmationBlockTime.lower(value)
}


public struct FinalizedPsbtResult {
    public var psbt: Psbt
    public var couldFinalize: Bool
    public var errors: [PsbtFinalizeError]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(psbt: Psbt, couldFinalize: Bool, errors: [PsbtFinalizeError]?) {
        self.psbt = psbt
        self.couldFinalize = couldFinalize
        self.errors = errors
    }
}

#if compiler(>=6)
extension FinalizedPsbtResult: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFinalizedPsbtResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FinalizedPsbtResult {
        return
            try FinalizedPsbtResult(
                psbt: FfiConverterTypePsbt.read(from: &buf), 
                couldFinalize: FfiConverterBool.read(from: &buf), 
                errors: FfiConverterOptionSequenceTypePsbtFinalizeError.read(from: &buf)
        )
    }

    public static func write(_ value: FinalizedPsbtResult, into buf: inout [UInt8]) {
        FfiConverterTypePsbt.write(value.psbt, into: &buf)
        FfiConverterBool.write(value.couldFinalize, into: &buf)
        FfiConverterOptionSequenceTypePsbtFinalizeError.write(value.errors, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFinalizedPsbtResult_lift(_ buf: RustBuffer) throws -> FinalizedPsbtResult {
    return try FfiConverterTypeFinalizedPsbtResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFinalizedPsbtResult_lower(_ value: FinalizedPsbtResult) -> RustBuffer {
    return FfiConverterTypeFinalizedPsbtResult.lower(value)
}


/**
 * Bitcoin block header.
 * Contains all the block’s information except the actual transactions, but including a root of a merkle tree
 * committing to all transactions in the block.
 */
public struct Header {
    /**
     * Block version, now repurposed for soft fork signalling.
     */
    public var version: Int32
    /**
     * Reference to the previous block in the chain.
     */
    public var prevBlockhash: String
    /**
     * The root hash of the merkle tree of transactions in the block.
     */
    public var merkleRoot: String
    /**
     * The timestamp of the block, as claimed by the miner.
     */
    public var time: UInt32
    /**
     * The target value below which the blockhash must lie.
     */
    public var bits: UInt32
    /**
     * The nonce, selected to obtain a low enough blockhash.
     */
    public var nonce: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Block version, now repurposed for soft fork signalling.
         */version: Int32, 
        /**
         * Reference to the previous block in the chain.
         */prevBlockhash: String, 
        /**
         * The root hash of the merkle tree of transactions in the block.
         */merkleRoot: String, 
        /**
         * The timestamp of the block, as claimed by the miner.
         */time: UInt32, 
        /**
         * The target value below which the blockhash must lie.
         */bits: UInt32, 
        /**
         * The nonce, selected to obtain a low enough blockhash.
         */nonce: UInt32) {
        self.version = version
        self.prevBlockhash = prevBlockhash
        self.merkleRoot = merkleRoot
        self.time = time
        self.bits = bits
        self.nonce = nonce
    }
}

#if compiler(>=6)
extension Header: Sendable {}
#endif


extension Header: Equatable, Hashable {
    public static func ==(lhs: Header, rhs: Header) -> Bool {
        if lhs.version != rhs.version {
            return false
        }
        if lhs.prevBlockhash != rhs.prevBlockhash {
            return false
        }
        if lhs.merkleRoot != rhs.merkleRoot {
            return false
        }
        if lhs.time != rhs.time {
            return false
        }
        if lhs.bits != rhs.bits {
            return false
        }
        if lhs.nonce != rhs.nonce {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(version)
        hasher.combine(prevBlockhash)
        hasher.combine(merkleRoot)
        hasher.combine(time)
        hasher.combine(bits)
        hasher.combine(nonce)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHeader: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Header {
        return
            try Header(
                version: FfiConverterInt32.read(from: &buf), 
                prevBlockhash: FfiConverterString.read(from: &buf), 
                merkleRoot: FfiConverterString.read(from: &buf), 
                time: FfiConverterUInt32.read(from: &buf), 
                bits: FfiConverterUInt32.read(from: &buf), 
                nonce: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: Header, into buf: inout [UInt8]) {
        FfiConverterInt32.write(value.version, into: &buf)
        FfiConverterString.write(value.prevBlockhash, into: &buf)
        FfiConverterString.write(value.merkleRoot, into: &buf)
        FfiConverterUInt32.write(value.time, into: &buf)
        FfiConverterUInt32.write(value.bits, into: &buf)
        FfiConverterUInt32.write(value.nonce, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHeader_lift(_ buf: RustBuffer) throws -> Header {
    return try FfiConverterTypeHeader.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHeader_lower(_ value: Header) -> RustBuffer {
    return FfiConverterTypeHeader.lower(value)
}


/**
 * Notification of a new block header.
 */
public struct HeaderNotification {
    /**
     * New block height.
     */
    public var height: UInt64
    /**
     * Newly added header.
     */
    public var header: Header

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * New block height.
         */height: UInt64, 
        /**
         * Newly added header.
         */header: Header) {
        self.height = height
        self.header = header
    }
}

#if compiler(>=6)
extension HeaderNotification: Sendable {}
#endif


extension HeaderNotification: Equatable, Hashable {
    public static func ==(lhs: HeaderNotification, rhs: HeaderNotification) -> Bool {
        if lhs.height != rhs.height {
            return false
        }
        if lhs.header != rhs.header {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(height)
        hasher.combine(header)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHeaderNotification: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HeaderNotification {
        return
            try HeaderNotification(
                height: FfiConverterUInt64.read(from: &buf), 
                header: FfiConverterTypeHeader.read(from: &buf)
        )
    }

    public static func write(_ value: HeaderNotification, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.height, into: &buf)
        FfiConverterTypeHeader.write(value.header, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHeaderNotification_lift(_ buf: RustBuffer) throws -> HeaderNotification {
    return try FfiConverterTypeHeaderNotification.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHeaderNotification_lower(_ value: HeaderNotification) -> RustBuffer {
    return FfiConverterTypeHeaderNotification.lower(value)
}


public struct KeychainAndIndex {
    public var keychain: KeychainKind
    public var index: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(keychain: KeychainKind, index: UInt32) {
        self.keychain = keychain
        self.index = index
    }
}

#if compiler(>=6)
extension KeychainAndIndex: Sendable {}
#endif


extension KeychainAndIndex: Equatable, Hashable {
    public static func ==(lhs: KeychainAndIndex, rhs: KeychainAndIndex) -> Bool {
        if lhs.keychain != rhs.keychain {
            return false
        }
        if lhs.index != rhs.index {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(keychain)
        hasher.combine(index)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKeychainAndIndex: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeychainAndIndex {
        return
            try KeychainAndIndex(
                keychain: FfiConverterTypeKeychainKind.read(from: &buf), 
                index: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: KeychainAndIndex, into buf: inout [UInt8]) {
        FfiConverterTypeKeychainKind.write(value.keychain, into: &buf)
        FfiConverterUInt32.write(value.index, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeychainAndIndex_lift(_ buf: RustBuffer) throws -> KeychainAndIndex {
    return try FfiConverterTypeKeychainAndIndex.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeychainAndIndex_lower(_ value: KeychainAndIndex) -> RustBuffer {
    return FfiConverterTypeKeychainAndIndex.lower(value)
}


/**
 * An unspent output owned by a [`Wallet`].
 */
public struct LocalOutput {
    /**
     * Reference to a transaction output
     */
    public var outpoint: OutPoint
    /**
     * Transaction output
     */
    public var txout: TxOut
    /**
     * Type of keychain
     */
    public var keychain: KeychainKind
    /**
     * Whether this UTXO is spent or not
     */
    public var isSpent: Bool
    /**
     * The derivation index for the script pubkey in the wallet
     */
    public var derivationIndex: UInt32
    /**
     * The position of the output in the blockchain.
     */
    public var chainPosition: ChainPosition

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Reference to a transaction output
         */outpoint: OutPoint, 
        /**
         * Transaction output
         */txout: TxOut, 
        /**
         * Type of keychain
         */keychain: KeychainKind, 
        /**
         * Whether this UTXO is spent or not
         */isSpent: Bool, 
        /**
         * The derivation index for the script pubkey in the wallet
         */derivationIndex: UInt32, 
        /**
         * The position of the output in the blockchain.
         */chainPosition: ChainPosition) {
        self.outpoint = outpoint
        self.txout = txout
        self.keychain = keychain
        self.isSpent = isSpent
        self.derivationIndex = derivationIndex
        self.chainPosition = chainPosition
    }
}

#if compiler(>=6)
extension LocalOutput: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLocalOutput: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocalOutput {
        return
            try LocalOutput(
                outpoint: FfiConverterTypeOutPoint.read(from: &buf), 
                txout: FfiConverterTypeTxOut.read(from: &buf), 
                keychain: FfiConverterTypeKeychainKind.read(from: &buf), 
                isSpent: FfiConverterBool.read(from: &buf), 
                derivationIndex: FfiConverterUInt32.read(from: &buf), 
                chainPosition: FfiConverterTypeChainPosition.read(from: &buf)
        )
    }

    public static func write(_ value: LocalOutput, into buf: inout [UInt8]) {
        FfiConverterTypeOutPoint.write(value.outpoint, into: &buf)
        FfiConverterTypeTxOut.write(value.txout, into: &buf)
        FfiConverterTypeKeychainKind.write(value.keychain, into: &buf)
        FfiConverterBool.write(value.isSpent, into: &buf)
        FfiConverterUInt32.write(value.derivationIndex, into: &buf)
        FfiConverterTypeChainPosition.write(value.chainPosition, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLocalOutput_lift(_ buf: RustBuffer) throws -> LocalOutput {
    return try FfiConverterTypeLocalOutput.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLocalOutput_lower(_ value: LocalOutput) -> RustBuffer {
    return FfiConverterTypeLocalOutput.lower(value)
}


public struct OutPoint {
    public var txid: String
    public var vout: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txid: String, vout: UInt32) {
        self.txid = txid
        self.vout = vout
    }
}

#if compiler(>=6)
extension OutPoint: Sendable {}
#endif


extension OutPoint: Equatable, Hashable {
    public static func ==(lhs: OutPoint, rhs: OutPoint) -> Bool {
        if lhs.txid != rhs.txid {
            return false
        }
        if lhs.vout != rhs.vout {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txid)
        hasher.combine(vout)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOutPoint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OutPoint {
        return
            try OutPoint(
                txid: FfiConverterString.read(from: &buf), 
                vout: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: OutPoint, into buf: inout [UInt8]) {
        FfiConverterString.write(value.txid, into: &buf)
        FfiConverterUInt32.write(value.vout, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOutPoint_lift(_ buf: RustBuffer) throws -> OutPoint {
    return try FfiConverterTypeOutPoint.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOutPoint_lower(_ value: OutPoint) -> RustBuffer {
    return FfiConverterTypeOutPoint.lower(value)
}


/**
 * A peer to connect to over the Bitcoin peer-to-peer network.
 */
public struct Peer {
    /**
     * The IP address to reach the node.
     */
    public var address: IpAddress
    /**
     * The port to reach the node. If none is provided, the default
     * port for the selected network will be used.
     */
    public var port: UInt16?
    /**
     * Does the remote node offer encrypted peer-to-peer connection.
     */
    public var v2Transport: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The IP address to reach the node.
         */address: IpAddress, 
        /**
         * The port to reach the node. If none is provided, the default
         * port for the selected network will be used.
         */port: UInt16?, 
        /**
         * Does the remote node offer encrypted peer-to-peer connection.
         */v2Transport: Bool) {
        self.address = address
        self.port = port
        self.v2Transport = v2Transport
    }
}

#if compiler(>=6)
extension Peer: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePeer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Peer {
        return
            try Peer(
                address: FfiConverterTypeIpAddress.read(from: &buf), 
                port: FfiConverterOptionUInt16.read(from: &buf), 
                v2Transport: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: Peer, into buf: inout [UInt8]) {
        FfiConverterTypeIpAddress.write(value.address, into: &buf)
        FfiConverterOptionUInt16.write(value.port, into: &buf)
        FfiConverterBool.write(value.v2Transport, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePeer_lift(_ buf: RustBuffer) throws -> Peer {
    return try FfiConverterTypePeer.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePeer_lower(_ value: Peer) -> RustBuffer {
    return FfiConverterTypePeer.lower(value)
}


public struct ScriptAmount {
    public var script: Script
    public var amount: Amount

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(script: Script, amount: Amount) {
        self.script = script
        self.amount = amount
    }
}

#if compiler(>=6)
extension ScriptAmount: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeScriptAmount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScriptAmount {
        return
            try ScriptAmount(
                script: FfiConverterTypeScript.read(from: &buf), 
                amount: FfiConverterTypeAmount.read(from: &buf)
        )
    }

    public static func write(_ value: ScriptAmount, into buf: inout [UInt8]) {
        FfiConverterTypeScript.write(value.script, into: &buf)
        FfiConverterTypeAmount.write(value.amount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeScriptAmount_lift(_ buf: RustBuffer) throws -> ScriptAmount {
    return try FfiConverterTypeScriptAmount.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeScriptAmount_lower(_ value: ScriptAmount) -> RustBuffer {
    return FfiConverterTypeScriptAmount.lower(value)
}


public struct SentAndReceivedValues {
    public var sent: Amount
    public var received: Amount

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(sent: Amount, received: Amount) {
        self.sent = sent
        self.received = received
    }
}

#if compiler(>=6)
extension SentAndReceivedValues: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSentAndReceivedValues: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SentAndReceivedValues {
        return
            try SentAndReceivedValues(
                sent: FfiConverterTypeAmount.read(from: &buf), 
                received: FfiConverterTypeAmount.read(from: &buf)
        )
    }

    public static func write(_ value: SentAndReceivedValues, into buf: inout [UInt8]) {
        FfiConverterTypeAmount.write(value.sent, into: &buf)
        FfiConverterTypeAmount.write(value.received, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSentAndReceivedValues_lift(_ buf: RustBuffer) throws -> SentAndReceivedValues {
    return try FfiConverterTypeSentAndReceivedValues.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSentAndReceivedValues_lower(_ value: SentAndReceivedValues) -> RustBuffer {
    return FfiConverterTypeSentAndReceivedValues.lower(value)
}


/**
 * Response to an ElectrumClient.server_features request.
 */
public struct ServerFeaturesRes {
    /**
     * Server version reported.
     */
    public var serverVersion: String
    /**
     * Hash of the genesis block.
     */
    public var genesisHash: String
    /**
     * Minimum supported version of the protocol.
     */
    public var protocolMin: String
    /**
     * Maximum supported version of the protocol.
     */
    public var protocolMax: String
    /**
     * Hash function used to create the `ScriptHash`.
     */
    public var hashFunction: String?
    /**
     * Pruned height of the server.
     */
    public var pruning: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Server version reported.
         */serverVersion: String, 
        /**
         * Hash of the genesis block.
         */genesisHash: String, 
        /**
         * Minimum supported version of the protocol.
         */protocolMin: String, 
        /**
         * Maximum supported version of the protocol.
         */protocolMax: String, 
        /**
         * Hash function used to create the `ScriptHash`.
         */hashFunction: String?, 
        /**
         * Pruned height of the server.
         */pruning: Int64?) {
        self.serverVersion = serverVersion
        self.genesisHash = genesisHash
        self.protocolMin = protocolMin
        self.protocolMax = protocolMax
        self.hashFunction = hashFunction
        self.pruning = pruning
    }
}

#if compiler(>=6)
extension ServerFeaturesRes: Sendable {}
#endif


extension ServerFeaturesRes: Equatable, Hashable {
    public static func ==(lhs: ServerFeaturesRes, rhs: ServerFeaturesRes) -> Bool {
        if lhs.serverVersion != rhs.serverVersion {
            return false
        }
        if lhs.genesisHash != rhs.genesisHash {
            return false
        }
        if lhs.protocolMin != rhs.protocolMin {
            return false
        }
        if lhs.protocolMax != rhs.protocolMax {
            return false
        }
        if lhs.hashFunction != rhs.hashFunction {
            return false
        }
        if lhs.pruning != rhs.pruning {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(serverVersion)
        hasher.combine(genesisHash)
        hasher.combine(protocolMin)
        hasher.combine(protocolMax)
        hasher.combine(hashFunction)
        hasher.combine(pruning)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeServerFeaturesRes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ServerFeaturesRes {
        return
            try ServerFeaturesRes(
                serverVersion: FfiConverterString.read(from: &buf), 
                genesisHash: FfiConverterString.read(from: &buf), 
                protocolMin: FfiConverterString.read(from: &buf), 
                protocolMax: FfiConverterString.read(from: &buf), 
                hashFunction: FfiConverterOptionString.read(from: &buf), 
                pruning: FfiConverterOptionInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ServerFeaturesRes, into buf: inout [UInt8]) {
        FfiConverterString.write(value.serverVersion, into: &buf)
        FfiConverterString.write(value.genesisHash, into: &buf)
        FfiConverterString.write(value.protocolMin, into: &buf)
        FfiConverterString.write(value.protocolMax, into: &buf)
        FfiConverterOptionString.write(value.hashFunction, into: &buf)
        FfiConverterOptionInt64.write(value.pruning, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeServerFeaturesRes_lift(_ buf: RustBuffer) throws -> ServerFeaturesRes {
    return try FfiConverterTypeServerFeaturesRes.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeServerFeaturesRes_lower(_ value: ServerFeaturesRes) -> RustBuffer {
    return FfiConverterTypeServerFeaturesRes.lower(value)
}


/**
 * Options for a software signer.
 *
 * Adjust the behavior of our software signers and the way a transaction is finalized.
 */
public struct SignOptions {
    /**
     * Whether the signer should trust the `witness_utxo`, if the `non_witness_utxo` hasn't been
     * provided
     *
     * Defaults to `false` to mitigate the "SegWit bug" which could trick the wallet into
     * paying a fee larger than expected.
     *
     * Some wallets, especially if relatively old, might not provide the `non_witness_utxo` for
     * SegWit transactions in the PSBT they generate: in those cases setting this to `true`
     * should correctly produce a signature, at the expense of an increased trust in the creator
     * of the PSBT.
     *
     * For more details see: <https://blog.trezor.io/details-of-firmware-updates-for-trezor-one-version-1-9-1-and-trezor-model-t-version-2-3-1-1eba8f60f2dd>
     */
    public var trustWitnessUtxo: Bool
    /**
     * Whether the wallet should assume a specific height has been reached when trying to finalize
     * a transaction
     *
     * The wallet will only "use" a timelock to satisfy the spending policy of an input if the
     * timelock height has already been reached. This option allows overriding the "current height" to let the
     * wallet use timelocks in the future to spend a coin.
     */
    public var assumeHeight: UInt32?
    /**
     * Whether the signer should use the `sighash_type` set in the PSBT when signing, no matter
     * what its value is
     *
     * Defaults to `false` which will only allow signing using `SIGHASH_ALL`.
     */
    public var allowAllSighashes: Bool
    /**
     * Whether to try finalizing the PSBT after the inputs are signed.
     *
     * Defaults to `true` which will try finalizing PSBT after inputs are signed.
     */
    public var tryFinalize: Bool
    /**
     * Whether we should try to sign a taproot transaction with the taproot internal key
     * or not. This option is ignored if we're signing a non-taproot PSBT.
     *
     * Defaults to `true`, i.e., we always try to sign with the taproot internal key.
     */
    public var signWithTapInternalKey: Bool
    /**
     * Whether we should grind ECDSA signature to ensure signing with low r
     * or not.
     * Defaults to `true`, i.e., we always grind ECDSA signature to sign with low r.
     */
    public var allowGrinding: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Whether the signer should trust the `witness_utxo`, if the `non_witness_utxo` hasn't been
         * provided
         *
         * Defaults to `false` to mitigate the "SegWit bug" which could trick the wallet into
         * paying a fee larger than expected.
         *
         * Some wallets, especially if relatively old, might not provide the `non_witness_utxo` for
         * SegWit transactions in the PSBT they generate: in those cases setting this to `true`
         * should correctly produce a signature, at the expense of an increased trust in the creator
         * of the PSBT.
         *
         * For more details see: <https://blog.trezor.io/details-of-firmware-updates-for-trezor-one-version-1-9-1-and-trezor-model-t-version-2-3-1-1eba8f60f2dd>
         */trustWitnessUtxo: Bool, 
        /**
         * Whether the wallet should assume a specific height has been reached when trying to finalize
         * a transaction
         *
         * The wallet will only "use" a timelock to satisfy the spending policy of an input if the
         * timelock height has already been reached. This option allows overriding the "current height" to let the
         * wallet use timelocks in the future to spend a coin.
         */assumeHeight: UInt32?, 
        /**
         * Whether the signer should use the `sighash_type` set in the PSBT when signing, no matter
         * what its value is
         *
         * Defaults to `false` which will only allow signing using `SIGHASH_ALL`.
         */allowAllSighashes: Bool, 
        /**
         * Whether to try finalizing the PSBT after the inputs are signed.
         *
         * Defaults to `true` which will try finalizing PSBT after inputs are signed.
         */tryFinalize: Bool, 
        /**
         * Whether we should try to sign a taproot transaction with the taproot internal key
         * or not. This option is ignored if we're signing a non-taproot PSBT.
         *
         * Defaults to `true`, i.e., we always try to sign with the taproot internal key.
         */signWithTapInternalKey: Bool, 
        /**
         * Whether we should grind ECDSA signature to ensure signing with low r
         * or not.
         * Defaults to `true`, i.e., we always grind ECDSA signature to sign with low r.
         */allowGrinding: Bool) {
        self.trustWitnessUtxo = trustWitnessUtxo
        self.assumeHeight = assumeHeight
        self.allowAllSighashes = allowAllSighashes
        self.tryFinalize = tryFinalize
        self.signWithTapInternalKey = signWithTapInternalKey
        self.allowGrinding = allowGrinding
    }
}

#if compiler(>=6)
extension SignOptions: Sendable {}
#endif


extension SignOptions: Equatable, Hashable {
    public static func ==(lhs: SignOptions, rhs: SignOptions) -> Bool {
        if lhs.trustWitnessUtxo != rhs.trustWitnessUtxo {
            return false
        }
        if lhs.assumeHeight != rhs.assumeHeight {
            return false
        }
        if lhs.allowAllSighashes != rhs.allowAllSighashes {
            return false
        }
        if lhs.tryFinalize != rhs.tryFinalize {
            return false
        }
        if lhs.signWithTapInternalKey != rhs.signWithTapInternalKey {
            return false
        }
        if lhs.allowGrinding != rhs.allowGrinding {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(trustWitnessUtxo)
        hasher.combine(assumeHeight)
        hasher.combine(allowAllSighashes)
        hasher.combine(tryFinalize)
        hasher.combine(signWithTapInternalKey)
        hasher.combine(allowGrinding)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignOptions {
        return
            try SignOptions(
                trustWitnessUtxo: FfiConverterBool.read(from: &buf), 
                assumeHeight: FfiConverterOptionUInt32.read(from: &buf), 
                allowAllSighashes: FfiConverterBool.read(from: &buf), 
                tryFinalize: FfiConverterBool.read(from: &buf), 
                signWithTapInternalKey: FfiConverterBool.read(from: &buf), 
                allowGrinding: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: SignOptions, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.trustWitnessUtxo, into: &buf)
        FfiConverterOptionUInt32.write(value.assumeHeight, into: &buf)
        FfiConverterBool.write(value.allowAllSighashes, into: &buf)
        FfiConverterBool.write(value.tryFinalize, into: &buf)
        FfiConverterBool.write(value.signWithTapInternalKey, into: &buf)
        FfiConverterBool.write(value.allowGrinding, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignOptions_lift(_ buf: RustBuffer) throws -> SignOptions {
    return try FfiConverterTypeSignOptions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignOptions_lower(_ value: SignOptions) -> RustBuffer {
    return FfiConverterTypeSignOptions.lower(value)
}


public struct Tx {
    public var txid: String
    public var version: Int32
    public var locktime: UInt32
    public var size: UInt64
    public var weight: UInt64
    public var fee: UInt64
    public var status: TxStatus

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txid: String, version: Int32, locktime: UInt32, size: UInt64, weight: UInt64, fee: UInt64, status: TxStatus) {
        self.txid = txid
        self.version = version
        self.locktime = locktime
        self.size = size
        self.weight = weight
        self.fee = fee
        self.status = status
    }
}

#if compiler(>=6)
extension Tx: Sendable {}
#endif


extension Tx: Equatable, Hashable {
    public static func ==(lhs: Tx, rhs: Tx) -> Bool {
        if lhs.txid != rhs.txid {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        if lhs.locktime != rhs.locktime {
            return false
        }
        if lhs.size != rhs.size {
            return false
        }
        if lhs.weight != rhs.weight {
            return false
        }
        if lhs.fee != rhs.fee {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txid)
        hasher.combine(version)
        hasher.combine(locktime)
        hasher.combine(size)
        hasher.combine(weight)
        hasher.combine(fee)
        hasher.combine(status)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTx: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Tx {
        return
            try Tx(
                txid: FfiConverterString.read(from: &buf), 
                version: FfiConverterInt32.read(from: &buf), 
                locktime: FfiConverterUInt32.read(from: &buf), 
                size: FfiConverterUInt64.read(from: &buf), 
                weight: FfiConverterUInt64.read(from: &buf), 
                fee: FfiConverterUInt64.read(from: &buf), 
                status: FfiConverterTypeTxStatus.read(from: &buf)
        )
    }

    public static func write(_ value: Tx, into buf: inout [UInt8]) {
        FfiConverterString.write(value.txid, into: &buf)
        FfiConverterInt32.write(value.version, into: &buf)
        FfiConverterUInt32.write(value.locktime, into: &buf)
        FfiConverterUInt64.write(value.size, into: &buf)
        FfiConverterUInt64.write(value.weight, into: &buf)
        FfiConverterUInt64.write(value.fee, into: &buf)
        FfiConverterTypeTxStatus.write(value.status, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTx_lift(_ buf: RustBuffer) throws -> Tx {
    return try FfiConverterTypeTx.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTx_lower(_ value: Tx) -> RustBuffer {
    return FfiConverterTypeTx.lower(value)
}


public struct TxIn {
    public var previousOutput: OutPoint
    public var scriptSig: Script
    public var sequence: UInt32
    public var witness: [[UInt8]]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(previousOutput: OutPoint, scriptSig: Script, sequence: UInt32, witness: [[UInt8]]) {
        self.previousOutput = previousOutput
        self.scriptSig = scriptSig
        self.sequence = sequence
        self.witness = witness
    }
}

#if compiler(>=6)
extension TxIn: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTxIn: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxIn {
        return
            try TxIn(
                previousOutput: FfiConverterTypeOutPoint.read(from: &buf), 
                scriptSig: FfiConverterTypeScript.read(from: &buf), 
                sequence: FfiConverterUInt32.read(from: &buf), 
                witness: FfiConverterSequenceSequenceUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: TxIn, into buf: inout [UInt8]) {
        FfiConverterTypeOutPoint.write(value.previousOutput, into: &buf)
        FfiConverterTypeScript.write(value.scriptSig, into: &buf)
        FfiConverterUInt32.write(value.sequence, into: &buf)
        FfiConverterSequenceSequenceUInt8.write(value.witness, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxIn_lift(_ buf: RustBuffer) throws -> TxIn {
    return try FfiConverterTypeTxIn.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxIn_lower(_ value: TxIn) -> RustBuffer {
    return FfiConverterTypeTxIn.lower(value)
}


/**
 * Bitcoin transaction output.
 *
 * Defines new coins to be created as a result of the transaction,
 * along with spending conditions ("script", aka "output script"),
 * which an input spending it must satisfy.
 *
 * An output that is not yet spent by an input is called Unspent Transaction Output ("UTXO").
 */
public struct TxOut {
    /**
     * The value of the output, in satoshis.
     */
    public var value: UInt64
    /**
     * The script which must be satisfied for the output to be spent.
     */
    public var scriptPubkey: Script

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The value of the output, in satoshis.
         */value: UInt64, 
        /**
         * The script which must be satisfied for the output to be spent.
         */scriptPubkey: Script) {
        self.value = value
        self.scriptPubkey = scriptPubkey
    }
}

#if compiler(>=6)
extension TxOut: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTxOut: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxOut {
        return
            try TxOut(
                value: FfiConverterUInt64.read(from: &buf), 
                scriptPubkey: FfiConverterTypeScript.read(from: &buf)
        )
    }

    public static func write(_ value: TxOut, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.value, into: &buf)
        FfiConverterTypeScript.write(value.scriptPubkey, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxOut_lift(_ buf: RustBuffer) throws -> TxOut {
    return try FfiConverterTypeTxOut.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxOut_lower(_ value: TxOut) -> RustBuffer {
    return FfiConverterTypeTxOut.lower(value)
}


public struct TxStatus {
    public var confirmed: Bool
    public var blockHeight: UInt32?
    public var blockHash: String?
    public var blockTime: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(confirmed: Bool, blockHeight: UInt32?, blockHash: String?, blockTime: UInt64?) {
        self.confirmed = confirmed
        self.blockHeight = blockHeight
        self.blockHash = blockHash
        self.blockTime = blockTime
    }
}

#if compiler(>=6)
extension TxStatus: Sendable {}
#endif


extension TxStatus: Equatable, Hashable {
    public static func ==(lhs: TxStatus, rhs: TxStatus) -> Bool {
        if lhs.confirmed != rhs.confirmed {
            return false
        }
        if lhs.blockHeight != rhs.blockHeight {
            return false
        }
        if lhs.blockHash != rhs.blockHash {
            return false
        }
        if lhs.blockTime != rhs.blockTime {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(confirmed)
        hasher.combine(blockHeight)
        hasher.combine(blockHash)
        hasher.combine(blockTime)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTxStatus: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxStatus {
        return
            try TxStatus(
                confirmed: FfiConverterBool.read(from: &buf), 
                blockHeight: FfiConverterOptionUInt32.read(from: &buf), 
                blockHash: FfiConverterOptionString.read(from: &buf), 
                blockTime: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: TxStatus, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.confirmed, into: &buf)
        FfiConverterOptionUInt32.write(value.blockHeight, into: &buf)
        FfiConverterOptionString.write(value.blockHash, into: &buf)
        FfiConverterOptionUInt64.write(value.blockTime, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxStatus_lift(_ buf: RustBuffer) throws -> TxStatus {
    return try FfiConverterTypeTxStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxStatus_lower(_ value: TxStatus) -> RustBuffer {
    return FfiConverterTypeTxStatus.lower(value)
}


/**
 * This type replaces the Rust tuple `(tx, last_seen)` used in the Wallet::apply_unconfirmed_txs` method,
 * where `last_seen` is the timestamp of when the transaction `tx` was last seen in the mempool.
 */
public struct UnconfirmedTx {
    public var tx: Transaction
    public var lastSeen: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(tx: Transaction, lastSeen: UInt64) {
        self.tx = tx
        self.lastSeen = lastSeen
    }
}

#if compiler(>=6)
extension UnconfirmedTx: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnconfirmedTx: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnconfirmedTx {
        return
            try UnconfirmedTx(
                tx: FfiConverterTypeTransaction.read(from: &buf), 
                lastSeen: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: UnconfirmedTx, into buf: inout [UInt8]) {
        FfiConverterTypeTransaction.write(value.tx, into: &buf)
        FfiConverterUInt64.write(value.lastSeen, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnconfirmedTx_lift(_ buf: RustBuffer) throws -> UnconfirmedTx {
    return try FfiConverterTypeUnconfirmedTx.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnconfirmedTx_lower(_ value: UnconfirmedTx) -> RustBuffer {
    return FfiConverterTypeUnconfirmedTx.lower(value)
}


public struct WitnessProgram {
    public var version: UInt8
    public var program: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(version: UInt8, program: [UInt8]) {
        self.version = version
        self.program = program
    }
}

#if compiler(>=6)
extension WitnessProgram: Sendable {}
#endif


extension WitnessProgram: Equatable, Hashable {
    public static func ==(lhs: WitnessProgram, rhs: WitnessProgram) -> Bool {
        if lhs.version != rhs.version {
            return false
        }
        if lhs.program != rhs.program {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(version)
        hasher.combine(program)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWitnessProgram: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WitnessProgram {
        return
            try WitnessProgram(
                version: FfiConverterUInt8.read(from: &buf), 
                program: FfiConverterSequenceUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: WitnessProgram, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.version, into: &buf)
        FfiConverterSequenceUInt8.write(value.program, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWitnessProgram_lift(_ buf: RustBuffer) throws -> WitnessProgram {
    return try FfiConverterTypeWitnessProgram.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWitnessProgram_lower(_ value: WitnessProgram) -> RustBuffer {
    return FfiConverterTypeWitnessProgram.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AddressData {
    
    case p2pkh(pubkeyHash: String
    )
    case p2sh(scriptHash: String
    )
    case segwit(witnessProgram: WitnessProgram
    )
}


#if compiler(>=6)
extension AddressData: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddressData: FfiConverterRustBuffer {
    typealias SwiftType = AddressData

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressData {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .p2pkh(pubkeyHash: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .p2sh(scriptHash: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .segwit(witnessProgram: try FfiConverterTypeWitnessProgram.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AddressData, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .p2pkh(pubkeyHash):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(pubkeyHash, into: &buf)
            
        
        case let .p2sh(scriptHash):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(scriptHash, into: &buf)
            
        
        case let .segwit(witnessProgram):
            writeInt(&buf, Int32(3))
            FfiConverterTypeWitnessProgram.write(witnessProgram, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressData_lift(_ buf: RustBuffer) throws -> AddressData {
    return try FfiConverterTypeAddressData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressData_lower(_ value: AddressData) -> RustBuffer {
    return FfiConverterTypeAddressData.lower(value)
}


extension AddressData: Equatable, Hashable {}




public enum AddressParseError: Swift.Error {

    
    
    case Base58
    case Bech32
    case WitnessVersion(errorMessage: String
    )
    case WitnessProgram(errorMessage: String
    )
    case UnknownHrp
    case LegacyAddressTooLong
    case InvalidBase58PayloadLength
    case InvalidLegacyPrefix
    case NetworkValidation
    case OtherAddressParseErr
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddressParseError: FfiConverterRustBuffer {
    typealias SwiftType = AddressParseError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressParseError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Base58
        case 2: return .Bech32
        case 3: return .WitnessVersion(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 4: return .WitnessProgram(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 5: return .UnknownHrp
        case 6: return .LegacyAddressTooLong
        case 7: return .InvalidBase58PayloadLength
        case 8: return .InvalidLegacyPrefix
        case 9: return .NetworkValidation
        case 10: return .OtherAddressParseErr

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AddressParseError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .Base58:
            writeInt(&buf, Int32(1))
        
        
        case .Bech32:
            writeInt(&buf, Int32(2))
        
        
        case let .WitnessVersion(errorMessage):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .WitnessProgram(errorMessage):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .UnknownHrp:
            writeInt(&buf, Int32(5))
        
        
        case .LegacyAddressTooLong:
            writeInt(&buf, Int32(6))
        
        
        case .InvalidBase58PayloadLength:
            writeInt(&buf, Int32(7))
        
        
        case .InvalidLegacyPrefix:
            writeInt(&buf, Int32(8))
        
        
        case .NetworkValidation:
            writeInt(&buf, Int32(9))
        
        
        case .OtherAddressParseErr:
            writeInt(&buf, Int32(10))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressParseError_lift(_ buf: RustBuffer) throws -> AddressParseError {
    return try FfiConverterTypeAddressParseError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressParseError_lower(_ value: AddressParseError) -> RustBuffer {
    return FfiConverterTypeAddressParseError.lower(value)
}


extension AddressParseError: Equatable, Hashable {}



extension AddressParseError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum Bip32Error: Swift.Error {

    
    
    case CannotDeriveFromHardenedKey
    case Secp256k1(errorMessage: String
    )
    case InvalidChildNumber(childNumber: UInt32
    )
    case InvalidChildNumberFormat
    case InvalidDerivationPathFormat
    case UnknownVersion(version: String
    )
    case WrongExtendedKeyLength(length: UInt32
    )
    case Base58(errorMessage: String
    )
    case Hex(errorMessage: String
    )
    case InvalidPublicKeyHexLength(length: UInt32
    )
    case UnknownError(errorMessage: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBip32Error: FfiConverterRustBuffer {
    typealias SwiftType = Bip32Error

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip32Error {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .CannotDeriveFromHardenedKey
        case 2: return .Secp256k1(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 3: return .InvalidChildNumber(
            childNumber: try FfiConverterUInt32.read(from: &buf)
            )
        case 4: return .InvalidChildNumberFormat
        case 5: return .InvalidDerivationPathFormat
        case 6: return .UnknownVersion(
            version: try FfiConverterString.read(from: &buf)
            )
        case 7: return .WrongExtendedKeyLength(
            length: try FfiConverterUInt32.read(from: &buf)
            )
        case 8: return .Base58(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 9: return .Hex(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 10: return .InvalidPublicKeyHexLength(
            length: try FfiConverterUInt32.read(from: &buf)
            )
        case 11: return .UnknownError(
            errorMessage: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Bip32Error, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .CannotDeriveFromHardenedKey:
            writeInt(&buf, Int32(1))
        
        
        case let .Secp256k1(errorMessage):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .InvalidChildNumber(childNumber):
            writeInt(&buf, Int32(3))
            FfiConverterUInt32.write(childNumber, into: &buf)
            
        
        case .InvalidChildNumberFormat:
            writeInt(&buf, Int32(4))
        
        
        case .InvalidDerivationPathFormat:
            writeInt(&buf, Int32(5))
        
        
        case let .UnknownVersion(version):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(version, into: &buf)
            
        
        case let .WrongExtendedKeyLength(length):
            writeInt(&buf, Int32(7))
            FfiConverterUInt32.write(length, into: &buf)
            
        
        case let .Base58(errorMessage):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Hex(errorMessage):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .InvalidPublicKeyHexLength(length):
            writeInt(&buf, Int32(10))
            FfiConverterUInt32.write(length, into: &buf)
            
        
        case let .UnknownError(errorMessage):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(errorMessage, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBip32Error_lift(_ buf: RustBuffer) throws -> Bip32Error {
    return try FfiConverterTypeBip32Error.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBip32Error_lower(_ value: Bip32Error) -> RustBuffer {
    return FfiConverterTypeBip32Error.lower(value)
}


extension Bip32Error: Equatable, Hashable {}



extension Bip32Error: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum Bip39Error: Swift.Error {

    
    
    case BadWordCount(wordCount: UInt64
    )
    case UnknownWord(index: UInt64
    )
    case BadEntropyBitCount(bitCount: UInt64
    )
    case InvalidChecksum
    case AmbiguousLanguages(languages: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBip39Error: FfiConverterRustBuffer {
    typealias SwiftType = Bip39Error

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39Error {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .BadWordCount(
            wordCount: try FfiConverterUInt64.read(from: &buf)
            )
        case 2: return .UnknownWord(
            index: try FfiConverterUInt64.read(from: &buf)
            )
        case 3: return .BadEntropyBitCount(
            bitCount: try FfiConverterUInt64.read(from: &buf)
            )
        case 4: return .InvalidChecksum
        case 5: return .AmbiguousLanguages(
            languages: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Bip39Error, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .BadWordCount(wordCount):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(wordCount, into: &buf)
            
        
        case let .UnknownWord(index):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(index, into: &buf)
            
        
        case let .BadEntropyBitCount(bitCount):
            writeInt(&buf, Int32(3))
            FfiConverterUInt64.write(bitCount, into: &buf)
            
        
        case .InvalidChecksum:
            writeInt(&buf, Int32(4))
        
        
        case let .AmbiguousLanguages(languages):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(languages, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBip39Error_lift(_ buf: RustBuffer) throws -> Bip39Error {
    return try FfiConverterTypeBip39Error.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBip39Error_lower(_ value: Bip39Error) -> RustBuffer {
    return FfiConverterTypeBip39Error.lower(value)
}


extension Bip39Error: Equatable, Hashable {}



extension Bip39Error: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum CalculateFeeError: Swift.Error {

    
    
    case MissingTxOut(outPoints: [OutPoint]
    )
    case NegativeFee(amount: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCalculateFeeError: FfiConverterRustBuffer {
    typealias SwiftType = CalculateFeeError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CalculateFeeError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .MissingTxOut(
            outPoints: try FfiConverterSequenceTypeOutPoint.read(from: &buf)
            )
        case 2: return .NegativeFee(
            amount: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CalculateFeeError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .MissingTxOut(outPoints):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeOutPoint.write(outPoints, into: &buf)
            
        
        case let .NegativeFee(amount):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(amount, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCalculateFeeError_lift(_ buf: RustBuffer) throws -> CalculateFeeError {
    return try FfiConverterTypeCalculateFeeError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCalculateFeeError_lower(_ value: CalculateFeeError) -> RustBuffer {
    return FfiConverterTypeCalculateFeeError.lower(value)
}


extension CalculateFeeError: Equatable, Hashable {}



extension CalculateFeeError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum CannotConnectError: Swift.Error {

    
    
    case Include(height: UInt32
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCannotConnectError: FfiConverterRustBuffer {
    typealias SwiftType = CannotConnectError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CannotConnectError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Include(
            height: try FfiConverterUInt32.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CannotConnectError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Include(height):
            writeInt(&buf, Int32(1))
            FfiConverterUInt32.write(height, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCannotConnectError_lift(_ buf: RustBuffer) throws -> CannotConnectError {
    return try FfiConverterTypeCannotConnectError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCannotConnectError_lower(_ value: CannotConnectError) -> RustBuffer {
    return FfiConverterTypeCannotConnectError.lower(value)
}


extension CannotConnectError: Equatable, Hashable {}



extension CannotConnectError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum CbfBuilderError: Swift.Error {

    
    
    case DatabaseError(reason: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCbfBuilderError: FfiConverterRustBuffer {
    typealias SwiftType = CbfBuilderError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CbfBuilderError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .DatabaseError(
            reason: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CbfBuilderError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .DatabaseError(reason):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(reason, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCbfBuilderError_lift(_ buf: RustBuffer) throws -> CbfBuilderError {
    return try FfiConverterTypeCbfBuilderError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCbfBuilderError_lower(_ value: CbfBuilderError) -> RustBuffer {
    return FfiConverterTypeCbfBuilderError.lower(value)
}


extension CbfBuilderError: Equatable, Hashable {}



extension CbfBuilderError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum CbfError: Swift.Error {

    
    
    case NodeStopped
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCbfError: FfiConverterRustBuffer {
    typealias SwiftType = CbfError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CbfError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .NodeStopped

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CbfError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .NodeStopped:
            writeInt(&buf, Int32(1))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCbfError_lift(_ buf: RustBuffer) throws -> CbfError {
    return try FfiConverterTypeCbfError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCbfError_lower(_ value: CbfError) -> RustBuffer {
    return FfiConverterTypeCbfError.lower(value)
}


extension CbfError: Equatable, Hashable {}



extension CbfError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Represents the observed position of some chain data.
 */

public enum ChainPosition {
    
    /**
     * The chain data is confirmed as it is anchored in the best chain by `A`.
     */
    case confirmed(confirmationBlockTime: ConfirmationBlockTime, transitively: String?
    )
    /**
     * The chain data is not confirmed and last seen in the mempool at this timestamp.
     */
    case unconfirmed(timestamp: UInt64?
    )
}


#if compiler(>=6)
extension ChainPosition: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeChainPosition: FfiConverterRustBuffer {
    typealias SwiftType = ChainPosition

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChainPosition {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .confirmed(confirmationBlockTime: try FfiConverterTypeConfirmationBlockTime.read(from: &buf), transitively: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 2: return .unconfirmed(timestamp: try FfiConverterOptionUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ChainPosition, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .confirmed(confirmationBlockTime,transitively):
            writeInt(&buf, Int32(1))
            FfiConverterTypeConfirmationBlockTime.write(confirmationBlockTime, into: &buf)
            FfiConverterOptionString.write(transitively, into: &buf)
            
        
        case let .unconfirmed(timestamp):
            writeInt(&buf, Int32(2))
            FfiConverterOptionUInt64.write(timestamp, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChainPosition_lift(_ buf: RustBuffer) throws -> ChainPosition {
    return try FfiConverterTypeChainPosition.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChainPosition_lower(_ value: ChainPosition) -> RustBuffer {
    return FfiConverterTypeChainPosition.lower(value)
}


extension ChainPosition: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Policy regarding the use of change outputs when creating a transaction
 */

public enum ChangeSpendPolicy {
    
    /**
     * Use both change and non-change outputs (default)
     */
    case changeAllowed
    /**
     * Only use change outputs (see [`TxBuilder::only_spend_change`])
     */
    case onlyChange
    /**
     * Only use non-change outputs
     */
    case changeForbidden
}


#if compiler(>=6)
extension ChangeSpendPolicy: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeChangeSpendPolicy: FfiConverterRustBuffer {
    typealias SwiftType = ChangeSpendPolicy

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChangeSpendPolicy {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .changeAllowed
        
        case 2: return .onlyChange
        
        case 3: return .changeForbidden
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ChangeSpendPolicy, into buf: inout [UInt8]) {
        switch value {
        
        
        case .changeAllowed:
            writeInt(&buf, Int32(1))
        
        
        case .onlyChange:
            writeInt(&buf, Int32(2))
        
        
        case .changeForbidden:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChangeSpendPolicy_lift(_ buf: RustBuffer) throws -> ChangeSpendPolicy {
    return try FfiConverterTypeChangeSpendPolicy.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChangeSpendPolicy_lower(_ value: ChangeSpendPolicy) -> RustBuffer {
    return FfiConverterTypeChangeSpendPolicy.lower(value)
}


extension ChangeSpendPolicy: Equatable, Hashable {}




public enum CreateTxError: Swift.Error {

    
    
    case Descriptor(errorMessage: String
    )
    case Policy(errorMessage: String
    )
    case SpendingPolicyRequired(kind: String
    )
    case Version0
    case Version1Csv
    case LockTime(requested: String, required: String
    )
    case RbfSequenceCsv(sequence: String, csv: String
    )
    case FeeTooLow(required: String
    )
    case FeeRateTooLow(required: String
    )
    case NoUtxosSelected
    case OutputBelowDustLimit(index: UInt64
    )
    case ChangePolicyDescriptor
    case CoinSelection(errorMessage: String
    )
    case InsufficientFunds(needed: UInt64, available: UInt64
    )
    case NoRecipients
    case Psbt(errorMessage: String
    )
    case MissingKeyOrigin(key: String
    )
    case UnknownUtxo(outpoint: String
    )
    case MissingNonWitnessUtxo(outpoint: String
    )
    case MiniscriptPsbt(errorMessage: String
    )
    case PushBytesError
    case LockTimeConversionError
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCreateTxError: FfiConverterRustBuffer {
    typealias SwiftType = CreateTxError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CreateTxError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Descriptor(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 2: return .Policy(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 3: return .SpendingPolicyRequired(
            kind: try FfiConverterString.read(from: &buf)
            )
        case 4: return .Version0
        case 5: return .Version1Csv
        case 6: return .LockTime(
            requested: try FfiConverterString.read(from: &buf), 
            required: try FfiConverterString.read(from: &buf)
            )
        case 7: return .RbfSequenceCsv(
            sequence: try FfiConverterString.read(from: &buf), 
            csv: try FfiConverterString.read(from: &buf)
            )
        case 8: return .FeeTooLow(
            required: try FfiConverterString.read(from: &buf)
            )
        case 9: return .FeeRateTooLow(
            required: try FfiConverterString.read(from: &buf)
            )
        case 10: return .NoUtxosSelected
        case 11: return .OutputBelowDustLimit(
            index: try FfiConverterUInt64.read(from: &buf)
            )
        case 12: return .ChangePolicyDescriptor
        case 13: return .CoinSelection(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 14: return .InsufficientFunds(
            needed: try FfiConverterUInt64.read(from: &buf), 
            available: try FfiConverterUInt64.read(from: &buf)
            )
        case 15: return .NoRecipients
        case 16: return .Psbt(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 17: return .MissingKeyOrigin(
            key: try FfiConverterString.read(from: &buf)
            )
        case 18: return .UnknownUtxo(
            outpoint: try FfiConverterString.read(from: &buf)
            )
        case 19: return .MissingNonWitnessUtxo(
            outpoint: try FfiConverterString.read(from: &buf)
            )
        case 20: return .MiniscriptPsbt(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 21: return .PushBytesError
        case 22: return .LockTimeConversionError

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CreateTxError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Descriptor(errorMessage):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Policy(errorMessage):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .SpendingPolicyRequired(kind):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(kind, into: &buf)
            
        
        case .Version0:
            writeInt(&buf, Int32(4))
        
        
        case .Version1Csv:
            writeInt(&buf, Int32(5))
        
        
        case let .LockTime(requested,required):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(requested, into: &buf)
            FfiConverterString.write(required, into: &buf)
            
        
        case let .RbfSequenceCsv(sequence,csv):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(sequence, into: &buf)
            FfiConverterString.write(csv, into: &buf)
            
        
        case let .FeeTooLow(required):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(required, into: &buf)
            
        
        case let .FeeRateTooLow(required):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(required, into: &buf)
            
        
        case .NoUtxosSelected:
            writeInt(&buf, Int32(10))
        
        
        case let .OutputBelowDustLimit(index):
            writeInt(&buf, Int32(11))
            FfiConverterUInt64.write(index, into: &buf)
            
        
        case .ChangePolicyDescriptor:
            writeInt(&buf, Int32(12))
        
        
        case let .CoinSelection(errorMessage):
            writeInt(&buf, Int32(13))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .InsufficientFunds(needed,available):
            writeInt(&buf, Int32(14))
            FfiConverterUInt64.write(needed, into: &buf)
            FfiConverterUInt64.write(available, into: &buf)
            
        
        case .NoRecipients:
            writeInt(&buf, Int32(15))
        
        
        case let .Psbt(errorMessage):
            writeInt(&buf, Int32(16))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .MissingKeyOrigin(key):
            writeInt(&buf, Int32(17))
            FfiConverterString.write(key, into: &buf)
            
        
        case let .UnknownUtxo(outpoint):
            writeInt(&buf, Int32(18))
            FfiConverterString.write(outpoint, into: &buf)
            
        
        case let .MissingNonWitnessUtxo(outpoint):
            writeInt(&buf, Int32(19))
            FfiConverterString.write(outpoint, into: &buf)
            
        
        case let .MiniscriptPsbt(errorMessage):
            writeInt(&buf, Int32(20))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .PushBytesError:
            writeInt(&buf, Int32(21))
        
        
        case .LockTimeConversionError:
            writeInt(&buf, Int32(22))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCreateTxError_lift(_ buf: RustBuffer) throws -> CreateTxError {
    return try FfiConverterTypeCreateTxError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCreateTxError_lower(_ value: CreateTxError) -> RustBuffer {
    return FfiConverterTypeCreateTxError.lower(value)
}


extension CreateTxError: Equatable, Hashable {}



extension CreateTxError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum CreateWithPersistError: Swift.Error {

    
    
    case Persist(errorMessage: String
    )
    case DataAlreadyExists
    case Descriptor(errorMessage: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCreateWithPersistError: FfiConverterRustBuffer {
    typealias SwiftType = CreateWithPersistError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CreateWithPersistError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Persist(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 2: return .DataAlreadyExists
        case 3: return .Descriptor(
            errorMessage: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CreateWithPersistError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Persist(errorMessage):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .DataAlreadyExists:
            writeInt(&buf, Int32(2))
        
        
        case let .Descriptor(errorMessage):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(errorMessage, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCreateWithPersistError_lift(_ buf: RustBuffer) throws -> CreateWithPersistError {
    return try FfiConverterTypeCreateWithPersistError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCreateWithPersistError_lower(_ value: CreateWithPersistError) -> RustBuffer {
    return FfiConverterTypeCreateWithPersistError.lower(value)
}


extension CreateWithPersistError: Equatable, Hashable {}



extension CreateWithPersistError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum DescriptorError: Swift.Error {

    
    
    case InvalidHdKeyPath
    case InvalidDescriptorChecksum
    case HardenedDerivationXpub
    case MultiPath
    case Key(errorMessage: String
    )
    case Policy(errorMessage: String
    )
    case InvalidDescriptorCharacter(char: String
    )
    case Bip32(errorMessage: String
    )
    case Base58(errorMessage: String
    )
    case Pk(errorMessage: String
    )
    case Miniscript(errorMessage: String
    )
    case Hex(errorMessage: String
    )
    case ExternalAndInternalAreTheSame
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDescriptorError: FfiConverterRustBuffer {
    typealias SwiftType = DescriptorError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DescriptorError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidHdKeyPath
        case 2: return .InvalidDescriptorChecksum
        case 3: return .HardenedDerivationXpub
        case 4: return .MultiPath
        case 5: return .Key(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 6: return .Policy(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 7: return .InvalidDescriptorCharacter(
            char: try FfiConverterString.read(from: &buf)
            )
        case 8: return .Bip32(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 9: return .Base58(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 10: return .Pk(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 11: return .Miniscript(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 12: return .Hex(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 13: return .ExternalAndInternalAreTheSame

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DescriptorError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .InvalidHdKeyPath:
            writeInt(&buf, Int32(1))
        
        
        case .InvalidDescriptorChecksum:
            writeInt(&buf, Int32(2))
        
        
        case .HardenedDerivationXpub:
            writeInt(&buf, Int32(3))
        
        
        case .MultiPath:
            writeInt(&buf, Int32(4))
        
        
        case let .Key(errorMessage):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Policy(errorMessage):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .InvalidDescriptorCharacter(char):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(char, into: &buf)
            
        
        case let .Bip32(errorMessage):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Base58(errorMessage):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Pk(errorMessage):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Miniscript(errorMessage):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Hex(errorMessage):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .ExternalAndInternalAreTheSame:
            writeInt(&buf, Int32(13))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDescriptorError_lift(_ buf: RustBuffer) throws -> DescriptorError {
    return try FfiConverterTypeDescriptorError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDescriptorError_lower(_ value: DescriptorError) -> RustBuffer {
    return FfiConverterTypeDescriptorError.lower(value)
}


extension DescriptorError: Equatable, Hashable {}



extension DescriptorError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum DescriptorKeyError: Swift.Error {

    
    
    case Parse(errorMessage: String
    )
    case InvalidKeyType
    case Bip32(errorMessage: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDescriptorKeyError: FfiConverterRustBuffer {
    typealias SwiftType = DescriptorKeyError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DescriptorKeyError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Parse(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 2: return .InvalidKeyType
        case 3: return .Bip32(
            errorMessage: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DescriptorKeyError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Parse(errorMessage):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .InvalidKeyType:
            writeInt(&buf, Int32(2))
        
        
        case let .Bip32(errorMessage):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(errorMessage, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDescriptorKeyError_lift(_ buf: RustBuffer) throws -> DescriptorKeyError {
    return try FfiConverterTypeDescriptorKeyError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDescriptorKeyError_lower(_ value: DescriptorKeyError) -> RustBuffer {
    return FfiConverterTypeDescriptorKeyError.lower(value)
}


extension DescriptorKeyError: Equatable, Hashable {}



extension DescriptorKeyError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum ElectrumError: Swift.Error {

    
    
    case IoError(errorMessage: String
    )
    case Json(errorMessage: String
    )
    case Hex(errorMessage: String
    )
    case Protocol(errorMessage: String
    )
    case Bitcoin(errorMessage: String
    )
    case AlreadySubscribed
    case NotSubscribed
    case InvalidResponse(errorMessage: String
    )
    case Message(errorMessage: String
    )
    case InvalidDnsNameError(domain: String
    )
    case MissingDomain
    case AllAttemptsErrored
    case SharedIoError(errorMessage: String
    )
    case CouldntLockReader
    case Mpsc
    case CouldNotCreateConnection(errorMessage: String
    )
    case RequestAlreadyConsumed
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeElectrumError: FfiConverterRustBuffer {
    typealias SwiftType = ElectrumError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ElectrumError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .IoError(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 2: return .Json(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 3: return .Hex(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 4: return .Protocol(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 5: return .Bitcoin(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 6: return .AlreadySubscribed
        case 7: return .NotSubscribed
        case 8: return .InvalidResponse(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 9: return .Message(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 10: return .InvalidDnsNameError(
            domain: try FfiConverterString.read(from: &buf)
            )
        case 11: return .MissingDomain
        case 12: return .AllAttemptsErrored
        case 13: return .SharedIoError(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 14: return .CouldntLockReader
        case 15: return .Mpsc
        case 16: return .CouldNotCreateConnection(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 17: return .RequestAlreadyConsumed

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ElectrumError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .IoError(errorMessage):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Json(errorMessage):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Hex(errorMessage):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Protocol(errorMessage):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Bitcoin(errorMessage):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .AlreadySubscribed:
            writeInt(&buf, Int32(6))
        
        
        case .NotSubscribed:
            writeInt(&buf, Int32(7))
        
        
        case let .InvalidResponse(errorMessage):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Message(errorMessage):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .InvalidDnsNameError(domain):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(domain, into: &buf)
            
        
        case .MissingDomain:
            writeInt(&buf, Int32(11))
        
        
        case .AllAttemptsErrored:
            writeInt(&buf, Int32(12))
        
        
        case let .SharedIoError(errorMessage):
            writeInt(&buf, Int32(13))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .CouldntLockReader:
            writeInt(&buf, Int32(14))
        
        
        case .Mpsc:
            writeInt(&buf, Int32(15))
        
        
        case let .CouldNotCreateConnection(errorMessage):
            writeInt(&buf, Int32(16))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .RequestAlreadyConsumed:
            writeInt(&buf, Int32(17))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeElectrumError_lift(_ buf: RustBuffer) throws -> ElectrumError {
    return try FfiConverterTypeElectrumError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeElectrumError_lower(_ value: ElectrumError) -> RustBuffer {
    return FfiConverterTypeElectrumError.lower(value)
}


extension ElectrumError: Equatable, Hashable {}



extension ElectrumError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum EsploraError: Swift.Error {

    
    
    case Minreq(errorMessage: String
    )
    case HttpResponse(status: UInt16, errorMessage: String
    )
    case Parsing(errorMessage: String
    )
    case StatusCode(errorMessage: String
    )
    case BitcoinEncoding(errorMessage: String
    )
    case HexToArray(errorMessage: String
    )
    case HexToBytes(errorMessage: String
    )
    case TransactionNotFound
    case HeaderHeightNotFound(height: UInt32
    )
    case HeaderHashNotFound
    case InvalidHttpHeaderName(name: String
    )
    case InvalidHttpHeaderValue(value: String
    )
    case RequestAlreadyConsumed
    case InvalidResponse
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEsploraError: FfiConverterRustBuffer {
    typealias SwiftType = EsploraError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EsploraError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Minreq(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 2: return .HttpResponse(
            status: try FfiConverterUInt16.read(from: &buf), 
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 3: return .Parsing(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 4: return .StatusCode(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 5: return .BitcoinEncoding(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 6: return .HexToArray(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 7: return .HexToBytes(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 8: return .TransactionNotFound
        case 9: return .HeaderHeightNotFound(
            height: try FfiConverterUInt32.read(from: &buf)
            )
        case 10: return .HeaderHashNotFound
        case 11: return .InvalidHttpHeaderName(
            name: try FfiConverterString.read(from: &buf)
            )
        case 12: return .InvalidHttpHeaderValue(
            value: try FfiConverterString.read(from: &buf)
            )
        case 13: return .RequestAlreadyConsumed
        case 14: return .InvalidResponse

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EsploraError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Minreq(errorMessage):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .HttpResponse(status,errorMessage):
            writeInt(&buf, Int32(2))
            FfiConverterUInt16.write(status, into: &buf)
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Parsing(errorMessage):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .StatusCode(errorMessage):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .BitcoinEncoding(errorMessage):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .HexToArray(errorMessage):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .HexToBytes(errorMessage):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .TransactionNotFound:
            writeInt(&buf, Int32(8))
        
        
        case let .HeaderHeightNotFound(height):
            writeInt(&buf, Int32(9))
            FfiConverterUInt32.write(height, into: &buf)
            
        
        case .HeaderHashNotFound:
            writeInt(&buf, Int32(10))
        
        
        case let .InvalidHttpHeaderName(name):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(name, into: &buf)
            
        
        case let .InvalidHttpHeaderValue(value):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(value, into: &buf)
            
        
        case .RequestAlreadyConsumed:
            writeInt(&buf, Int32(13))
        
        
        case .InvalidResponse:
            writeInt(&buf, Int32(14))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEsploraError_lift(_ buf: RustBuffer) throws -> EsploraError {
    return try FfiConverterTypeEsploraError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEsploraError_lower(_ value: EsploraError) -> RustBuffer {
    return FfiConverterTypeEsploraError.lower(value)
}


extension EsploraError: Equatable, Hashable {}



extension EsploraError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum ExtractTxError: Swift.Error {

    
    
    case AbsurdFeeRate(feeRate: UInt64
    )
    case MissingInputValue
    case SendingTooMuch
    case OtherExtractTxErr
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExtractTxError: FfiConverterRustBuffer {
    typealias SwiftType = ExtractTxError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExtractTxError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .AbsurdFeeRate(
            feeRate: try FfiConverterUInt64.read(from: &buf)
            )
        case 2: return .MissingInputValue
        case 3: return .SendingTooMuch
        case 4: return .OtherExtractTxErr

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ExtractTxError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .AbsurdFeeRate(feeRate):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(feeRate, into: &buf)
            
        
        case .MissingInputValue:
            writeInt(&buf, Int32(2))
        
        
        case .SendingTooMuch:
            writeInt(&buf, Int32(3))
        
        
        case .OtherExtractTxErr:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExtractTxError_lift(_ buf: RustBuffer) throws -> ExtractTxError {
    return try FfiConverterTypeExtractTxError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExtractTxError_lower(_ value: ExtractTxError) -> RustBuffer {
    return FfiConverterTypeExtractTxError.lower(value)
}


extension ExtractTxError: Equatable, Hashable {}



extension ExtractTxError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum FeeRateError: Swift.Error {

    
    
    case ArithmeticOverflow
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFeeRateError: FfiConverterRustBuffer {
    typealias SwiftType = FeeRateError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeRateError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ArithmeticOverflow

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FeeRateError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .ArithmeticOverflow:
            writeInt(&buf, Int32(1))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRateError_lift(_ buf: RustBuffer) throws -> FeeRateError {
    return try FfiConverterTypeFeeRateError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRateError_lower(_ value: FeeRateError) -> RustBuffer {
    return FfiConverterTypeFeeRateError.lower(value)
}


extension FeeRateError: Equatable, Hashable {}



extension FeeRateError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum FromScriptError: Swift.Error {

    
    
    case UnrecognizedScript
    case WitnessProgram(errorMessage: String
    )
    case WitnessVersion(errorMessage: String
    )
    case OtherFromScriptErr
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFromScriptError: FfiConverterRustBuffer {
    typealias SwiftType = FromScriptError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FromScriptError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .UnrecognizedScript
        case 2: return .WitnessProgram(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 3: return .WitnessVersion(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 4: return .OtherFromScriptErr

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FromScriptError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .UnrecognizedScript:
            writeInt(&buf, Int32(1))
        
        
        case let .WitnessProgram(errorMessage):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .WitnessVersion(errorMessage):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .OtherFromScriptErr:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFromScriptError_lift(_ buf: RustBuffer) throws -> FromScriptError {
    return try FfiConverterTypeFromScriptError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFromScriptError_lower(_ value: FromScriptError) -> RustBuffer {
    return FfiConverterTypeFromScriptError.lower(value)
}


extension FromScriptError: Equatable, Hashable {}



extension FromScriptError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Types of keychains
 */

public enum KeychainKind {
    
    /**
     * External keychain, used for deriving recipient addresses.
     */
    case external
    /**
     * Internal keychain, used for deriving change addresses.
     */
    case `internal`
}


#if compiler(>=6)
extension KeychainKind: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKeychainKind: FfiConverterRustBuffer {
    typealias SwiftType = KeychainKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeychainKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .external
        
        case 2: return .`internal`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: KeychainKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .external:
            writeInt(&buf, Int32(1))
        
        
        case .`internal`:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeychainKind_lift(_ buf: RustBuffer) throws -> KeychainKind {
    return try FfiConverterTypeKeychainKind.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeychainKind_lower(_ value: KeychainKind) -> RustBuffer {
    return FfiConverterTypeKeychainKind.lower(value)
}


extension KeychainKind: Equatable, Hashable {}




public enum LoadWithPersistError: Swift.Error {

    
    
    case Persist(errorMessage: String
    )
    case InvalidChangeSet(errorMessage: String
    )
    case CouldNotLoad
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLoadWithPersistError: FfiConverterRustBuffer {
    typealias SwiftType = LoadWithPersistError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LoadWithPersistError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Persist(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 2: return .InvalidChangeSet(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 3: return .CouldNotLoad

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LoadWithPersistError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Persist(errorMessage):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .InvalidChangeSet(errorMessage):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .CouldNotLoad:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLoadWithPersistError_lift(_ buf: RustBuffer) throws -> LoadWithPersistError {
    return try FfiConverterTypeLoadWithPersistError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLoadWithPersistError_lower(_ value: LoadWithPersistError) -> RustBuffer {
    return FfiConverterTypeLoadWithPersistError.lower(value)
}


extension LoadWithPersistError: Equatable, Hashable {}



extension LoadWithPersistError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LockTime {
    
    case blocks(height: UInt32
    )
    case seconds(consensusTime: UInt32
    )
}


#if compiler(>=6)
extension LockTime: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLockTime: FfiConverterRustBuffer {
    typealias SwiftType = LockTime

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LockTime {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .blocks(height: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 2: return .seconds(consensusTime: try FfiConverterUInt32.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LockTime, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .blocks(height):
            writeInt(&buf, Int32(1))
            FfiConverterUInt32.write(height, into: &buf)
            
        
        case let .seconds(consensusTime):
            writeInt(&buf, Int32(2))
            FfiConverterUInt32.write(consensusTime, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLockTime_lift(_ buf: RustBuffer) throws -> LockTime {
    return try FfiConverterTypeLockTime.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLockTime_lower(_ value: LockTime) -> RustBuffer {
    return FfiConverterTypeLockTime.lower(value)
}


extension LockTime: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A log message from the node.
 */

public enum Log {
    
    /**
     * A human-readable debug message.
     */
    case debug(log: String
    )
    /**
     * All the required connections have been met. This is subject to change.
     */
    case connectionsMet
    /**
     * A percentage value of filters that have been scanned.
     */
    case progress(progress: Float
    )
    /**
     * A state in the node syncing process.
     */
    case stateUpdate(nodeState: NodeState
    )
    /**
     * A transaction was broadcast over the wire.
     * The transaction may or may not be rejected by recipient nodes.
     */
    case txSent(txid: String
    )
}


#if compiler(>=6)
extension Log: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLog: FfiConverterRustBuffer {
    typealias SwiftType = Log

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Log {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .debug(log: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .connectionsMet
        
        case 3: return .progress(progress: try FfiConverterFloat.read(from: &buf)
        )
        
        case 4: return .stateUpdate(nodeState: try FfiConverterTypeNodeState.read(from: &buf)
        )
        
        case 5: return .txSent(txid: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Log, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .debug(log):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(log, into: &buf)
            
        
        case .connectionsMet:
            writeInt(&buf, Int32(2))
        
        
        case let .progress(progress):
            writeInt(&buf, Int32(3))
            FfiConverterFloat.write(progress, into: &buf)
            
        
        case let .stateUpdate(nodeState):
            writeInt(&buf, Int32(4))
            FfiConverterTypeNodeState.write(nodeState, into: &buf)
            
        
        case let .txSent(txid):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(txid, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLog_lift(_ buf: RustBuffer) throws -> Log {
    return try FfiConverterTypeLog.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLog_lower(_ value: Log) -> RustBuffer {
    return FfiConverterTypeLog.lower(value)
}


extension Log: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Select the category of messages for the node to emit.
 */

public enum LogLevel {
    
    /**
     * Send `Log::Debug` messages. These messages are intended for debugging or troubleshooting
     * node operation.
     */
    case debug
    /**
     * Omit `Log::Debug` messages, including their memory allocations. Ideal for a production
     * application that uses minimal logging.
     */
    case warning
}


#if compiler(>=6)
extension LogLevel: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLogLevel: FfiConverterRustBuffer {
    typealias SwiftType = LogLevel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogLevel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .debug
        
        case 2: return .warning
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LogLevel, into buf: inout [UInt8]) {
        switch value {
        
        
        case .debug:
            writeInt(&buf, Int32(1))
        
        
        case .warning:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLogLevel_lift(_ buf: RustBuffer) throws -> LogLevel {
    return try FfiConverterTypeLogLevel.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLogLevel_lower(_ value: LogLevel) -> RustBuffer {
    return FfiConverterTypeLogLevel.lower(value)
}


extension LogLevel: Equatable, Hashable {}




public enum MiniscriptError: Swift.Error {

    
    
    case AbsoluteLockTime
    case AddrError(errorMessage: String
    )
    case AddrP2shError(errorMessage: String
    )
    case AnalysisError(errorMessage: String
    )
    case AtOutsideOr
    case BadDescriptor(errorMessage: String
    )
    case BareDescriptorAddr
    case CmsTooManyKeys(keys: UInt32
    )
    case ContextError(errorMessage: String
    )
    case CouldNotSatisfy
    case ExpectedChar(char: String
    )
    case ImpossibleSatisfaction
    case InvalidOpcode
    case InvalidPush
    case LiftError(errorMessage: String
    )
    case MaxRecursiveDepthExceeded
    case MissingSig
    case MultiATooManyKeys(keys: UInt64
    )
    case MultiColon
    case MultipathDescLenMismatch
    case NonMinimalVerify(errorMessage: String
    )
    case NonStandardBareScript
    case NonTopLevel(errorMessage: String
    )
    case ParseThreshold
    case PolicyError(errorMessage: String
    )
    case PubKeyCtxError
    case RelativeLockTime
    case Script(errorMessage: String
    )
    case Secp(errorMessage: String
    )
    case Threshold
    case TrNoScriptCode
    case Trailing(errorMessage: String
    )
    case TypeCheck(errorMessage: String
    )
    case Unexpected(errorMessage: String
    )
    case UnexpectedStart
    case UnknownWrapper(char: String
    )
    case Unprintable(byte: UInt8
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMiniscriptError: FfiConverterRustBuffer {
    typealias SwiftType = MiniscriptError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MiniscriptError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .AbsoluteLockTime
        case 2: return .AddrError(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 3: return .AddrP2shError(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 4: return .AnalysisError(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 5: return .AtOutsideOr
        case 6: return .BadDescriptor(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 7: return .BareDescriptorAddr
        case 8: return .CmsTooManyKeys(
            keys: try FfiConverterUInt32.read(from: &buf)
            )
        case 9: return .ContextError(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 10: return .CouldNotSatisfy
        case 11: return .ExpectedChar(
            char: try FfiConverterString.read(from: &buf)
            )
        case 12: return .ImpossibleSatisfaction
        case 13: return .InvalidOpcode
        case 14: return .InvalidPush
        case 15: return .LiftError(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 16: return .MaxRecursiveDepthExceeded
        case 17: return .MissingSig
        case 18: return .MultiATooManyKeys(
            keys: try FfiConverterUInt64.read(from: &buf)
            )
        case 19: return .MultiColon
        case 20: return .MultipathDescLenMismatch
        case 21: return .NonMinimalVerify(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 22: return .NonStandardBareScript
        case 23: return .NonTopLevel(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 24: return .ParseThreshold
        case 25: return .PolicyError(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 26: return .PubKeyCtxError
        case 27: return .RelativeLockTime
        case 28: return .Script(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 29: return .Secp(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 30: return .Threshold
        case 31: return .TrNoScriptCode
        case 32: return .Trailing(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 33: return .TypeCheck(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 34: return .Unexpected(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 35: return .UnexpectedStart
        case 36: return .UnknownWrapper(
            char: try FfiConverterString.read(from: &buf)
            )
        case 37: return .Unprintable(
            byte: try FfiConverterUInt8.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MiniscriptError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .AbsoluteLockTime:
            writeInt(&buf, Int32(1))
        
        
        case let .AddrError(errorMessage):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .AddrP2shError(errorMessage):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .AnalysisError(errorMessage):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .AtOutsideOr:
            writeInt(&buf, Int32(5))
        
        
        case let .BadDescriptor(errorMessage):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .BareDescriptorAddr:
            writeInt(&buf, Int32(7))
        
        
        case let .CmsTooManyKeys(keys):
            writeInt(&buf, Int32(8))
            FfiConverterUInt32.write(keys, into: &buf)
            
        
        case let .ContextError(errorMessage):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .CouldNotSatisfy:
            writeInt(&buf, Int32(10))
        
        
        case let .ExpectedChar(char):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(char, into: &buf)
            
        
        case .ImpossibleSatisfaction:
            writeInt(&buf, Int32(12))
        
        
        case .InvalidOpcode:
            writeInt(&buf, Int32(13))
        
        
        case .InvalidPush:
            writeInt(&buf, Int32(14))
        
        
        case let .LiftError(errorMessage):
            writeInt(&buf, Int32(15))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .MaxRecursiveDepthExceeded:
            writeInt(&buf, Int32(16))
        
        
        case .MissingSig:
            writeInt(&buf, Int32(17))
        
        
        case let .MultiATooManyKeys(keys):
            writeInt(&buf, Int32(18))
            FfiConverterUInt64.write(keys, into: &buf)
            
        
        case .MultiColon:
            writeInt(&buf, Int32(19))
        
        
        case .MultipathDescLenMismatch:
            writeInt(&buf, Int32(20))
        
        
        case let .NonMinimalVerify(errorMessage):
            writeInt(&buf, Int32(21))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .NonStandardBareScript:
            writeInt(&buf, Int32(22))
        
        
        case let .NonTopLevel(errorMessage):
            writeInt(&buf, Int32(23))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .ParseThreshold:
            writeInt(&buf, Int32(24))
        
        
        case let .PolicyError(errorMessage):
            writeInt(&buf, Int32(25))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .PubKeyCtxError:
            writeInt(&buf, Int32(26))
        
        
        case .RelativeLockTime:
            writeInt(&buf, Int32(27))
        
        
        case let .Script(errorMessage):
            writeInt(&buf, Int32(28))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Secp(errorMessage):
            writeInt(&buf, Int32(29))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .Threshold:
            writeInt(&buf, Int32(30))
        
        
        case .TrNoScriptCode:
            writeInt(&buf, Int32(31))
        
        
        case let .Trailing(errorMessage):
            writeInt(&buf, Int32(32))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .TypeCheck(errorMessage):
            writeInt(&buf, Int32(33))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Unexpected(errorMessage):
            writeInt(&buf, Int32(34))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .UnexpectedStart:
            writeInt(&buf, Int32(35))
        
        
        case let .UnknownWrapper(char):
            writeInt(&buf, Int32(36))
            FfiConverterString.write(char, into: &buf)
            
        
        case let .Unprintable(byte):
            writeInt(&buf, Int32(37))
            FfiConverterUInt8.write(byte, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMiniscriptError_lift(_ buf: RustBuffer) throws -> MiniscriptError {
    return try FfiConverterTypeMiniscriptError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMiniscriptError_lower(_ value: MiniscriptError) -> RustBuffer {
    return FfiConverterTypeMiniscriptError.lower(value)
}


extension MiniscriptError: Equatable, Hashable {}



extension MiniscriptError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Network {
    
    case bitcoin
    case testnet
    case signet
    case regtest
    case testnet4
}


#if compiler(>=6)
extension Network: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = Network

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Network {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoin
        
        case 2: return .testnet
        
        case 3: return .signet
        
        case 4: return .regtest
        
        case 5: return .testnet4
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Network, into buf: inout [UInt8]) {
        switch value {
        
        
        case .bitcoin:
            writeInt(&buf, Int32(1))
        
        
        case .testnet:
            writeInt(&buf, Int32(2))
        
        
        case .signet:
            writeInt(&buf, Int32(3))
        
        
        case .regtest:
            writeInt(&buf, Int32(4))
        
        
        case .testnet4:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetwork_lift(_ buf: RustBuffer) throws -> Network {
    return try FfiConverterTypeNetwork.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetwork_lower(_ value: Network) -> RustBuffer {
    return FfiConverterTypeNetwork.lower(value)
}


extension Network: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The state of the node with respect to connected peers.
 */

public enum NodeState {
    
    /**
     * We are behind on block headers according to our peers.
     */
    case behind
    /**
     * We may start downloading compact block filter headers.
     */
    case headersSynced
    /**
     * We may start scanning compact block filters.
     */
    case filterHeadersSynced
    /**
     * We may start asking for blocks with matches.
     */
    case filtersSynced
    /**
     * We found all known transactions to the wallet.
     */
    case transactionsSynced
}


#if compiler(>=6)
extension NodeState: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNodeState: FfiConverterRustBuffer {
    typealias SwiftType = NodeState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .behind
        
        case 2: return .headersSynced
        
        case 3: return .filterHeadersSynced
        
        case 4: return .filtersSynced
        
        case 5: return .transactionsSynced
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NodeState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .behind:
            writeInt(&buf, Int32(1))
        
        
        case .headersSynced:
            writeInt(&buf, Int32(2))
        
        
        case .filterHeadersSynced:
            writeInt(&buf, Int32(3))
        
        
        case .filtersSynced:
            writeInt(&buf, Int32(4))
        
        
        case .transactionsSynced:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeState_lift(_ buf: RustBuffer) throws -> NodeState {
    return try FfiConverterTypeNodeState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeState_lower(_ value: NodeState) -> RustBuffer {
    return FfiConverterTypeNodeState.lower(value)
}


extension NodeState: Equatable, Hashable {}




public enum ParseAmountError: Swift.Error {

    
    
    case OutOfRange
    case TooPrecise
    case MissingDigits
    case InputTooLarge
    case InvalidCharacter(errorMessage: String
    )
    case OtherParseAmountErr
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeParseAmountError: FfiConverterRustBuffer {
    typealias SwiftType = ParseAmountError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParseAmountError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .OutOfRange
        case 2: return .TooPrecise
        case 3: return .MissingDigits
        case 4: return .InputTooLarge
        case 5: return .InvalidCharacter(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 6: return .OtherParseAmountErr

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ParseAmountError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .OutOfRange:
            writeInt(&buf, Int32(1))
        
        
        case .TooPrecise:
            writeInt(&buf, Int32(2))
        
        
        case .MissingDigits:
            writeInt(&buf, Int32(3))
        
        
        case .InputTooLarge:
            writeInt(&buf, Int32(4))
        
        
        case let .InvalidCharacter(errorMessage):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .OtherParseAmountErr:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParseAmountError_lift(_ buf: RustBuffer) throws -> ParseAmountError {
    return try FfiConverterTypeParseAmountError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParseAmountError_lower(_ value: ParseAmountError) -> RustBuffer {
    return FfiConverterTypeParseAmountError.lower(value)
}


extension ParseAmountError: Equatable, Hashable {}



extension ParseAmountError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum PersistenceError: Swift.Error {

    
    
    case Write(errorMessage: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePersistenceError: FfiConverterRustBuffer {
    typealias SwiftType = PersistenceError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersistenceError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Write(
            errorMessage: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PersistenceError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Write(errorMessage):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(errorMessage, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePersistenceError_lift(_ buf: RustBuffer) throws -> PersistenceError {
    return try FfiConverterTypePersistenceError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePersistenceError_lower(_ value: PersistenceError) -> RustBuffer {
    return FfiConverterTypePersistenceError.lower(value)
}


extension PersistenceError: Equatable, Hashable {}



extension PersistenceError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PkOrF {
    
    case pubkey(value: String
    )
    case xOnlyPubkey(value: String
    )
    case fingerprint(value: String
    )
}


#if compiler(>=6)
extension PkOrF: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePkOrF: FfiConverterRustBuffer {
    typealias SwiftType = PkOrF

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PkOrF {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .pubkey(value: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .xOnlyPubkey(value: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .fingerprint(value: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PkOrF, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .pubkey(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .xOnlyPubkey(value):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .fingerprint(value):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePkOrF_lift(_ buf: RustBuffer) throws -> PkOrF {
    return try FfiConverterTypePkOrF.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePkOrF_lower(_ value: PkOrF) -> RustBuffer {
    return FfiConverterTypePkOrF.lower(value)
}


extension PkOrF: Equatable, Hashable {}




public enum PsbtError: Swift.Error {

    
    
    case InvalidMagic
    case MissingUtxo
    case InvalidSeparator
    case PsbtUtxoOutOfBounds
    case InvalidKey(key: String
    )
    case InvalidProprietaryKey
    case DuplicateKey(key: String
    )
    case UnsignedTxHasScriptSigs
    case UnsignedTxHasScriptWitnesses
    case MustHaveUnsignedTx
    case NoMorePairs
    case UnexpectedUnsignedTx
    case NonStandardSighashType(sighash: UInt32
    )
    case InvalidHash(hash: String
    )
    case InvalidPreimageHashPair
    case CombineInconsistentKeySources(xpub: String
    )
    case ConsensusEncoding(encodingError: String
    )
    case NegativeFee
    case FeeOverflow
    case InvalidPublicKey(errorMessage: String
    )
    case InvalidSecp256k1PublicKey(secp256k1Error: String
    )
    case InvalidXOnlyPublicKey
    case InvalidEcdsaSignature(errorMessage: String
    )
    case InvalidTaprootSignature(errorMessage: String
    )
    case InvalidControlBlock
    case InvalidLeafVersion
    case Taproot
    case TapTree(errorMessage: String
    )
    case XPubKey
    case Version(errorMessage: String
    )
    case PartialDataConsumption
    case Io(errorMessage: String
    )
    case OtherPsbtErr
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePsbtError: FfiConverterRustBuffer {
    typealias SwiftType = PsbtError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PsbtError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidMagic
        case 2: return .MissingUtxo
        case 3: return .InvalidSeparator
        case 4: return .PsbtUtxoOutOfBounds
        case 5: return .InvalidKey(
            key: try FfiConverterString.read(from: &buf)
            )
        case 6: return .InvalidProprietaryKey
        case 7: return .DuplicateKey(
            key: try FfiConverterString.read(from: &buf)
            )
        case 8: return .UnsignedTxHasScriptSigs
        case 9: return .UnsignedTxHasScriptWitnesses
        case 10: return .MustHaveUnsignedTx
        case 11: return .NoMorePairs
        case 12: return .UnexpectedUnsignedTx
        case 13: return .NonStandardSighashType(
            sighash: try FfiConverterUInt32.read(from: &buf)
            )
        case 14: return .InvalidHash(
            hash: try FfiConverterString.read(from: &buf)
            )
        case 15: return .InvalidPreimageHashPair
        case 16: return .CombineInconsistentKeySources(
            xpub: try FfiConverterString.read(from: &buf)
            )
        case 17: return .ConsensusEncoding(
            encodingError: try FfiConverterString.read(from: &buf)
            )
        case 18: return .NegativeFee
        case 19: return .FeeOverflow
        case 20: return .InvalidPublicKey(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 21: return .InvalidSecp256k1PublicKey(
            secp256k1Error: try FfiConverterString.read(from: &buf)
            )
        case 22: return .InvalidXOnlyPublicKey
        case 23: return .InvalidEcdsaSignature(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 24: return .InvalidTaprootSignature(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 25: return .InvalidControlBlock
        case 26: return .InvalidLeafVersion
        case 27: return .Taproot
        case 28: return .TapTree(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 29: return .XPubKey
        case 30: return .Version(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 31: return .PartialDataConsumption
        case 32: return .Io(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 33: return .OtherPsbtErr

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PsbtError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .InvalidMagic:
            writeInt(&buf, Int32(1))
        
        
        case .MissingUtxo:
            writeInt(&buf, Int32(2))
        
        
        case .InvalidSeparator:
            writeInt(&buf, Int32(3))
        
        
        case .PsbtUtxoOutOfBounds:
            writeInt(&buf, Int32(4))
        
        
        case let .InvalidKey(key):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(key, into: &buf)
            
        
        case .InvalidProprietaryKey:
            writeInt(&buf, Int32(6))
        
        
        case let .DuplicateKey(key):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(key, into: &buf)
            
        
        case .UnsignedTxHasScriptSigs:
            writeInt(&buf, Int32(8))
        
        
        case .UnsignedTxHasScriptWitnesses:
            writeInt(&buf, Int32(9))
        
        
        case .MustHaveUnsignedTx:
            writeInt(&buf, Int32(10))
        
        
        case .NoMorePairs:
            writeInt(&buf, Int32(11))
        
        
        case .UnexpectedUnsignedTx:
            writeInt(&buf, Int32(12))
        
        
        case let .NonStandardSighashType(sighash):
            writeInt(&buf, Int32(13))
            FfiConverterUInt32.write(sighash, into: &buf)
            
        
        case let .InvalidHash(hash):
            writeInt(&buf, Int32(14))
            FfiConverterString.write(hash, into: &buf)
            
        
        case .InvalidPreimageHashPair:
            writeInt(&buf, Int32(15))
        
        
        case let .CombineInconsistentKeySources(xpub):
            writeInt(&buf, Int32(16))
            FfiConverterString.write(xpub, into: &buf)
            
        
        case let .ConsensusEncoding(encodingError):
            writeInt(&buf, Int32(17))
            FfiConverterString.write(encodingError, into: &buf)
            
        
        case .NegativeFee:
            writeInt(&buf, Int32(18))
        
        
        case .FeeOverflow:
            writeInt(&buf, Int32(19))
        
        
        case let .InvalidPublicKey(errorMessage):
            writeInt(&buf, Int32(20))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .InvalidSecp256k1PublicKey(secp256k1Error):
            writeInt(&buf, Int32(21))
            FfiConverterString.write(secp256k1Error, into: &buf)
            
        
        case .InvalidXOnlyPublicKey:
            writeInt(&buf, Int32(22))
        
        
        case let .InvalidEcdsaSignature(errorMessage):
            writeInt(&buf, Int32(23))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .InvalidTaprootSignature(errorMessage):
            writeInt(&buf, Int32(24))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .InvalidControlBlock:
            writeInt(&buf, Int32(25))
        
        
        case .InvalidLeafVersion:
            writeInt(&buf, Int32(26))
        
        
        case .Taproot:
            writeInt(&buf, Int32(27))
        
        
        case let .TapTree(errorMessage):
            writeInt(&buf, Int32(28))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .XPubKey:
            writeInt(&buf, Int32(29))
        
        
        case let .Version(errorMessage):
            writeInt(&buf, Int32(30))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .PartialDataConsumption:
            writeInt(&buf, Int32(31))
        
        
        case let .Io(errorMessage):
            writeInt(&buf, Int32(32))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .OtherPsbtErr:
            writeInt(&buf, Int32(33))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePsbtError_lift(_ buf: RustBuffer) throws -> PsbtError {
    return try FfiConverterTypePsbtError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePsbtError_lower(_ value: PsbtError) -> RustBuffer {
    return FfiConverterTypePsbtError.lower(value)
}


extension PsbtError: Equatable, Hashable {}



extension PsbtError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum PsbtFinalizeError: Swift.Error {

    
    
    case InputError(reason: String, index: UInt32
    )
    case WrongInputCount(inTx: UInt32, inMap: UInt32
    )
    case InputIdxOutofBounds(psbtInp: UInt32, requested: UInt32
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePsbtFinalizeError: FfiConverterRustBuffer {
    typealias SwiftType = PsbtFinalizeError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PsbtFinalizeError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InputError(
            reason: try FfiConverterString.read(from: &buf), 
            index: try FfiConverterUInt32.read(from: &buf)
            )
        case 2: return .WrongInputCount(
            inTx: try FfiConverterUInt32.read(from: &buf), 
            inMap: try FfiConverterUInt32.read(from: &buf)
            )
        case 3: return .InputIdxOutofBounds(
            psbtInp: try FfiConverterUInt32.read(from: &buf), 
            requested: try FfiConverterUInt32.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PsbtFinalizeError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InputError(reason,index):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(reason, into: &buf)
            FfiConverterUInt32.write(index, into: &buf)
            
        
        case let .WrongInputCount(inTx,inMap):
            writeInt(&buf, Int32(2))
            FfiConverterUInt32.write(inTx, into: &buf)
            FfiConverterUInt32.write(inMap, into: &buf)
            
        
        case let .InputIdxOutofBounds(psbtInp,requested):
            writeInt(&buf, Int32(3))
            FfiConverterUInt32.write(psbtInp, into: &buf)
            FfiConverterUInt32.write(requested, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePsbtFinalizeError_lift(_ buf: RustBuffer) throws -> PsbtFinalizeError {
    return try FfiConverterTypePsbtFinalizeError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePsbtFinalizeError_lower(_ value: PsbtFinalizeError) -> RustBuffer {
    return FfiConverterTypePsbtFinalizeError.lower(value)
}


extension PsbtFinalizeError: Equatable, Hashable {}



extension PsbtFinalizeError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum PsbtParseError: Swift.Error {

    
    
    case PsbtEncoding(errorMessage: String
    )
    case Base64Encoding(errorMessage: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePsbtParseError: FfiConverterRustBuffer {
    typealias SwiftType = PsbtParseError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PsbtParseError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .PsbtEncoding(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 2: return .Base64Encoding(
            errorMessage: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PsbtParseError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .PsbtEncoding(errorMessage):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Base64Encoding(errorMessage):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(errorMessage, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePsbtParseError_lift(_ buf: RustBuffer) throws -> PsbtParseError {
    return try FfiConverterTypePsbtParseError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePsbtParseError_lower(_ value: PsbtParseError) -> RustBuffer {
    return FfiConverterTypePsbtParseError.lower(value)
}


extension PsbtParseError: Equatable, Hashable {}



extension PsbtParseError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum RequestBuilderError: Swift.Error {

    
    
    case RequestAlreadyConsumed
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRequestBuilderError: FfiConverterRustBuffer {
    typealias SwiftType = RequestBuilderError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestBuilderError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .RequestAlreadyConsumed

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RequestBuilderError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .RequestAlreadyConsumed:
            writeInt(&buf, Int32(1))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRequestBuilderError_lift(_ buf: RustBuffer) throws -> RequestBuilderError {
    return try FfiConverterTypeRequestBuilderError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRequestBuilderError_lower(_ value: RequestBuilderError) -> RustBuffer {
    return FfiConverterTypeRequestBuilderError.lower(value)
}


extension RequestBuilderError: Equatable, Hashable {}



extension RequestBuilderError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Satisfaction {
    
    case partial(n: UInt64, m: UInt64, items: [UInt64], sorted: Bool?, conditions: [UInt32: [Condition]]
    )
    case partialComplete(n: UInt64, m: UInt64, items: [UInt64], sorted: Bool?, conditions: [[UInt32]: [Condition]]
    )
    case complete(condition: Condition
    )
    case none(msg: String
    )
}


#if compiler(>=6)
extension Satisfaction: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSatisfaction: FfiConverterRustBuffer {
    typealias SwiftType = Satisfaction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Satisfaction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .partial(n: try FfiConverterUInt64.read(from: &buf), m: try FfiConverterUInt64.read(from: &buf), items: try FfiConverterSequenceUInt64.read(from: &buf), sorted: try FfiConverterOptionBool.read(from: &buf), conditions: try FfiConverterDictionaryUInt32SequenceTypeCondition.read(from: &buf)
        )
        
        case 2: return .partialComplete(n: try FfiConverterUInt64.read(from: &buf), m: try FfiConverterUInt64.read(from: &buf), items: try FfiConverterSequenceUInt64.read(from: &buf), sorted: try FfiConverterOptionBool.read(from: &buf), conditions: try FfiConverterDictionarySequenceUInt32SequenceTypeCondition.read(from: &buf)
        )
        
        case 3: return .complete(condition: try FfiConverterTypeCondition.read(from: &buf)
        )
        
        case 4: return .none(msg: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Satisfaction, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .partial(n,m,items,sorted,conditions):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(n, into: &buf)
            FfiConverterUInt64.write(m, into: &buf)
            FfiConverterSequenceUInt64.write(items, into: &buf)
            FfiConverterOptionBool.write(sorted, into: &buf)
            FfiConverterDictionaryUInt32SequenceTypeCondition.write(conditions, into: &buf)
            
        
        case let .partialComplete(n,m,items,sorted,conditions):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(n, into: &buf)
            FfiConverterUInt64.write(m, into: &buf)
            FfiConverterSequenceUInt64.write(items, into: &buf)
            FfiConverterOptionBool.write(sorted, into: &buf)
            FfiConverterDictionarySequenceUInt32SequenceTypeCondition.write(conditions, into: &buf)
            
        
        case let .complete(condition):
            writeInt(&buf, Int32(3))
            FfiConverterTypeCondition.write(condition, into: &buf)
            
        
        case let .none(msg):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(msg, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSatisfaction_lift(_ buf: RustBuffer) throws -> Satisfaction {
    return try FfiConverterTypeSatisfaction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSatisfaction_lower(_ value: Satisfaction) -> RustBuffer {
    return FfiConverterTypeSatisfaction.lower(value)
}


extension Satisfaction: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SatisfiableItem {
    
    case ecdsaSignature(key: PkOrF
    )
    case schnorrSignature(key: PkOrF
    )
    case sha256Preimage(hash: String
    )
    case hash256Preimage(hash: String
    )
    case ripemd160Preimage(hash: String
    )
    case hash160Preimage(hash: String
    )
    case absoluteTimelock(value: LockTime
    )
    case relativeTimelock(value: UInt32
    )
    case multisig(keys: [PkOrF], threshold: UInt64
    )
    case thresh(items: [Policy], threshold: UInt64
    )
}


#if compiler(>=6)
extension SatisfiableItem: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSatisfiableItem: FfiConverterRustBuffer {
    typealias SwiftType = SatisfiableItem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SatisfiableItem {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ecdsaSignature(key: try FfiConverterTypePkOrF.read(from: &buf)
        )
        
        case 2: return .schnorrSignature(key: try FfiConverterTypePkOrF.read(from: &buf)
        )
        
        case 3: return .sha256Preimage(hash: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .hash256Preimage(hash: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .ripemd160Preimage(hash: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .hash160Preimage(hash: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .absoluteTimelock(value: try FfiConverterTypeLockTime.read(from: &buf)
        )
        
        case 8: return .relativeTimelock(value: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 9: return .multisig(keys: try FfiConverterSequenceTypePkOrF.read(from: &buf), threshold: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 10: return .thresh(items: try FfiConverterSequenceTypePolicy.read(from: &buf), threshold: try FfiConverterUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SatisfiableItem, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .ecdsaSignature(key):
            writeInt(&buf, Int32(1))
            FfiConverterTypePkOrF.write(key, into: &buf)
            
        
        case let .schnorrSignature(key):
            writeInt(&buf, Int32(2))
            FfiConverterTypePkOrF.write(key, into: &buf)
            
        
        case let .sha256Preimage(hash):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(hash, into: &buf)
            
        
        case let .hash256Preimage(hash):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(hash, into: &buf)
            
        
        case let .ripemd160Preimage(hash):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(hash, into: &buf)
            
        
        case let .hash160Preimage(hash):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(hash, into: &buf)
            
        
        case let .absoluteTimelock(value):
            writeInt(&buf, Int32(7))
            FfiConverterTypeLockTime.write(value, into: &buf)
            
        
        case let .relativeTimelock(value):
            writeInt(&buf, Int32(8))
            FfiConverterUInt32.write(value, into: &buf)
            
        
        case let .multisig(keys,threshold):
            writeInt(&buf, Int32(9))
            FfiConverterSequenceTypePkOrF.write(keys, into: &buf)
            FfiConverterUInt64.write(threshold, into: &buf)
            
        
        case let .thresh(items,threshold):
            writeInt(&buf, Int32(10))
            FfiConverterSequenceTypePolicy.write(items, into: &buf)
            FfiConverterUInt64.write(threshold, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSatisfiableItem_lift(_ buf: RustBuffer) throws -> SatisfiableItem {
    return try FfiConverterTypeSatisfiableItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSatisfiableItem_lower(_ value: SatisfiableItem) -> RustBuffer {
    return FfiConverterTypeSatisfiableItem.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Sync a wallet from the last known block hash, recover a wallet from a specified height,
 * or perform an expedited block header download for a new wallet.
 */

public enum ScanType {
    
    /**
     * Perform an expedited header and filter download for a new wallet.
     * If this option is not set, and the wallet has no history, the
     * entire chain will be scanned for script inclusions.
     */
    case new
    /**
     * Sync an existing wallet from the last stored chain checkpoint.
     */
    case sync
    /**
     * Recover an existing wallet by scanning from the specified height.
     */
    case recovery(fromHeight: UInt32
    )
}


#if compiler(>=6)
extension ScanType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeScanType: FfiConverterRustBuffer {
    typealias SwiftType = ScanType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScanType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .new
        
        case 2: return .sync
        
        case 3: return .recovery(fromHeight: try FfiConverterUInt32.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ScanType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .new:
            writeInt(&buf, Int32(1))
        
        
        case .sync:
            writeInt(&buf, Int32(2))
        
        
        case let .recovery(fromHeight):
            writeInt(&buf, Int32(3))
            FfiConverterUInt32.write(fromHeight, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeScanType_lift(_ buf: RustBuffer) throws -> ScanType {
    return try FfiConverterTypeScanType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeScanType_lower(_ value: ScanType) -> RustBuffer {
    return FfiConverterTypeScanType.lower(value)
}


extension ScanType: Equatable, Hashable {}




public enum SignerError: Swift.Error {

    
    
    case MissingKey
    case InvalidKey
    case UserCanceled
    case InputIndexOutOfRange
    case MissingNonWitnessUtxo
    case InvalidNonWitnessUtxo
    case MissingWitnessUtxo
    case MissingWitnessScript
    case MissingHdKeypath
    case NonStandardSighash
    case InvalidSighash
    case SighashP2wpkh(errorMessage: String
    )
    case SighashTaproot(errorMessage: String
    )
    case TxInputsIndexError(errorMessage: String
    )
    case MiniscriptPsbt(errorMessage: String
    )
    case External(errorMessage: String
    )
    case Psbt(errorMessage: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignerError: FfiConverterRustBuffer {
    typealias SwiftType = SignerError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignerError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .MissingKey
        case 2: return .InvalidKey
        case 3: return .UserCanceled
        case 4: return .InputIndexOutOfRange
        case 5: return .MissingNonWitnessUtxo
        case 6: return .InvalidNonWitnessUtxo
        case 7: return .MissingWitnessUtxo
        case 8: return .MissingWitnessScript
        case 9: return .MissingHdKeypath
        case 10: return .NonStandardSighash
        case 11: return .InvalidSighash
        case 12: return .SighashP2wpkh(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 13: return .SighashTaproot(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 14: return .TxInputsIndexError(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 15: return .MiniscriptPsbt(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 16: return .External(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 17: return .Psbt(
            errorMessage: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SignerError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .MissingKey:
            writeInt(&buf, Int32(1))
        
        
        case .InvalidKey:
            writeInt(&buf, Int32(2))
        
        
        case .UserCanceled:
            writeInt(&buf, Int32(3))
        
        
        case .InputIndexOutOfRange:
            writeInt(&buf, Int32(4))
        
        
        case .MissingNonWitnessUtxo:
            writeInt(&buf, Int32(5))
        
        
        case .InvalidNonWitnessUtxo:
            writeInt(&buf, Int32(6))
        
        
        case .MissingWitnessUtxo:
            writeInt(&buf, Int32(7))
        
        
        case .MissingWitnessScript:
            writeInt(&buf, Int32(8))
        
        
        case .MissingHdKeypath:
            writeInt(&buf, Int32(9))
        
        
        case .NonStandardSighash:
            writeInt(&buf, Int32(10))
        
        
        case .InvalidSighash:
            writeInt(&buf, Int32(11))
        
        
        case let .SighashP2wpkh(errorMessage):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .SighashTaproot(errorMessage):
            writeInt(&buf, Int32(13))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .TxInputsIndexError(errorMessage):
            writeInt(&buf, Int32(14))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .MiniscriptPsbt(errorMessage):
            writeInt(&buf, Int32(15))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .External(errorMessage):
            writeInt(&buf, Int32(16))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Psbt(errorMessage):
            writeInt(&buf, Int32(17))
            FfiConverterString.write(errorMessage, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignerError_lift(_ buf: RustBuffer) throws -> SignerError {
    return try FfiConverterTypeSignerError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignerError_lower(_ value: SignerError) -> RustBuffer {
    return FfiConverterTypeSignerError.lower(value)
}


extension SignerError: Equatable, Hashable {}



extension SignerError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum SqliteError: Swift.Error {

    
    
    case Sqlite(rusqliteError: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSqliteError: FfiConverterRustBuffer {
    typealias SwiftType = SqliteError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SqliteError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Sqlite(
            rusqliteError: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SqliteError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Sqlite(rusqliteError):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(rusqliteError, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSqliteError_lift(_ buf: RustBuffer) throws -> SqliteError {
    return try FfiConverterTypeSqliteError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSqliteError_lower(_ value: SqliteError) -> RustBuffer {
    return FfiConverterTypeSqliteError.lower(value)
}


extension SqliteError: Equatable, Hashable {}



extension SqliteError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum TransactionError: Swift.Error {

    
    
    case Io
    case OversizedVectorAllocation
    case InvalidChecksum(expected: String, actual: String
    )
    case NonMinimalVarInt
    case ParseFailed
    case UnsupportedSegwitFlag(flag: UInt8
    )
    case OtherTransactionErr
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransactionError: FfiConverterRustBuffer {
    typealias SwiftType = TransactionError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Io
        case 2: return .OversizedVectorAllocation
        case 3: return .InvalidChecksum(
            expected: try FfiConverterString.read(from: &buf), 
            actual: try FfiConverterString.read(from: &buf)
            )
        case 4: return .NonMinimalVarInt
        case 5: return .ParseFailed
        case 6: return .UnsupportedSegwitFlag(
            flag: try FfiConverterUInt8.read(from: &buf)
            )
        case 7: return .OtherTransactionErr

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransactionError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .Io:
            writeInt(&buf, Int32(1))
        
        
        case .OversizedVectorAllocation:
            writeInt(&buf, Int32(2))
        
        
        case let .InvalidChecksum(expected,actual):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(expected, into: &buf)
            FfiConverterString.write(actual, into: &buf)
            
        
        case .NonMinimalVarInt:
            writeInt(&buf, Int32(4))
        
        
        case .ParseFailed:
            writeInt(&buf, Int32(5))
        
        
        case let .UnsupportedSegwitFlag(flag):
            writeInt(&buf, Int32(6))
            FfiConverterUInt8.write(flag, into: &buf)
            
        
        case .OtherTransactionErr:
            writeInt(&buf, Int32(7))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionError_lift(_ buf: RustBuffer) throws -> TransactionError {
    return try FfiConverterTypeTransactionError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionError_lower(_ value: TransactionError) -> RustBuffer {
    return FfiConverterTypeTransactionError.lower(value)
}


extension TransactionError: Equatable, Hashable {}



extension TransactionError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum TxidParseError: Swift.Error {

    
    
    case InvalidTxid(txid: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTxidParseError: FfiConverterRustBuffer {
    typealias SwiftType = TxidParseError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxidParseError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidTxid(
            txid: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TxidParseError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidTxid(txid):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(txid, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxidParseError_lift(_ buf: RustBuffer) throws -> TxidParseError {
    return try FfiConverterTypeTxidParseError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxidParseError_lower(_ value: TxidParseError) -> RustBuffer {
    return FfiConverterTypeTxidParseError.lower(value)
}


extension TxidParseError: Equatable, Hashable {}



extension TxidParseError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Warnings a node may issue while running.
 */

public enum Warning {
    
    /**
     * The node is looking for connections to peers.
     */
    case needConnections
    /**
     * A connection to a peer timed out.
     */
    case peerTimedOut
    /**
     * The node was unable to connect to a peer in the database.
     */
    case couldNotConnect
    /**
     * A connection was maintained, but the peer does not signal for compact block filers.
     */
    case noCompactFilters
    /**
     * The node has been waiting for new inv and will find new peers to avoid block withholding.
     */
    case potentialStaleTip
    /**
     * A peer sent us a peer-to-peer message the node did not request.
     */
    case unsolicitedMessage
    /**
     * The provided starting height is deeper than the database history.
     * This should not occur under normal use.
     */
    case invalidStartHeight
    /**
     * The headers in the database do not link together.
     * Recoverable by deleting the database.
     */
    case corruptedHeaders
    /**
     * A transaction got rejected, likely for being an insufficient fee or non-standard transaction.
     */
    case transactionRejected(txid: String, reason: String?
    )
    /**
     * A database failed to persist some data and may retry again
     */
    case failedPersistence(warning: String
    )
    /**
     * The peer sent us a potential fork.
     */
    case evaluatingFork
    /**
     * The peer database has no values.
     */
    case emptyPeerDatabase
    /**
     * An unexpected error occured processing a peer-to-peer message.
     */
    case unexpectedSyncError(warning: String
    )
    /**
     * The node failed to respond to a message sent from the client.
     */
    case requestFailed
}


#if compiler(>=6)
extension Warning: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWarning: FfiConverterRustBuffer {
    typealias SwiftType = Warning

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Warning {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .needConnections
        
        case 2: return .peerTimedOut
        
        case 3: return .couldNotConnect
        
        case 4: return .noCompactFilters
        
        case 5: return .potentialStaleTip
        
        case 6: return .unsolicitedMessage
        
        case 7: return .invalidStartHeight
        
        case 8: return .corruptedHeaders
        
        case 9: return .transactionRejected(txid: try FfiConverterString.read(from: &buf), reason: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 10: return .failedPersistence(warning: try FfiConverterString.read(from: &buf)
        )
        
        case 11: return .evaluatingFork
        
        case 12: return .emptyPeerDatabase
        
        case 13: return .unexpectedSyncError(warning: try FfiConverterString.read(from: &buf)
        )
        
        case 14: return .requestFailed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Warning, into buf: inout [UInt8]) {
        switch value {
        
        
        case .needConnections:
            writeInt(&buf, Int32(1))
        
        
        case .peerTimedOut:
            writeInt(&buf, Int32(2))
        
        
        case .couldNotConnect:
            writeInt(&buf, Int32(3))
        
        
        case .noCompactFilters:
            writeInt(&buf, Int32(4))
        
        
        case .potentialStaleTip:
            writeInt(&buf, Int32(5))
        
        
        case .unsolicitedMessage:
            writeInt(&buf, Int32(6))
        
        
        case .invalidStartHeight:
            writeInt(&buf, Int32(7))
        
        
        case .corruptedHeaders:
            writeInt(&buf, Int32(8))
        
        
        case let .transactionRejected(txid,reason):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(txid, into: &buf)
            FfiConverterOptionString.write(reason, into: &buf)
            
        
        case let .failedPersistence(warning):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(warning, into: &buf)
            
        
        case .evaluatingFork:
            writeInt(&buf, Int32(11))
        
        
        case .emptyPeerDatabase:
            writeInt(&buf, Int32(12))
        
        
        case let .unexpectedSyncError(warning):
            writeInt(&buf, Int32(13))
            FfiConverterString.write(warning, into: &buf)
            
        
        case .requestFailed:
            writeInt(&buf, Int32(14))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWarning_lift(_ buf: RustBuffer) throws -> Warning {
    return try FfiConverterTypeWarning.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWarning_lower(_ value: Warning) -> RustBuffer {
    return FfiConverterTypeWarning.lower(value)
}


extension Warning: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WordCount {
    
    case words12
    case words15
    case words18
    case words21
    case words24
}


#if compiler(>=6)
extension WordCount: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWordCount: FfiConverterRustBuffer {
    typealias SwiftType = WordCount

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WordCount {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .words12
        
        case 2: return .words15
        
        case 3: return .words18
        
        case 4: return .words21
        
        case 5: return .words24
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WordCount, into buf: inout [UInt8]) {
        switch value {
        
        
        case .words12:
            writeInt(&buf, Int32(1))
        
        
        case .words15:
            writeInt(&buf, Int32(2))
        
        
        case .words18:
            writeInt(&buf, Int32(3))
        
        
        case .words21:
            writeInt(&buf, Int32(4))
        
        
        case .words24:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWordCount_lift(_ buf: RustBuffer) throws -> WordCount {
    return try FfiConverterTypeWordCount.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWordCount_lower(_ value: WordCount) -> RustBuffer {
    return FfiConverterTypeWordCount.lower(value)
}


extension WordCount: Equatable, Hashable {}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt16: FfiConverterRustBuffer {
    typealias SwiftType = UInt16?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt16.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt16.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypePolicy: FfiConverterRustBuffer {
    typealias SwiftType = Policy?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePolicy.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePolicy.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeTransaction: FfiConverterRustBuffer {
    typealias SwiftType = Transaction?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTransaction.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTransaction.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeUpdate: FfiConverterRustBuffer {
    typealias SwiftType = Update?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUpdate.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUpdate.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeCanonicalTx: FfiConverterRustBuffer {
    typealias SwiftType = CanonicalTx?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCanonicalTx.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCanonicalTx.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeKeychainAndIndex: FfiConverterRustBuffer {
    typealias SwiftType = KeychainAndIndex?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeKeychainAndIndex.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeKeychainAndIndex.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeLocalOutput: FfiConverterRustBuffer {
    typealias SwiftType = LocalOutput?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLocalOutput.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLocalOutput.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSignOptions: FfiConverterRustBuffer {
    typealias SwiftType = SignOptions?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSignOptions.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSignOptions.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeTx: FfiConverterRustBuffer {
    typealias SwiftType = Tx?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTx.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTx.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeLockTime: FfiConverterRustBuffer {
    typealias SwiftType = LockTime?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLockTime.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLockTime.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypePsbtFinalizeError: FfiConverterRustBuffer {
    typealias SwiftType = [PsbtFinalizeError]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypePsbtFinalizeError.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypePsbtFinalizeError.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]

    public static func write(_ value: [UInt8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt8.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceUInt32: FfiConverterRustBuffer {
    typealias SwiftType = [UInt32]

    public static func write(_ value: [UInt32], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt32.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt32] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt32]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt32.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceUInt64: FfiConverterRustBuffer {
    typealias SwiftType = [UInt64]

    public static func write(_ value: [UInt64], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt64.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt64] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt64]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt64.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeDescriptor: FfiConverterRustBuffer {
    typealias SwiftType = [Descriptor]

    public static func write(_ value: [Descriptor], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDescriptor.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Descriptor] {
        let len: Int32 = try readInt(&buf)
        var seq = [Descriptor]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeDescriptor.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePolicy: FfiConverterRustBuffer {
    typealias SwiftType = [Policy]

    public static func write(_ value: [Policy], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePolicy.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Policy] {
        let len: Int32 = try readInt(&buf)
        var seq = [Policy]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePolicy.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAddressInfo: FfiConverterRustBuffer {
    typealias SwiftType = [AddressInfo]

    public static func write(_ value: [AddressInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAddressInfo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AddressInfo] {
        let len: Int32 = try readInt(&buf)
        var seq = [AddressInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAddressInfo.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeCanonicalTx: FfiConverterRustBuffer {
    typealias SwiftType = [CanonicalTx]

    public static func write(_ value: [CanonicalTx], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCanonicalTx.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [CanonicalTx] {
        let len: Int32 = try readInt(&buf)
        var seq = [CanonicalTx]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCanonicalTx.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeCondition: FfiConverterRustBuffer {
    typealias SwiftType = [Condition]

    public static func write(_ value: [Condition], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCondition.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Condition] {
        let len: Int32 = try readInt(&buf)
        var seq = [Condition]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCondition.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeLocalOutput: FfiConverterRustBuffer {
    typealias SwiftType = [LocalOutput]

    public static func write(_ value: [LocalOutput], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLocalOutput.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LocalOutput] {
        let len: Int32 = try readInt(&buf)
        var seq = [LocalOutput]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLocalOutput.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeOutPoint: FfiConverterRustBuffer {
    typealias SwiftType = [OutPoint]

    public static func write(_ value: [OutPoint], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeOutPoint.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [OutPoint] {
        let len: Int32 = try readInt(&buf)
        var seq = [OutPoint]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeOutPoint.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePeer: FfiConverterRustBuffer {
    typealias SwiftType = [Peer]

    public static func write(_ value: [Peer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePeer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Peer] {
        let len: Int32 = try readInt(&buf)
        var seq = [Peer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePeer.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeScriptAmount: FfiConverterRustBuffer {
    typealias SwiftType = [ScriptAmount]

    public static func write(_ value: [ScriptAmount], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeScriptAmount.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ScriptAmount] {
        let len: Int32 = try readInt(&buf)
        var seq = [ScriptAmount]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeScriptAmount.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTxIn: FfiConverterRustBuffer {
    typealias SwiftType = [TxIn]

    public static func write(_ value: [TxIn], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTxIn.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TxIn] {
        let len: Int32 = try readInt(&buf)
        var seq = [TxIn]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTxIn.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTxOut: FfiConverterRustBuffer {
    typealias SwiftType = [TxOut]

    public static func write(_ value: [TxOut], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTxOut.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TxOut] {
        let len: Int32 = try readInt(&buf)
        var seq = [TxOut]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTxOut.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeUnconfirmedTx: FfiConverterRustBuffer {
    typealias SwiftType = [UnconfirmedTx]

    public static func write(_ value: [UnconfirmedTx], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUnconfirmedTx.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UnconfirmedTx] {
        let len: Int32 = try readInt(&buf)
        var seq = [UnconfirmedTx]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUnconfirmedTx.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePkOrF: FfiConverterRustBuffer {
    typealias SwiftType = [PkOrF]

    public static func write(_ value: [PkOrF], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePkOrF.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PkOrF] {
        let len: Int32 = try readInt(&buf)
        var seq = [PkOrF]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePkOrF.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePsbtFinalizeError: FfiConverterRustBuffer {
    typealias SwiftType = [PsbtFinalizeError]

    public static func write(_ value: [PsbtFinalizeError], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePsbtFinalizeError.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PsbtFinalizeError] {
        let len: Int32 = try readInt(&buf)
        var seq = [PsbtFinalizeError]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePsbtFinalizeError.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [[UInt8]]

    public static func write(_ value: [[UInt8]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterSequenceUInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[UInt8]] {
        let len: Int32 = try readInt(&buf)
        var seq = [[UInt8]]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterSequenceUInt8.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryUInt16Double: FfiConverterRustBuffer {
    public static func write(_ value: [UInt16: Double], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterUInt16.write(key, into: &buf)
            FfiConverterDouble.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt16: Double] {
        let len: Int32 = try readInt(&buf)
        var dict = [UInt16: Double]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterUInt16.read(from: &buf)
            let value = try FfiConverterDouble.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryUInt32SequenceTypeCondition: FfiConverterRustBuffer {
    public static func write(_ value: [UInt32: [Condition]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterUInt32.write(key, into: &buf)
            FfiConverterSequenceTypeCondition.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt32: [Condition]] {
        let len: Int32 = try readInt(&buf)
        var dict = [UInt32: [Condition]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterUInt32.read(from: &buf)
            let value = try FfiConverterSequenceTypeCondition.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringSequenceUInt64: FfiConverterRustBuffer {
    public static func write(_ value: [String: [UInt64]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceUInt64.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [UInt64]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [UInt64]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceUInt64.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionarySequenceUInt32SequenceTypeCondition: FfiConverterRustBuffer {
    public static func write(_ value: [[UInt32]: [Condition]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterSequenceUInt32.write(key, into: &buf)
            FfiConverterSequenceTypeCondition.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[UInt32]: [Condition]] {
        let len: Int32 = try readInt(&buf)
        var dict = [[UInt32]: [Condition]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterSequenceUInt32.read(from: &buf)
            let value = try FfiConverterSequenceTypeCondition.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}
private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call the ensure init function since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureBdkffiInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 29
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_bdkffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_bdkffi_checksum_method_address_is_valid_for_network() != 10350) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_address_script_pubkey() != 10722) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_address_to_address_data() != 61625) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_address_to_qr_uri() != 48141) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_amount_to_btc() != 44112) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_amount_to_sat() != 2062) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_bumpfeetxbuilder_allow_dust() != 64834) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_bumpfeetxbuilder_current_height() != 25489) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_bumpfeetxbuilder_finish() != 36534) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_bumpfeetxbuilder_nlocktime() != 13924) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_bumpfeetxbuilder_set_exact_sequence() != 13533) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_bumpfeetxbuilder_version() != 18790) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfbuilder_build() != 49355) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfbuilder_connections() != 8040) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfbuilder_data_dir() != 31903) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfbuilder_dns_resolver() != 20074) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfbuilder_log_level() != 53476) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfbuilder_peers() != 54701) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfbuilder_scan_type() != 58442) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfclient_add_revealed_scripts() != 60116) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfclient_broadcast() != 60500) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfclient_is_running() != 60374) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfclient_min_broadcast_feerate() != 31908) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfclient_next_log() != 19452) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfclient_next_warning() != 38083) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfclient_shutdown() != 34854) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfclient_update() != 752) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfnode_run() != 61383) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptor_is_multipath() != 3912) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptor_to_single_descriptors() != 33905) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptor_to_string_with_secret() != 18986) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptorpublickey_as_string() != 37256) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptorpublickey_derive() != 42652) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptorpublickey_extend() != 46128) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptorpublickey_is_multipath() != 45386) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptorpublickey_master_fingerprint() != 19753) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptorsecretkey_as_public() != 56954) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptorsecretkey_as_string() != 28335) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptorsecretkey_derive() != 61335) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptorsecretkey_extend() != 19969) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptorsecretkey_secret_bytes() != 40876) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_electrumclient_block_headers_subscribe() != 45147) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_electrumclient_estimate_fee() != 17604) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_electrumclient_full_scan() != 45625) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_electrumclient_ping() != 28406) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_electrumclient_server_features() != 18744) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_electrumclient_sync() != 62150) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_electrumclient_transaction_broadcast() != 36923) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_esploraclient_broadcast() != 21200) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_esploraclient_full_scan() != 43201) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_esploraclient_get_block_hash() != 18600) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_esploraclient_get_fee_estimates() != 64331) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_esploraclient_get_height() != 1218) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_esploraclient_get_tx() != 59770) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_esploraclient_get_tx_info() != 1114) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_esploraclient_get_tx_status() != 25440) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_esploraclient_sync() != 11965) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_feerate_to_sat_per_kwu() != 54539) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_feerate_to_sat_per_vb_ceil() != 34953) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_feerate_to_sat_per_vb_floor() != 29836) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_fullscanrequestbuilder_build() != 56245) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_fullscanrequestbuilder_inspect_spks_for_all_keychains() != 6853) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_fullscanscriptinspector_inspect() != 52426) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_policy_as_string() != 41785) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_policy_contribution() != 25625) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_policy_id() != 33085) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_policy_item() != 24039) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_policy_requires_path() != 40639) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_policy_satisfaction() != 28647) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_psbt_combine() != 42218) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_psbt_extract_tx() != 60519) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_psbt_fee() != 48877) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_psbt_finalize() != 20182) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_psbt_json_serialize() != 9611) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_psbt_serialize() != 33309) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_script_to_bytes() != 31368) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_syncrequestbuilder_build() != 38954) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_syncrequestbuilder_inspect_spks() != 33029) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_syncscriptinspector_inspect() != 6883) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_compute_txid() != 46504) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_input() != 5374) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_is_coinbase() != 14454) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_is_explicitly_rbf() != 32682) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_is_lock_time_enabled() != 48885) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_lock_time() != 49321) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_output() != 30237) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_serialize() != 62862) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_total_size() != 12759) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_version() != 15271) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_vsize() != 3804) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_weight() != 21879) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_add_data() != 3485) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_add_global_xpubs() != 60600) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_add_recipient() != 38261) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_add_unspendable() != 42556) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_add_utxo() != 55155) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_add_utxos() != 36635) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_allow_dust() != 36330) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_change_policy() != 33210) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_current_height() != 25990) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_do_not_spend_change() != 279) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_drain_to() != 19958) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_drain_wallet() != 21886) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_fee_absolute() != 6920) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_fee_rate() != 42880) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_finish() != 43504) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_manually_selected_only() != 17632) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_nlocktime() != 61968) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_only_spend_change() != 2625) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_policy_path() != 36425) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_set_exact_sequence() != 11338) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_set_recipients() != 8653) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_unspendable() != 59793) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_version() != 12910) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_apply_unconfirmed_txs() != 10353) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_apply_update() != 65428) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_balance() != 32173) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_calculate_fee() != 14264) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_calculate_fee_rate() != 61555) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_cancel_tx() != 27219) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_derivation_index() != 63084) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_derivation_of_spk() != 48832) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_descriptor_checksum() != 60436) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_finalize_psbt() != 52988) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_get_tx() != 59450) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_get_utxo() != 48342) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_is_mine() != 56329) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_list_output() != 27359) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_list_unspent() != 25643) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_list_unused_addresses() != 1695) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_mark_used() != 51163) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_network() != 32197) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_next_derivation_index() != 47127) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_next_unused_address() != 18644) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_peek_address() != 47647) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_persist() != 14909) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_policies() != 23929) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_reveal_addresses_to() != 10653) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_reveal_next_address() != 54031) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_sent_and_received() != 15077) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_sign() != 41599) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_start_full_scan() != 3023) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_start_sync_with_revealed_spks() != 41977) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_transactions() != 37950) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_address_from_script() != 63028) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_address_new() != 10014) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_amount_from_btc() != 43617) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_amount_from_sat() != 18287) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_bumpfeetxbuilder_new() != 39025) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_cbfbuilder_new() != 33361) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_connection_new() != 57214) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_connection_new_in_memory() != 62138) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_derivationpath_new() != 18379) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptor_new() != 19415) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptor_new_bip44() != 640) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptor_new_bip44_public() != 17163) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptor_new_bip49() != 50215) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptor_new_bip49_public() != 16648) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptor_new_bip84() != 56174) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptor_new_bip84_public() != 27707) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptor_new_bip86() != 52779) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptor_new_bip86_public() != 60138) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptorpublickey_from_string() != 13510) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptorsecretkey_from_string() != 35137) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptorsecretkey_new() != 516) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_electrumclient_new() != 22342) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_esploraclient_new() != 10410) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_feerate_from_sat_per_kwu() != 2730) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_feerate_from_sat_per_vb() != 6982) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_ipaddress_from_ipv4() != 14635) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_ipaddress_from_ipv6() != 31033) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_mnemonic_from_entropy() != 30681) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_mnemonic_from_string() != 22177) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_mnemonic_new() != 62260) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_psbt_new() != 34802) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_script_new() != 54110) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_transaction_new() != 52808) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_txbuilder_new() != 20554) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_wallet_load() != 49712) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_wallet_new() != 30052) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitFullScanScriptInspector()
    uniffiCallbackInitSyncScriptInspector()
    return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
public func uniffiEnsureBdkffiInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all