// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(bdkFFI)
import bdkFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_bdkffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_bdkffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterFloat: FfiConverterPrimitive {
    typealias FfiType = Float
    typealias SwiftType = Float

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Float {
        return try lift(readFloat(&buf))
    }

    public static func write(_ value: Float, into buf: inout [UInt8]) {
        writeFloat(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}




public protocol AddressProtocol : AnyObject {
    
    func asString()  -> String
    
    func isValidForNetwork(network: Network)  -> Bool
    
    func network()  -> Network
    
    func payload()  -> Payload
    
    func scriptPubkey()  -> Script
    
    func toQrUri()  -> String
    
}

open class Address:
    AddressProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_address(self.pointer, $0) }
    }
public convenience init(address: String, network: Network)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeBdkError.lift) {
    uniffi_bdkffi_fn_constructor_address_new(
        FfiConverterString.lower(address),
        FfiConverterTypeNetwork.lower(network),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_address(pointer, $0) }
    }

    
public static func fromScript(script: Script, network: Network)throws  -> Address {
    return try  FfiConverterTypeAddress.lift(try rustCallWithError(FfiConverterTypeBdkError.lift) {
    uniffi_bdkffi_fn_constructor_address_from_script(
        FfiConverterTypeScript.lower(script),
        FfiConverterTypeNetwork.lower(network),$0
    )
})
}
    

    
open func asString() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_address_as_string(self.uniffiClonePointer(),$0
    )
})
}
    
open func isValidForNetwork(network: Network) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_address_is_valid_for_network(self.uniffiClonePointer(),
        FfiConverterTypeNetwork.lower(network),$0
    )
})
}
    
open func network() -> Network {
    return try!  FfiConverterTypeNetwork.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_address_network(self.uniffiClonePointer(),$0
    )
})
}
    
open func payload() -> Payload {
    return try!  FfiConverterTypePayload.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_address_payload(self.uniffiClonePointer(),$0
    )
})
}
    
open func scriptPubkey() -> Script {
    return try!  FfiConverterTypeScript.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_address_script_pubkey(self.uniffiClonePointer(),$0
    )
})
}
    
open func toQrUri() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_address_to_qr_uri(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeAddress: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Address

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Address {
        return Address(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Address) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Address {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Address, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeAddress_lift(_ pointer: UnsafeMutableRawPointer) throws -> Address {
    return try FfiConverterTypeAddress.lift(pointer)
}

public func FfiConverterTypeAddress_lower(_ value: Address) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAddress.lower(value)
}




public protocol BlockchainProtocol : AnyObject {
    
    func broadcast(transaction: Transaction) throws 
    
    func estimateFee(target: UInt64) throws  -> FeeRate
    
    func getBlockHash(height: UInt32) throws  -> String
    
    func getHeight() throws  -> UInt32
    
    func getTx(txid: String) throws  -> Transaction?
    
}

open class Blockchain:
    BlockchainProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_blockchain(self.pointer, $0) }
    }
public convenience init(config: BlockchainConfig)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeBdkError.lift) {
    uniffi_bdkffi_fn_constructor_blockchain_new(
        FfiConverterTypeBlockchainConfig.lower(config),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_blockchain(pointer, $0) }
    }

    

    
open func broadcast(transaction: Transaction)throws  {try rustCallWithError(FfiConverterTypeBdkError.lift) {
    uniffi_bdkffi_fn_method_blockchain_broadcast(self.uniffiClonePointer(),
        FfiConverterTypeTransaction.lower(transaction),$0
    )
}
}
    
open func estimateFee(target: UInt64)throws  -> FeeRate {
    return try  FfiConverterTypeFeeRate.lift(try rustCallWithError(FfiConverterTypeBdkError.lift) {
    uniffi_bdkffi_fn_method_blockchain_estimate_fee(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(target),$0
    )
})
}
    
open func getBlockHash(height: UInt32)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeBdkError.lift) {
    uniffi_bdkffi_fn_method_blockchain_get_block_hash(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(height),$0
    )
})
}
    
open func getHeight()throws  -> UInt32 {
    return try  FfiConverterUInt32.lift(try rustCallWithError(FfiConverterTypeBdkError.lift) {
    uniffi_bdkffi_fn_method_blockchain_get_height(self.uniffiClonePointer(),$0
    )
})
}
    
open func getTx(txid: String)throws  -> Transaction? {
    return try  FfiConverterOptionTypeTransaction.lift(try rustCallWithError(FfiConverterTypeBdkError.lift) {
    uniffi_bdkffi_fn_method_blockchain_get_tx(self.uniffiClonePointer(),
        FfiConverterString.lower(txid),$0
    )
})
}
    

}

public struct FfiConverterTypeBlockchain: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Blockchain

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Blockchain {
        return Blockchain(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Blockchain) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Blockchain {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Blockchain, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeBlockchain_lift(_ pointer: UnsafeMutableRawPointer) throws -> Blockchain {
    return try FfiConverterTypeBlockchain.lift(pointer)
}

public func FfiConverterTypeBlockchain_lower(_ value: Blockchain) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBlockchain.lower(value)
}




public protocol BumpFeeTxBuilderProtocol : AnyObject {
    
    func allowShrinking(scriptPubkey: Script)  -> BumpFeeTxBuilder
    
    func enableRbf()  -> BumpFeeTxBuilder
    
    func enableRbfWithSequence(nsequence: UInt32)  -> BumpFeeTxBuilder
    
    func finish(wallet: Wallet) throws  -> PartiallySignedTransaction
    
}

open class BumpFeeTxBuilder:
    BumpFeeTxBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_bumpfeetxbuilder(self.pointer, $0) }
    }
public convenience init(txid: String, newFeeRate: Float) {
    let pointer =
        try! rustCall() {
    uniffi_bdkffi_fn_constructor_bumpfeetxbuilder_new(
        FfiConverterString.lower(txid),
        FfiConverterFloat.lower(newFeeRate),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_bumpfeetxbuilder(pointer, $0) }
    }

    

    
open func allowShrinking(scriptPubkey: Script) -> BumpFeeTxBuilder {
    return try!  FfiConverterTypeBumpFeeTxBuilder.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_bumpfeetxbuilder_allow_shrinking(self.uniffiClonePointer(),
        FfiConverterTypeScript.lower(scriptPubkey),$0
    )
})
}
    
open func enableRbf() -> BumpFeeTxBuilder {
    return try!  FfiConverterTypeBumpFeeTxBuilder.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_bumpfeetxbuilder_enable_rbf(self.uniffiClonePointer(),$0
    )
})
}
    
open func enableRbfWithSequence(nsequence: UInt32) -> BumpFeeTxBuilder {
    return try!  FfiConverterTypeBumpFeeTxBuilder.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_bumpfeetxbuilder_enable_rbf_with_sequence(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(nsequence),$0
    )
})
}
    
open func finish(wallet: Wallet)throws  -> PartiallySignedTransaction {
    return try  FfiConverterTypePartiallySignedTransaction.lift(try rustCallWithError(FfiConverterTypeBdkError.lift) {
    uniffi_bdkffi_fn_method_bumpfeetxbuilder_finish(self.uniffiClonePointer(),
        FfiConverterTypeWallet.lower(wallet),$0
    )
})
}
    

}

public struct FfiConverterTypeBumpFeeTxBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BumpFeeTxBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BumpFeeTxBuilder {
        return BumpFeeTxBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BumpFeeTxBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BumpFeeTxBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BumpFeeTxBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeBumpFeeTxBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> BumpFeeTxBuilder {
    return try FfiConverterTypeBumpFeeTxBuilder.lift(pointer)
}

public func FfiConverterTypeBumpFeeTxBuilder_lower(_ value: BumpFeeTxBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBumpFeeTxBuilder.lower(value)
}




public protocol DerivationPathProtocol : AnyObject {
    
}

open class DerivationPath:
    DerivationPathProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_derivationpath(self.pointer, $0) }
    }
public convenience init(path: String)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeBdkError.lift) {
    uniffi_bdkffi_fn_constructor_derivationpath_new(
        FfiConverterString.lower(path),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_derivationpath(pointer, $0) }
    }

    

    

}

public struct FfiConverterTypeDerivationPath: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = DerivationPath

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> DerivationPath {
        return DerivationPath(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: DerivationPath) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DerivationPath {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: DerivationPath, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeDerivationPath_lift(_ pointer: UnsafeMutableRawPointer) throws -> DerivationPath {
    return try FfiConverterTypeDerivationPath.lift(pointer)
}

public func FfiConverterTypeDerivationPath_lower(_ value: DerivationPath) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDerivationPath.lower(value)
}




public protocol DescriptorProtocol : AnyObject {
    
    func asString()  -> String
    
    func asStringPrivate()  -> String
    
}

open class Descriptor:
    DescriptorProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_descriptor(self.pointer, $0) }
    }
public convenience init(descriptor: String, network: Network)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeBdkError.lift) {
    uniffi_bdkffi_fn_constructor_descriptor_new(
        FfiConverterString.lower(descriptor),
        FfiConverterTypeNetwork.lower(network),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_descriptor(pointer, $0) }
    }

    
public static func newBip44(secretKey: DescriptorSecretKey, keychain: KeychainKind, network: Network) -> Descriptor {
    return try!  FfiConverterTypeDescriptor.lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_descriptor_new_bip44(
        FfiConverterTypeDescriptorSecretKey.lower(secretKey),
        FfiConverterTypeKeychainKind.lower(keychain),
        FfiConverterTypeNetwork.lower(network),$0
    )
})
}
    
public static func newBip44Public(publicKey: DescriptorPublicKey, fingerprint: String, keychain: KeychainKind, network: Network) -> Descriptor {
    return try!  FfiConverterTypeDescriptor.lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_descriptor_new_bip44_public(
        FfiConverterTypeDescriptorPublicKey.lower(publicKey),
        FfiConverterString.lower(fingerprint),
        FfiConverterTypeKeychainKind.lower(keychain),
        FfiConverterTypeNetwork.lower(network),$0
    )
})
}
    
public static func newBip49(secretKey: DescriptorSecretKey, keychain: KeychainKind, network: Network) -> Descriptor {
    return try!  FfiConverterTypeDescriptor.lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_descriptor_new_bip49(
        FfiConverterTypeDescriptorSecretKey.lower(secretKey),
        FfiConverterTypeKeychainKind.lower(keychain),
        FfiConverterTypeNetwork.lower(network),$0
    )
})
}
    
public static func newBip49Public(publicKey: DescriptorPublicKey, fingerprint: String, keychain: KeychainKind, network: Network) -> Descriptor {
    return try!  FfiConverterTypeDescriptor.lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_descriptor_new_bip49_public(
        FfiConverterTypeDescriptorPublicKey.lower(publicKey),
        FfiConverterString.lower(fingerprint),
        FfiConverterTypeKeychainKind.lower(keychain),
        FfiConverterTypeNetwork.lower(network),$0
    )
})
}
    
public static func newBip84(secretKey: DescriptorSecretKey, keychain: KeychainKind, network: Network) -> Descriptor {
    return try!  FfiConverterTypeDescriptor.lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_descriptor_new_bip84(
        FfiConverterTypeDescriptorSecretKey.lower(secretKey),
        FfiConverterTypeKeychainKind.lower(keychain),
        FfiConverterTypeNetwork.lower(network),$0
    )
})
}
    
public static func newBip84Public(publicKey: DescriptorPublicKey, fingerprint: String, keychain: KeychainKind, network: Network) -> Descriptor {
    return try!  FfiConverterTypeDescriptor.lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_descriptor_new_bip84_public(
        FfiConverterTypeDescriptorPublicKey.lower(publicKey),
        FfiConverterString.lower(fingerprint),
        FfiConverterTypeKeychainKind.lower(keychain),
        FfiConverterTypeNetwork.lower(network),$0
    )
})
}
    
public static func newBip86(secretKey: DescriptorSecretKey, keychain: KeychainKind, network: Network) -> Descriptor {
    return try!  FfiConverterTypeDescriptor.lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_descriptor_new_bip86(
        FfiConverterTypeDescriptorSecretKey.lower(secretKey),
        FfiConverterTypeKeychainKind.lower(keychain),
        FfiConverterTypeNetwork.lower(network),$0
    )
})
}
    
public static func newBip86Public(publicKey: DescriptorPublicKey, fingerprint: String, keychain: KeychainKind, network: Network) -> Descriptor {
    return try!  FfiConverterTypeDescriptor.lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_descriptor_new_bip86_public(
        FfiConverterTypeDescriptorPublicKey.lower(publicKey),
        FfiConverterString.lower(fingerprint),
        FfiConverterTypeKeychainKind.lower(keychain),
        FfiConverterTypeNetwork.lower(network),$0
    )
})
}
    

    
open func asString() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_descriptor_as_string(self.uniffiClonePointer(),$0
    )
})
}
    
open func asStringPrivate() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_descriptor_as_string_private(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeDescriptor: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Descriptor

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Descriptor {
        return Descriptor(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Descriptor) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Descriptor {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Descriptor, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeDescriptor_lift(_ pointer: UnsafeMutableRawPointer) throws -> Descriptor {
    return try FfiConverterTypeDescriptor.lift(pointer)
}

public func FfiConverterTypeDescriptor_lower(_ value: Descriptor) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDescriptor.lower(value)
}




public protocol DescriptorPublicKeyProtocol : AnyObject {
    
    func asString()  -> String
    
    func derive(path: DerivationPath) throws  -> DescriptorPublicKey
    
    func extend(path: DerivationPath) throws  -> DescriptorPublicKey
    
}

open class DescriptorPublicKey:
    DescriptorPublicKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_descriptorpublickey(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_descriptorpublickey(pointer, $0) }
    }

    
public static func fromString(publicKey: String)throws  -> DescriptorPublicKey {
    return try  FfiConverterTypeDescriptorPublicKey.lift(try rustCallWithError(FfiConverterTypeBdkError.lift) {
    uniffi_bdkffi_fn_constructor_descriptorpublickey_from_string(
        FfiConverterString.lower(publicKey),$0
    )
})
}
    

    
open func asString() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_descriptorpublickey_as_string(self.uniffiClonePointer(),$0
    )
})
}
    
open func derive(path: DerivationPath)throws  -> DescriptorPublicKey {
    return try  FfiConverterTypeDescriptorPublicKey.lift(try rustCallWithError(FfiConverterTypeBdkError.lift) {
    uniffi_bdkffi_fn_method_descriptorpublickey_derive(self.uniffiClonePointer(),
        FfiConverterTypeDerivationPath.lower(path),$0
    )
})
}
    
open func extend(path: DerivationPath)throws  -> DescriptorPublicKey {
    return try  FfiConverterTypeDescriptorPublicKey.lift(try rustCallWithError(FfiConverterTypeBdkError.lift) {
    uniffi_bdkffi_fn_method_descriptorpublickey_extend(self.uniffiClonePointer(),
        FfiConverterTypeDerivationPath.lower(path),$0
    )
})
}
    

}

public struct FfiConverterTypeDescriptorPublicKey: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = DescriptorPublicKey

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> DescriptorPublicKey {
        return DescriptorPublicKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: DescriptorPublicKey) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DescriptorPublicKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: DescriptorPublicKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeDescriptorPublicKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> DescriptorPublicKey {
    return try FfiConverterTypeDescriptorPublicKey.lift(pointer)
}

public func FfiConverterTypeDescriptorPublicKey_lower(_ value: DescriptorPublicKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDescriptorPublicKey.lower(value)
}




public protocol DescriptorSecretKeyProtocol : AnyObject {
    
    func asPublic()  -> DescriptorPublicKey
    
    func asString()  -> String
    
    func derive(path: DerivationPath) throws  -> DescriptorSecretKey
    
    func extend(path: DerivationPath) throws  -> DescriptorSecretKey
    
    func secretBytes()  -> [UInt8]
    
}

open class DescriptorSecretKey:
    DescriptorSecretKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_descriptorsecretkey(self.pointer, $0) }
    }
public convenience init(network: Network, mnemonic: Mnemonic, password: String?) {
    let pointer =
        try! rustCall() {
    uniffi_bdkffi_fn_constructor_descriptorsecretkey_new(
        FfiConverterTypeNetwork.lower(network),
        FfiConverterTypeMnemonic.lower(mnemonic),
        FfiConverterOptionString.lower(password),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_descriptorsecretkey(pointer, $0) }
    }

    
public static func fromString(secretKey: String)throws  -> DescriptorSecretKey {
    return try  FfiConverterTypeDescriptorSecretKey.lift(try rustCallWithError(FfiConverterTypeBdkError.lift) {
    uniffi_bdkffi_fn_constructor_descriptorsecretkey_from_string(
        FfiConverterString.lower(secretKey),$0
    )
})
}
    

    
open func asPublic() -> DescriptorPublicKey {
    return try!  FfiConverterTypeDescriptorPublicKey.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_descriptorsecretkey_as_public(self.uniffiClonePointer(),$0
    )
})
}
    
open func asString() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_descriptorsecretkey_as_string(self.uniffiClonePointer(),$0
    )
})
}
    
open func derive(path: DerivationPath)throws  -> DescriptorSecretKey {
    return try  FfiConverterTypeDescriptorSecretKey.lift(try rustCallWithError(FfiConverterTypeBdkError.lift) {
    uniffi_bdkffi_fn_method_descriptorsecretkey_derive(self.uniffiClonePointer(),
        FfiConverterTypeDerivationPath.lower(path),$0
    )
})
}
    
open func extend(path: DerivationPath)throws  -> DescriptorSecretKey {
    return try  FfiConverterTypeDescriptorSecretKey.lift(try rustCallWithError(FfiConverterTypeBdkError.lift) {
    uniffi_bdkffi_fn_method_descriptorsecretkey_extend(self.uniffiClonePointer(),
        FfiConverterTypeDerivationPath.lower(path),$0
    )
})
}
    
open func secretBytes() -> [UInt8] {
    return try!  FfiConverterSequenceUInt8.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_descriptorsecretkey_secret_bytes(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeDescriptorSecretKey: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = DescriptorSecretKey

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> DescriptorSecretKey {
        return DescriptorSecretKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: DescriptorSecretKey) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DescriptorSecretKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: DescriptorSecretKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeDescriptorSecretKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> DescriptorSecretKey {
    return try FfiConverterTypeDescriptorSecretKey.lift(pointer)
}

public func FfiConverterTypeDescriptorSecretKey_lower(_ value: DescriptorSecretKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDescriptorSecretKey.lower(value)
}




public protocol FeeRateProtocol : AnyObject {
    
    func asSatPerVb()  -> Float
    
}

open class FeeRate:
    FeeRateProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_feerate(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_feerate(pointer, $0) }
    }

    
public static func fromSatPerVb(satPerVb: Float) -> FeeRate {
    return try!  FfiConverterTypeFeeRate.lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_feerate_from_sat_per_vb(
        FfiConverterFloat.lower(satPerVb),$0
    )
})
}
    

    
open func asSatPerVb() -> Float {
    return try!  FfiConverterFloat.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_feerate_as_sat_per_vb(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeFeeRate: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FeeRate

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRate {
        return FeeRate(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FeeRate) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeRate {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FeeRate, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeFeeRate_lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRate {
    return try FfiConverterTypeFeeRate.lift(pointer)
}

public func FfiConverterTypeFeeRate_lower(_ value: FeeRate) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFeeRate.lower(value)
}




public protocol MnemonicProtocol : AnyObject {
    
    func asString()  -> String
    
}

open class Mnemonic:
    MnemonicProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_mnemonic(self.pointer, $0) }
    }
public convenience init(wordCount: WordCount) {
    let pointer =
        try! rustCall() {
    uniffi_bdkffi_fn_constructor_mnemonic_new(
        FfiConverterTypeWordCount.lower(wordCount),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_mnemonic(pointer, $0) }
    }

    
public static func fromEntropy(entropy: [UInt8])throws  -> Mnemonic {
    return try  FfiConverterTypeMnemonic.lift(try rustCallWithError(FfiConverterTypeBdkError.lift) {
    uniffi_bdkffi_fn_constructor_mnemonic_from_entropy(
        FfiConverterSequenceUInt8.lower(entropy),$0
    )
})
}
    
public static func fromString(mnemonic: String)throws  -> Mnemonic {
    return try  FfiConverterTypeMnemonic.lift(try rustCallWithError(FfiConverterTypeBdkError.lift) {
    uniffi_bdkffi_fn_constructor_mnemonic_from_string(
        FfiConverterString.lower(mnemonic),$0
    )
})
}
    

    
open func asString() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_mnemonic_as_string(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeMnemonic: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Mnemonic

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Mnemonic {
        return Mnemonic(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Mnemonic) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Mnemonic {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Mnemonic, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeMnemonic_lift(_ pointer: UnsafeMutableRawPointer) throws -> Mnemonic {
    return try FfiConverterTypeMnemonic.lift(pointer)
}

public func FfiConverterTypeMnemonic_lower(_ value: Mnemonic) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMnemonic.lower(value)
}




public protocol PartiallySignedTransactionProtocol : AnyObject {
    
    func combine(other: PartiallySignedTransaction) throws  -> PartiallySignedTransaction
    
    func extractTx()  -> Transaction
    
    func feeAmount()  -> UInt64?
    
    func feeRate()  -> FeeRate?
    
    func jsonSerialize()  -> String
    
    func serialize()  -> String
    
    func txid()  -> String
    
}

open class PartiallySignedTransaction:
    PartiallySignedTransactionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_partiallysignedtransaction(self.pointer, $0) }
    }
public convenience init(psbtBase64: String)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeBdkError.lift) {
    uniffi_bdkffi_fn_constructor_partiallysignedtransaction_new(
        FfiConverterString.lower(psbtBase64),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_partiallysignedtransaction(pointer, $0) }
    }

    

    
open func combine(other: PartiallySignedTransaction)throws  -> PartiallySignedTransaction {
    return try  FfiConverterTypePartiallySignedTransaction.lift(try rustCallWithError(FfiConverterTypeBdkError.lift) {
    uniffi_bdkffi_fn_method_partiallysignedtransaction_combine(self.uniffiClonePointer(),
        FfiConverterTypePartiallySignedTransaction.lower(other),$0
    )
})
}
    
open func extractTx() -> Transaction {
    return try!  FfiConverterTypeTransaction.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_partiallysignedtransaction_extract_tx(self.uniffiClonePointer(),$0
    )
})
}
    
open func feeAmount() -> UInt64? {
    return try!  FfiConverterOptionUInt64.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_partiallysignedtransaction_fee_amount(self.uniffiClonePointer(),$0
    )
})
}
    
open func feeRate() -> FeeRate? {
    return try!  FfiConverterOptionTypeFeeRate.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_partiallysignedtransaction_fee_rate(self.uniffiClonePointer(),$0
    )
})
}
    
open func jsonSerialize() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_partiallysignedtransaction_json_serialize(self.uniffiClonePointer(),$0
    )
})
}
    
open func serialize() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_partiallysignedtransaction_serialize(self.uniffiClonePointer(),$0
    )
})
}
    
open func txid() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_partiallysignedtransaction_txid(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypePartiallySignedTransaction: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PartiallySignedTransaction

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PartiallySignedTransaction {
        return PartiallySignedTransaction(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PartiallySignedTransaction) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PartiallySignedTransaction {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PartiallySignedTransaction, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypePartiallySignedTransaction_lift(_ pointer: UnsafeMutableRawPointer) throws -> PartiallySignedTransaction {
    return try FfiConverterTypePartiallySignedTransaction.lift(pointer)
}

public func FfiConverterTypePartiallySignedTransaction_lower(_ value: PartiallySignedTransaction) -> UnsafeMutableRawPointer {
    return FfiConverterTypePartiallySignedTransaction.lower(value)
}




public protocol ScriptProtocol : AnyObject {
    
    func toBytes()  -> [UInt8]
    
}

open class Script:
    ScriptProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_script(self.pointer, $0) }
    }
public convenience init(rawOutputScript: [UInt8]) {
    let pointer =
        try! rustCall() {
    uniffi_bdkffi_fn_constructor_script_new(
        FfiConverterSequenceUInt8.lower(rawOutputScript),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_script(pointer, $0) }
    }

    

    
open func toBytes() -> [UInt8] {
    return try!  FfiConverterSequenceUInt8.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_script_to_bytes(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeScript: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Script

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Script {
        return Script(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Script) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Script {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Script, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeScript_lift(_ pointer: UnsafeMutableRawPointer) throws -> Script {
    return try FfiConverterTypeScript.lift(pointer)
}

public func FfiConverterTypeScript_lower(_ value: Script) -> UnsafeMutableRawPointer {
    return FfiConverterTypeScript.lower(value)
}




public protocol TransactionProtocol : AnyObject {
    
    func input()  -> [TxIn]
    
    func isCoinBase()  -> Bool
    
    func isExplicitlyRbf()  -> Bool
    
    func isLockTimeEnabled()  -> Bool
    
    func lockTime()  -> UInt32
    
    func output()  -> [TxOut]
    
    func serialize()  -> [UInt8]
    
    func size()  -> UInt64
    
    func txid()  -> String
    
    func version()  -> Int32
    
    func vsize()  -> UInt64
    
    func weight()  -> UInt64
    
}

open class Transaction:
    TransactionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_transaction(self.pointer, $0) }
    }
public convenience init(transactionBytes: [UInt8])throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeBdkError.lift) {
    uniffi_bdkffi_fn_constructor_transaction_new(
        FfiConverterSequenceUInt8.lower(transactionBytes),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_transaction(pointer, $0) }
    }

    

    
open func input() -> [TxIn] {
    return try!  FfiConverterSequenceTypeTxIn.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_input(self.uniffiClonePointer(),$0
    )
})
}
    
open func isCoinBase() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_is_coin_base(self.uniffiClonePointer(),$0
    )
})
}
    
open func isExplicitlyRbf() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_is_explicitly_rbf(self.uniffiClonePointer(),$0
    )
})
}
    
open func isLockTimeEnabled() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_is_lock_time_enabled(self.uniffiClonePointer(),$0
    )
})
}
    
open func lockTime() -> UInt32 {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_lock_time(self.uniffiClonePointer(),$0
    )
})
}
    
open func output() -> [TxOut] {
    return try!  FfiConverterSequenceTypeTxOut.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_output(self.uniffiClonePointer(),$0
    )
})
}
    
open func serialize() -> [UInt8] {
    return try!  FfiConverterSequenceUInt8.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_serialize(self.uniffiClonePointer(),$0
    )
})
}
    
open func size() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_size(self.uniffiClonePointer(),$0
    )
})
}
    
open func txid() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_txid(self.uniffiClonePointer(),$0
    )
})
}
    
open func version() -> Int32 {
    return try!  FfiConverterInt32.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_version(self.uniffiClonePointer(),$0
    )
})
}
    
open func vsize() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_vsize(self.uniffiClonePointer(),$0
    )
})
}
    
open func weight() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_weight(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeTransaction: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Transaction

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Transaction {
        return Transaction(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Transaction) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Transaction {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Transaction, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeTransaction_lift(_ pointer: UnsafeMutableRawPointer) throws -> Transaction {
    return try FfiConverterTypeTransaction.lift(pointer)
}

public func FfiConverterTypeTransaction_lower(_ value: Transaction) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTransaction.lower(value)
}




public protocol TxBuilderProtocol : AnyObject {
    
    func addData(data: [UInt8])  -> TxBuilder
    
    func addRecipient(script: Script, amount: UInt64)  -> TxBuilder
    
    func addUnspendable(unspendable: OutPoint)  -> TxBuilder
    
    func addUtxo(outpoint: OutPoint)  -> TxBuilder
    
    func addUtxos(outpoints: [OutPoint])  -> TxBuilder
    
    func doNotSpendChange()  -> TxBuilder
    
    func drainTo(script: Script)  -> TxBuilder
    
    func drainWallet()  -> TxBuilder
    
    func enableRbf()  -> TxBuilder
    
    func enableRbfWithSequence(nsequence: UInt32)  -> TxBuilder
    
    func feeAbsolute(feeAmount: UInt64)  -> TxBuilder
    
    func feeRate(satPerVbyte: Float)  -> TxBuilder
    
    func finish(wallet: Wallet) throws  -> TxBuilderResult
    
    func manuallySelectedOnly()  -> TxBuilder
    
    func onlySpendChange()  -> TxBuilder
    
    func setRecipients(recipients: [ScriptAmount])  -> TxBuilder
    
    func unspendable(unspendable: [OutPoint])  -> TxBuilder
    
}

open class TxBuilder:
    TxBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_txbuilder(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_bdkffi_fn_constructor_txbuilder_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_txbuilder(pointer, $0) }
    }

    

    
open func addData(data: [UInt8]) -> TxBuilder {
    return try!  FfiConverterTypeTxBuilder.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_add_data(self.uniffiClonePointer(),
        FfiConverterSequenceUInt8.lower(data),$0
    )
})
}
    
open func addRecipient(script: Script, amount: UInt64) -> TxBuilder {
    return try!  FfiConverterTypeTxBuilder.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_add_recipient(self.uniffiClonePointer(),
        FfiConverterTypeScript.lower(script),
        FfiConverterUInt64.lower(amount),$0
    )
})
}
    
open func addUnspendable(unspendable: OutPoint) -> TxBuilder {
    return try!  FfiConverterTypeTxBuilder.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_add_unspendable(self.uniffiClonePointer(),
        FfiConverterTypeOutPoint.lower(unspendable),$0
    )
})
}
    
open func addUtxo(outpoint: OutPoint) -> TxBuilder {
    return try!  FfiConverterTypeTxBuilder.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_add_utxo(self.uniffiClonePointer(),
        FfiConverterTypeOutPoint.lower(outpoint),$0
    )
})
}
    
open func addUtxos(outpoints: [OutPoint]) -> TxBuilder {
    return try!  FfiConverterTypeTxBuilder.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_add_utxos(self.uniffiClonePointer(),
        FfiConverterSequenceTypeOutPoint.lower(outpoints),$0
    )
})
}
    
open func doNotSpendChange() -> TxBuilder {
    return try!  FfiConverterTypeTxBuilder.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_do_not_spend_change(self.uniffiClonePointer(),$0
    )
})
}
    
open func drainTo(script: Script) -> TxBuilder {
    return try!  FfiConverterTypeTxBuilder.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_drain_to(self.uniffiClonePointer(),
        FfiConverterTypeScript.lower(script),$0
    )
})
}
    
open func drainWallet() -> TxBuilder {
    return try!  FfiConverterTypeTxBuilder.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_drain_wallet(self.uniffiClonePointer(),$0
    )
})
}
    
open func enableRbf() -> TxBuilder {
    return try!  FfiConverterTypeTxBuilder.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_enable_rbf(self.uniffiClonePointer(),$0
    )
})
}
    
open func enableRbfWithSequence(nsequence: UInt32) -> TxBuilder {
    return try!  FfiConverterTypeTxBuilder.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_enable_rbf_with_sequence(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(nsequence),$0
    )
})
}
    
open func feeAbsolute(feeAmount: UInt64) -> TxBuilder {
    return try!  FfiConverterTypeTxBuilder.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_fee_absolute(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(feeAmount),$0
    )
})
}
    
open func feeRate(satPerVbyte: Float) -> TxBuilder {
    return try!  FfiConverterTypeTxBuilder.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_fee_rate(self.uniffiClonePointer(),
        FfiConverterFloat.lower(satPerVbyte),$0
    )
})
}
    
open func finish(wallet: Wallet)throws  -> TxBuilderResult {
    return try  FfiConverterTypeTxBuilderResult.lift(try rustCallWithError(FfiConverterTypeBdkError.lift) {
    uniffi_bdkffi_fn_method_txbuilder_finish(self.uniffiClonePointer(),
        FfiConverterTypeWallet.lower(wallet),$0
    )
})
}
    
open func manuallySelectedOnly() -> TxBuilder {
    return try!  FfiConverterTypeTxBuilder.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_manually_selected_only(self.uniffiClonePointer(),$0
    )
})
}
    
open func onlySpendChange() -> TxBuilder {
    return try!  FfiConverterTypeTxBuilder.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_only_spend_change(self.uniffiClonePointer(),$0
    )
})
}
    
open func setRecipients(recipients: [ScriptAmount]) -> TxBuilder {
    return try!  FfiConverterTypeTxBuilder.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_set_recipients(self.uniffiClonePointer(),
        FfiConverterSequenceTypeScriptAmount.lower(recipients),$0
    )
})
}
    
open func unspendable(unspendable: [OutPoint]) -> TxBuilder {
    return try!  FfiConverterTypeTxBuilder.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_unspendable(self.uniffiClonePointer(),
        FfiConverterSequenceTypeOutPoint.lower(unspendable),$0
    )
})
}
    

}

public struct FfiConverterTypeTxBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TxBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TxBuilder {
        return TxBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TxBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TxBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeTxBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> TxBuilder {
    return try FfiConverterTypeTxBuilder.lift(pointer)
}

public func FfiConverterTypeTxBuilder_lower(_ value: TxBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTxBuilder.lower(value)
}




public protocol WalletProtocol : AnyObject {
    
    func getAddress(addressIndex: AddressIndex) throws  -> AddressInfo
    
    func getBalance() throws  -> Balance
    
    func getInternalAddress(addressIndex: AddressIndex) throws  -> AddressInfo
    
    func isMine(script: Script) throws  -> Bool
    
    func listTransactions(includeRaw: Bool) throws  -> [TransactionDetails]
    
    func listUnspent() throws  -> [LocalUtxo]
    
    func network()  -> Network
    
    func sign(psbt: PartiallySignedTransaction, signOptions: SignOptions?) throws  -> Bool
    
    func sync(blockchain: Blockchain, progress: Progress?) throws 
    
}

open class Wallet:
    WalletProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_wallet(self.pointer, $0) }
    }
public convenience init(descriptor: Descriptor, changeDescriptor: Descriptor?, network: Network, databaseConfig: DatabaseConfig)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeBdkError.lift) {
    uniffi_bdkffi_fn_constructor_wallet_new(
        FfiConverterTypeDescriptor.lower(descriptor),
        FfiConverterOptionTypeDescriptor.lower(changeDescriptor),
        FfiConverterTypeNetwork.lower(network),
        FfiConverterTypeDatabaseConfig.lower(databaseConfig),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_wallet(pointer, $0) }
    }

    

    
open func getAddress(addressIndex: AddressIndex)throws  -> AddressInfo {
    return try  FfiConverterTypeAddressInfo.lift(try rustCallWithError(FfiConverterTypeBdkError.lift) {
    uniffi_bdkffi_fn_method_wallet_get_address(self.uniffiClonePointer(),
        FfiConverterTypeAddressIndex.lower(addressIndex),$0
    )
})
}
    
open func getBalance()throws  -> Balance {
    return try  FfiConverterTypeBalance.lift(try rustCallWithError(FfiConverterTypeBdkError.lift) {
    uniffi_bdkffi_fn_method_wallet_get_balance(self.uniffiClonePointer(),$0
    )
})
}
    
open func getInternalAddress(addressIndex: AddressIndex)throws  -> AddressInfo {
    return try  FfiConverterTypeAddressInfo.lift(try rustCallWithError(FfiConverterTypeBdkError.lift) {
    uniffi_bdkffi_fn_method_wallet_get_internal_address(self.uniffiClonePointer(),
        FfiConverterTypeAddressIndex.lower(addressIndex),$0
    )
})
}
    
open func isMine(script: Script)throws  -> Bool {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeBdkError.lift) {
    uniffi_bdkffi_fn_method_wallet_is_mine(self.uniffiClonePointer(),
        FfiConverterTypeScript.lower(script),$0
    )
})
}
    
open func listTransactions(includeRaw: Bool)throws  -> [TransactionDetails] {
    return try  FfiConverterSequenceTypeTransactionDetails.lift(try rustCallWithError(FfiConverterTypeBdkError.lift) {
    uniffi_bdkffi_fn_method_wallet_list_transactions(self.uniffiClonePointer(),
        FfiConverterBool.lower(includeRaw),$0
    )
})
}
    
open func listUnspent()throws  -> [LocalUtxo] {
    return try  FfiConverterSequenceTypeLocalUtxo.lift(try rustCallWithError(FfiConverterTypeBdkError.lift) {
    uniffi_bdkffi_fn_method_wallet_list_unspent(self.uniffiClonePointer(),$0
    )
})
}
    
open func network() -> Network {
    return try!  FfiConverterTypeNetwork.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_network(self.uniffiClonePointer(),$0
    )
})
}
    
open func sign(psbt: PartiallySignedTransaction, signOptions: SignOptions?)throws  -> Bool {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeBdkError.lift) {
    uniffi_bdkffi_fn_method_wallet_sign(self.uniffiClonePointer(),
        FfiConverterTypePartiallySignedTransaction.lower(psbt),
        FfiConverterOptionTypeSignOptions.lower(signOptions),$0
    )
})
}
    
open func sync(blockchain: Blockchain, progress: Progress?)throws  {try rustCallWithError(FfiConverterTypeBdkError.lift) {
    uniffi_bdkffi_fn_method_wallet_sync(self.uniffiClonePointer(),
        FfiConverterTypeBlockchain.lower(blockchain),
        FfiConverterOptionCallbackInterfaceProgress.lower(progress),$0
    )
}
}
    

}

public struct FfiConverterTypeWallet: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Wallet

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Wallet {
        return Wallet(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Wallet) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Wallet {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Wallet, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeWallet_lift(_ pointer: UnsafeMutableRawPointer) throws -> Wallet {
    return try FfiConverterTypeWallet.lift(pointer)
}

public func FfiConverterTypeWallet_lower(_ value: Wallet) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWallet.lower(value)
}


public struct AddressInfo {
    public var index: UInt32
    public var address: Address
    public var keychain: KeychainKind

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(index: UInt32, address: Address, keychain: KeychainKind) {
        self.index = index
        self.address = address
        self.keychain = keychain
    }
}



public struct FfiConverterTypeAddressInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressInfo {
        return
            try AddressInfo(
                index: FfiConverterUInt32.read(from: &buf), 
                address: FfiConverterTypeAddress.read(from: &buf), 
                keychain: FfiConverterTypeKeychainKind.read(from: &buf)
        )
    }

    public static func write(_ value: AddressInfo, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.index, into: &buf)
        FfiConverterTypeAddress.write(value.address, into: &buf)
        FfiConverterTypeKeychainKind.write(value.keychain, into: &buf)
    }
}


public func FfiConverterTypeAddressInfo_lift(_ buf: RustBuffer) throws -> AddressInfo {
    return try FfiConverterTypeAddressInfo.lift(buf)
}

public func FfiConverterTypeAddressInfo_lower(_ value: AddressInfo) -> RustBuffer {
    return FfiConverterTypeAddressInfo.lower(value)
}


public struct Balance {
    public var immature: UInt64
    public var trustedPending: UInt64
    public var untrustedPending: UInt64
    public var confirmed: UInt64
    public var spendable: UInt64
    public var total: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(immature: UInt64, trustedPending: UInt64, untrustedPending: UInt64, confirmed: UInt64, spendable: UInt64, total: UInt64) {
        self.immature = immature
        self.trustedPending = trustedPending
        self.untrustedPending = untrustedPending
        self.confirmed = confirmed
        self.spendable = spendable
        self.total = total
    }
}



extension Balance: Equatable, Hashable {
    public static func ==(lhs: Balance, rhs: Balance) -> Bool {
        if lhs.immature != rhs.immature {
            return false
        }
        if lhs.trustedPending != rhs.trustedPending {
            return false
        }
        if lhs.untrustedPending != rhs.untrustedPending {
            return false
        }
        if lhs.confirmed != rhs.confirmed {
            return false
        }
        if lhs.spendable != rhs.spendable {
            return false
        }
        if lhs.total != rhs.total {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(immature)
        hasher.combine(trustedPending)
        hasher.combine(untrustedPending)
        hasher.combine(confirmed)
        hasher.combine(spendable)
        hasher.combine(total)
    }
}


public struct FfiConverterTypeBalance: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Balance {
        return
            try Balance(
                immature: FfiConverterUInt64.read(from: &buf), 
                trustedPending: FfiConverterUInt64.read(from: &buf), 
                untrustedPending: FfiConverterUInt64.read(from: &buf), 
                confirmed: FfiConverterUInt64.read(from: &buf), 
                spendable: FfiConverterUInt64.read(from: &buf), 
                total: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Balance, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.immature, into: &buf)
        FfiConverterUInt64.write(value.trustedPending, into: &buf)
        FfiConverterUInt64.write(value.untrustedPending, into: &buf)
        FfiConverterUInt64.write(value.confirmed, into: &buf)
        FfiConverterUInt64.write(value.spendable, into: &buf)
        FfiConverterUInt64.write(value.total, into: &buf)
    }
}


public func FfiConverterTypeBalance_lift(_ buf: RustBuffer) throws -> Balance {
    return try FfiConverterTypeBalance.lift(buf)
}

public func FfiConverterTypeBalance_lower(_ value: Balance) -> RustBuffer {
    return FfiConverterTypeBalance.lower(value)
}


public struct BlockTime {
    public var height: UInt32
    public var timestamp: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(height: UInt32, timestamp: UInt64) {
        self.height = height
        self.timestamp = timestamp
    }
}



extension BlockTime: Equatable, Hashable {
    public static func ==(lhs: BlockTime, rhs: BlockTime) -> Bool {
        if lhs.height != rhs.height {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(height)
        hasher.combine(timestamp)
    }
}


public struct FfiConverterTypeBlockTime: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlockTime {
        return
            try BlockTime(
                height: FfiConverterUInt32.read(from: &buf), 
                timestamp: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: BlockTime, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.height, into: &buf)
        FfiConverterUInt64.write(value.timestamp, into: &buf)
    }
}


public func FfiConverterTypeBlockTime_lift(_ buf: RustBuffer) throws -> BlockTime {
    return try FfiConverterTypeBlockTime.lift(buf)
}

public func FfiConverterTypeBlockTime_lower(_ value: BlockTime) -> RustBuffer {
    return FfiConverterTypeBlockTime.lower(value)
}


public struct ElectrumConfig {
    public var url: String
    public var socks5: String?
    public var retry: UInt8
    public var timeout: UInt8?
    public var stopGap: UInt64
    public var validateDomain: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: String, socks5: String?, retry: UInt8, timeout: UInt8?, stopGap: UInt64, validateDomain: Bool) {
        self.url = url
        self.socks5 = socks5
        self.retry = retry
        self.timeout = timeout
        self.stopGap = stopGap
        self.validateDomain = validateDomain
    }
}



extension ElectrumConfig: Equatable, Hashable {
    public static func ==(lhs: ElectrumConfig, rhs: ElectrumConfig) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.socks5 != rhs.socks5 {
            return false
        }
        if lhs.retry != rhs.retry {
            return false
        }
        if lhs.timeout != rhs.timeout {
            return false
        }
        if lhs.stopGap != rhs.stopGap {
            return false
        }
        if lhs.validateDomain != rhs.validateDomain {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(socks5)
        hasher.combine(retry)
        hasher.combine(timeout)
        hasher.combine(stopGap)
        hasher.combine(validateDomain)
    }
}


public struct FfiConverterTypeElectrumConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ElectrumConfig {
        return
            try ElectrumConfig(
                url: FfiConverterString.read(from: &buf), 
                socks5: FfiConverterOptionString.read(from: &buf), 
                retry: FfiConverterUInt8.read(from: &buf), 
                timeout: FfiConverterOptionUInt8.read(from: &buf), 
                stopGap: FfiConverterUInt64.read(from: &buf), 
                validateDomain: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: ElectrumConfig, into buf: inout [UInt8]) {
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterOptionString.write(value.socks5, into: &buf)
        FfiConverterUInt8.write(value.retry, into: &buf)
        FfiConverterOptionUInt8.write(value.timeout, into: &buf)
        FfiConverterUInt64.write(value.stopGap, into: &buf)
        FfiConverterBool.write(value.validateDomain, into: &buf)
    }
}


public func FfiConverterTypeElectrumConfig_lift(_ buf: RustBuffer) throws -> ElectrumConfig {
    return try FfiConverterTypeElectrumConfig.lift(buf)
}

public func FfiConverterTypeElectrumConfig_lower(_ value: ElectrumConfig) -> RustBuffer {
    return FfiConverterTypeElectrumConfig.lower(value)
}


public struct EsploraConfig {
    public var baseUrl: String
    public var proxy: String?
    public var concurrency: UInt8?
    public var stopGap: UInt64
    public var timeout: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(baseUrl: String, proxy: String?, concurrency: UInt8?, stopGap: UInt64, timeout: UInt64?) {
        self.baseUrl = baseUrl
        self.proxy = proxy
        self.concurrency = concurrency
        self.stopGap = stopGap
        self.timeout = timeout
    }
}



extension EsploraConfig: Equatable, Hashable {
    public static func ==(lhs: EsploraConfig, rhs: EsploraConfig) -> Bool {
        if lhs.baseUrl != rhs.baseUrl {
            return false
        }
        if lhs.proxy != rhs.proxy {
            return false
        }
        if lhs.concurrency != rhs.concurrency {
            return false
        }
        if lhs.stopGap != rhs.stopGap {
            return false
        }
        if lhs.timeout != rhs.timeout {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(baseUrl)
        hasher.combine(proxy)
        hasher.combine(concurrency)
        hasher.combine(stopGap)
        hasher.combine(timeout)
    }
}


public struct FfiConverterTypeEsploraConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EsploraConfig {
        return
            try EsploraConfig(
                baseUrl: FfiConverterString.read(from: &buf), 
                proxy: FfiConverterOptionString.read(from: &buf), 
                concurrency: FfiConverterOptionUInt8.read(from: &buf), 
                stopGap: FfiConverterUInt64.read(from: &buf), 
                timeout: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: EsploraConfig, into buf: inout [UInt8]) {
        FfiConverterString.write(value.baseUrl, into: &buf)
        FfiConverterOptionString.write(value.proxy, into: &buf)
        FfiConverterOptionUInt8.write(value.concurrency, into: &buf)
        FfiConverterUInt64.write(value.stopGap, into: &buf)
        FfiConverterOptionUInt64.write(value.timeout, into: &buf)
    }
}


public func FfiConverterTypeEsploraConfig_lift(_ buf: RustBuffer) throws -> EsploraConfig {
    return try FfiConverterTypeEsploraConfig.lift(buf)
}

public func FfiConverterTypeEsploraConfig_lower(_ value: EsploraConfig) -> RustBuffer {
    return FfiConverterTypeEsploraConfig.lower(value)
}


public struct LocalUtxo {
    public var outpoint: OutPoint
    public var txout: TxOut
    public var keychain: KeychainKind
    public var isSpent: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(outpoint: OutPoint, txout: TxOut, keychain: KeychainKind, isSpent: Bool) {
        self.outpoint = outpoint
        self.txout = txout
        self.keychain = keychain
        self.isSpent = isSpent
    }
}



public struct FfiConverterTypeLocalUtxo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocalUtxo {
        return
            try LocalUtxo(
                outpoint: FfiConverterTypeOutPoint.read(from: &buf), 
                txout: FfiConverterTypeTxOut.read(from: &buf), 
                keychain: FfiConverterTypeKeychainKind.read(from: &buf), 
                isSpent: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: LocalUtxo, into buf: inout [UInt8]) {
        FfiConverterTypeOutPoint.write(value.outpoint, into: &buf)
        FfiConverterTypeTxOut.write(value.txout, into: &buf)
        FfiConverterTypeKeychainKind.write(value.keychain, into: &buf)
        FfiConverterBool.write(value.isSpent, into: &buf)
    }
}


public func FfiConverterTypeLocalUtxo_lift(_ buf: RustBuffer) throws -> LocalUtxo {
    return try FfiConverterTypeLocalUtxo.lift(buf)
}

public func FfiConverterTypeLocalUtxo_lower(_ value: LocalUtxo) -> RustBuffer {
    return FfiConverterTypeLocalUtxo.lower(value)
}


public struct OutPoint {
    public var txid: String
    public var vout: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txid: String, vout: UInt32) {
        self.txid = txid
        self.vout = vout
    }
}



extension OutPoint: Equatable, Hashable {
    public static func ==(lhs: OutPoint, rhs: OutPoint) -> Bool {
        if lhs.txid != rhs.txid {
            return false
        }
        if lhs.vout != rhs.vout {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txid)
        hasher.combine(vout)
    }
}


public struct FfiConverterTypeOutPoint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OutPoint {
        return
            try OutPoint(
                txid: FfiConverterString.read(from: &buf), 
                vout: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: OutPoint, into buf: inout [UInt8]) {
        FfiConverterString.write(value.txid, into: &buf)
        FfiConverterUInt32.write(value.vout, into: &buf)
    }
}


public func FfiConverterTypeOutPoint_lift(_ buf: RustBuffer) throws -> OutPoint {
    return try FfiConverterTypeOutPoint.lift(buf)
}

public func FfiConverterTypeOutPoint_lower(_ value: OutPoint) -> RustBuffer {
    return FfiConverterTypeOutPoint.lower(value)
}


public struct RpcConfig {
    public var url: String
    public var auth: Auth
    public var network: Network
    public var walletName: String
    public var syncParams: RpcSyncParams?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: String, auth: Auth, network: Network, walletName: String, syncParams: RpcSyncParams?) {
        self.url = url
        self.auth = auth
        self.network = network
        self.walletName = walletName
        self.syncParams = syncParams
    }
}



extension RpcConfig: Equatable, Hashable {
    public static func ==(lhs: RpcConfig, rhs: RpcConfig) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.auth != rhs.auth {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.walletName != rhs.walletName {
            return false
        }
        if lhs.syncParams != rhs.syncParams {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(auth)
        hasher.combine(network)
        hasher.combine(walletName)
        hasher.combine(syncParams)
    }
}


public struct FfiConverterTypeRpcConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RpcConfig {
        return
            try RpcConfig(
                url: FfiConverterString.read(from: &buf), 
                auth: FfiConverterTypeAuth.read(from: &buf), 
                network: FfiConverterTypeNetwork.read(from: &buf), 
                walletName: FfiConverterString.read(from: &buf), 
                syncParams: FfiConverterOptionTypeRpcSyncParams.read(from: &buf)
        )
    }

    public static func write(_ value: RpcConfig, into buf: inout [UInt8]) {
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterTypeAuth.write(value.auth, into: &buf)
        FfiConverterTypeNetwork.write(value.network, into: &buf)
        FfiConverterString.write(value.walletName, into: &buf)
        FfiConverterOptionTypeRpcSyncParams.write(value.syncParams, into: &buf)
    }
}


public func FfiConverterTypeRpcConfig_lift(_ buf: RustBuffer) throws -> RpcConfig {
    return try FfiConverterTypeRpcConfig.lift(buf)
}

public func FfiConverterTypeRpcConfig_lower(_ value: RpcConfig) -> RustBuffer {
    return FfiConverterTypeRpcConfig.lower(value)
}


public struct RpcSyncParams {
    public var startScriptCount: UInt64
    public var startTime: UInt64
    public var forceStartTime: Bool
    public var pollRateSec: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(startScriptCount: UInt64, startTime: UInt64, forceStartTime: Bool, pollRateSec: UInt64) {
        self.startScriptCount = startScriptCount
        self.startTime = startTime
        self.forceStartTime = forceStartTime
        self.pollRateSec = pollRateSec
    }
}



extension RpcSyncParams: Equatable, Hashable {
    public static func ==(lhs: RpcSyncParams, rhs: RpcSyncParams) -> Bool {
        if lhs.startScriptCount != rhs.startScriptCount {
            return false
        }
        if lhs.startTime != rhs.startTime {
            return false
        }
        if lhs.forceStartTime != rhs.forceStartTime {
            return false
        }
        if lhs.pollRateSec != rhs.pollRateSec {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(startScriptCount)
        hasher.combine(startTime)
        hasher.combine(forceStartTime)
        hasher.combine(pollRateSec)
    }
}


public struct FfiConverterTypeRpcSyncParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RpcSyncParams {
        return
            try RpcSyncParams(
                startScriptCount: FfiConverterUInt64.read(from: &buf), 
                startTime: FfiConverterUInt64.read(from: &buf), 
                forceStartTime: FfiConverterBool.read(from: &buf), 
                pollRateSec: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: RpcSyncParams, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.startScriptCount, into: &buf)
        FfiConverterUInt64.write(value.startTime, into: &buf)
        FfiConverterBool.write(value.forceStartTime, into: &buf)
        FfiConverterUInt64.write(value.pollRateSec, into: &buf)
    }
}


public func FfiConverterTypeRpcSyncParams_lift(_ buf: RustBuffer) throws -> RpcSyncParams {
    return try FfiConverterTypeRpcSyncParams.lift(buf)
}

public func FfiConverterTypeRpcSyncParams_lower(_ value: RpcSyncParams) -> RustBuffer {
    return FfiConverterTypeRpcSyncParams.lower(value)
}


public struct ScriptAmount {
    public var script: Script
    public var amount: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(script: Script, amount: UInt64) {
        self.script = script
        self.amount = amount
    }
}



public struct FfiConverterTypeScriptAmount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScriptAmount {
        return
            try ScriptAmount(
                script: FfiConverterTypeScript.read(from: &buf), 
                amount: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ScriptAmount, into buf: inout [UInt8]) {
        FfiConverterTypeScript.write(value.script, into: &buf)
        FfiConverterUInt64.write(value.amount, into: &buf)
    }
}


public func FfiConverterTypeScriptAmount_lift(_ buf: RustBuffer) throws -> ScriptAmount {
    return try FfiConverterTypeScriptAmount.lift(buf)
}

public func FfiConverterTypeScriptAmount_lower(_ value: ScriptAmount) -> RustBuffer {
    return FfiConverterTypeScriptAmount.lower(value)
}


public struct SignOptions {
    public var trustWitnessUtxo: Bool
    public var assumeHeight: UInt32?
    public var allowAllSighashes: Bool
    public var removePartialSigs: Bool
    public var tryFinalize: Bool
    public var signWithTapInternalKey: Bool
    public var allowGrinding: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(trustWitnessUtxo: Bool, assumeHeight: UInt32?, allowAllSighashes: Bool, removePartialSigs: Bool, tryFinalize: Bool, signWithTapInternalKey: Bool, allowGrinding: Bool) {
        self.trustWitnessUtxo = trustWitnessUtxo
        self.assumeHeight = assumeHeight
        self.allowAllSighashes = allowAllSighashes
        self.removePartialSigs = removePartialSigs
        self.tryFinalize = tryFinalize
        self.signWithTapInternalKey = signWithTapInternalKey
        self.allowGrinding = allowGrinding
    }
}



extension SignOptions: Equatable, Hashable {
    public static func ==(lhs: SignOptions, rhs: SignOptions) -> Bool {
        if lhs.trustWitnessUtxo != rhs.trustWitnessUtxo {
            return false
        }
        if lhs.assumeHeight != rhs.assumeHeight {
            return false
        }
        if lhs.allowAllSighashes != rhs.allowAllSighashes {
            return false
        }
        if lhs.removePartialSigs != rhs.removePartialSigs {
            return false
        }
        if lhs.tryFinalize != rhs.tryFinalize {
            return false
        }
        if lhs.signWithTapInternalKey != rhs.signWithTapInternalKey {
            return false
        }
        if lhs.allowGrinding != rhs.allowGrinding {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(trustWitnessUtxo)
        hasher.combine(assumeHeight)
        hasher.combine(allowAllSighashes)
        hasher.combine(removePartialSigs)
        hasher.combine(tryFinalize)
        hasher.combine(signWithTapInternalKey)
        hasher.combine(allowGrinding)
    }
}


public struct FfiConverterTypeSignOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignOptions {
        return
            try SignOptions(
                trustWitnessUtxo: FfiConverterBool.read(from: &buf), 
                assumeHeight: FfiConverterOptionUInt32.read(from: &buf), 
                allowAllSighashes: FfiConverterBool.read(from: &buf), 
                removePartialSigs: FfiConverterBool.read(from: &buf), 
                tryFinalize: FfiConverterBool.read(from: &buf), 
                signWithTapInternalKey: FfiConverterBool.read(from: &buf), 
                allowGrinding: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: SignOptions, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.trustWitnessUtxo, into: &buf)
        FfiConverterOptionUInt32.write(value.assumeHeight, into: &buf)
        FfiConverterBool.write(value.allowAllSighashes, into: &buf)
        FfiConverterBool.write(value.removePartialSigs, into: &buf)
        FfiConverterBool.write(value.tryFinalize, into: &buf)
        FfiConverterBool.write(value.signWithTapInternalKey, into: &buf)
        FfiConverterBool.write(value.allowGrinding, into: &buf)
    }
}


public func FfiConverterTypeSignOptions_lift(_ buf: RustBuffer) throws -> SignOptions {
    return try FfiConverterTypeSignOptions.lift(buf)
}

public func FfiConverterTypeSignOptions_lower(_ value: SignOptions) -> RustBuffer {
    return FfiConverterTypeSignOptions.lower(value)
}


public struct SledDbConfiguration {
    public var path: String
    public var treeName: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(path: String, treeName: String) {
        self.path = path
        self.treeName = treeName
    }
}



extension SledDbConfiguration: Equatable, Hashable {
    public static func ==(lhs: SledDbConfiguration, rhs: SledDbConfiguration) -> Bool {
        if lhs.path != rhs.path {
            return false
        }
        if lhs.treeName != rhs.treeName {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(path)
        hasher.combine(treeName)
    }
}


public struct FfiConverterTypeSledDbConfiguration: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SledDbConfiguration {
        return
            try SledDbConfiguration(
                path: FfiConverterString.read(from: &buf), 
                treeName: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SledDbConfiguration, into buf: inout [UInt8]) {
        FfiConverterString.write(value.path, into: &buf)
        FfiConverterString.write(value.treeName, into: &buf)
    }
}


public func FfiConverterTypeSledDbConfiguration_lift(_ buf: RustBuffer) throws -> SledDbConfiguration {
    return try FfiConverterTypeSledDbConfiguration.lift(buf)
}

public func FfiConverterTypeSledDbConfiguration_lower(_ value: SledDbConfiguration) -> RustBuffer {
    return FfiConverterTypeSledDbConfiguration.lower(value)
}


public struct SqliteDbConfiguration {
    public var path: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(path: String) {
        self.path = path
    }
}



extension SqliteDbConfiguration: Equatable, Hashable {
    public static func ==(lhs: SqliteDbConfiguration, rhs: SqliteDbConfiguration) -> Bool {
        if lhs.path != rhs.path {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(path)
    }
}


public struct FfiConverterTypeSqliteDbConfiguration: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SqliteDbConfiguration {
        return
            try SqliteDbConfiguration(
                path: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SqliteDbConfiguration, into buf: inout [UInt8]) {
        FfiConverterString.write(value.path, into: &buf)
    }
}


public func FfiConverterTypeSqliteDbConfiguration_lift(_ buf: RustBuffer) throws -> SqliteDbConfiguration {
    return try FfiConverterTypeSqliteDbConfiguration.lift(buf)
}

public func FfiConverterTypeSqliteDbConfiguration_lower(_ value: SqliteDbConfiguration) -> RustBuffer {
    return FfiConverterTypeSqliteDbConfiguration.lower(value)
}


public struct TransactionDetails {
    public var transaction: Transaction?
    public var fee: UInt64?
    public var received: UInt64
    public var sent: UInt64
    public var txid: String
    public var confirmationTime: BlockTime?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(transaction: Transaction?, fee: UInt64?, received: UInt64, sent: UInt64, txid: String, confirmationTime: BlockTime?) {
        self.transaction = transaction
        self.fee = fee
        self.received = received
        self.sent = sent
        self.txid = txid
        self.confirmationTime = confirmationTime
    }
}



public struct FfiConverterTypeTransactionDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionDetails {
        return
            try TransactionDetails(
                transaction: FfiConverterOptionTypeTransaction.read(from: &buf), 
                fee: FfiConverterOptionUInt64.read(from: &buf), 
                received: FfiConverterUInt64.read(from: &buf), 
                sent: FfiConverterUInt64.read(from: &buf), 
                txid: FfiConverterString.read(from: &buf), 
                confirmationTime: FfiConverterOptionTypeBlockTime.read(from: &buf)
        )
    }

    public static func write(_ value: TransactionDetails, into buf: inout [UInt8]) {
        FfiConverterOptionTypeTransaction.write(value.transaction, into: &buf)
        FfiConverterOptionUInt64.write(value.fee, into: &buf)
        FfiConverterUInt64.write(value.received, into: &buf)
        FfiConverterUInt64.write(value.sent, into: &buf)
        FfiConverterString.write(value.txid, into: &buf)
        FfiConverterOptionTypeBlockTime.write(value.confirmationTime, into: &buf)
    }
}


public func FfiConverterTypeTransactionDetails_lift(_ buf: RustBuffer) throws -> TransactionDetails {
    return try FfiConverterTypeTransactionDetails.lift(buf)
}

public func FfiConverterTypeTransactionDetails_lower(_ value: TransactionDetails) -> RustBuffer {
    return FfiConverterTypeTransactionDetails.lower(value)
}


public struct TxBuilderResult {
    public var psbt: PartiallySignedTransaction
    public var transactionDetails: TransactionDetails

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(psbt: PartiallySignedTransaction, transactionDetails: TransactionDetails) {
        self.psbt = psbt
        self.transactionDetails = transactionDetails
    }
}



public struct FfiConverterTypeTxBuilderResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxBuilderResult {
        return
            try TxBuilderResult(
                psbt: FfiConverterTypePartiallySignedTransaction.read(from: &buf), 
                transactionDetails: FfiConverterTypeTransactionDetails.read(from: &buf)
        )
    }

    public static func write(_ value: TxBuilderResult, into buf: inout [UInt8]) {
        FfiConverterTypePartiallySignedTransaction.write(value.psbt, into: &buf)
        FfiConverterTypeTransactionDetails.write(value.transactionDetails, into: &buf)
    }
}


public func FfiConverterTypeTxBuilderResult_lift(_ buf: RustBuffer) throws -> TxBuilderResult {
    return try FfiConverterTypeTxBuilderResult.lift(buf)
}

public func FfiConverterTypeTxBuilderResult_lower(_ value: TxBuilderResult) -> RustBuffer {
    return FfiConverterTypeTxBuilderResult.lower(value)
}


public struct TxIn {
    public var previousOutput: OutPoint
    public var scriptSig: Script
    public var sequence: UInt32
    public var witness: [[UInt8]]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(previousOutput: OutPoint, scriptSig: Script, sequence: UInt32, witness: [[UInt8]]) {
        self.previousOutput = previousOutput
        self.scriptSig = scriptSig
        self.sequence = sequence
        self.witness = witness
    }
}



public struct FfiConverterTypeTxIn: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxIn {
        return
            try TxIn(
                previousOutput: FfiConverterTypeOutPoint.read(from: &buf), 
                scriptSig: FfiConverterTypeScript.read(from: &buf), 
                sequence: FfiConverterUInt32.read(from: &buf), 
                witness: FfiConverterSequenceSequenceUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: TxIn, into buf: inout [UInt8]) {
        FfiConverterTypeOutPoint.write(value.previousOutput, into: &buf)
        FfiConverterTypeScript.write(value.scriptSig, into: &buf)
        FfiConverterUInt32.write(value.sequence, into: &buf)
        FfiConverterSequenceSequenceUInt8.write(value.witness, into: &buf)
    }
}


public func FfiConverterTypeTxIn_lift(_ buf: RustBuffer) throws -> TxIn {
    return try FfiConverterTypeTxIn.lift(buf)
}

public func FfiConverterTypeTxIn_lower(_ value: TxIn) -> RustBuffer {
    return FfiConverterTypeTxIn.lower(value)
}


public struct TxOut {
    public var value: UInt64
    public var scriptPubkey: Script

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: UInt64, scriptPubkey: Script) {
        self.value = value
        self.scriptPubkey = scriptPubkey
    }
}



public struct FfiConverterTypeTxOut: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxOut {
        return
            try TxOut(
                value: FfiConverterUInt64.read(from: &buf), 
                scriptPubkey: FfiConverterTypeScript.read(from: &buf)
        )
    }

    public static func write(_ value: TxOut, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.value, into: &buf)
        FfiConverterTypeScript.write(value.scriptPubkey, into: &buf)
    }
}


public func FfiConverterTypeTxOut_lift(_ buf: RustBuffer) throws -> TxOut {
    return try FfiConverterTypeTxOut.lift(buf)
}

public func FfiConverterTypeTxOut_lower(_ value: TxOut) -> RustBuffer {
    return FfiConverterTypeTxOut.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AddressIndex {
    
    case new
    case lastUnused
    case peek(index: UInt32
    )
    case reset(index: UInt32
    )
}


public struct FfiConverterTypeAddressIndex: FfiConverterRustBuffer {
    typealias SwiftType = AddressIndex

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressIndex {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .new
        
        case 2: return .lastUnused
        
        case 3: return .peek(index: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 4: return .reset(index: try FfiConverterUInt32.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AddressIndex, into buf: inout [UInt8]) {
        switch value {
        
        
        case .new:
            writeInt(&buf, Int32(1))
        
        
        case .lastUnused:
            writeInt(&buf, Int32(2))
        
        
        case let .peek(index):
            writeInt(&buf, Int32(3))
            FfiConverterUInt32.write(index, into: &buf)
            
        
        case let .reset(index):
            writeInt(&buf, Int32(4))
            FfiConverterUInt32.write(index, into: &buf)
            
        }
    }
}


public func FfiConverterTypeAddressIndex_lift(_ buf: RustBuffer) throws -> AddressIndex {
    return try FfiConverterTypeAddressIndex.lift(buf)
}

public func FfiConverterTypeAddressIndex_lower(_ value: AddressIndex) -> RustBuffer {
    return FfiConverterTypeAddressIndex.lower(value)
}



extension AddressIndex: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Auth {
    
    case none
    case userPass(username: String, password: String
    )
    case cookie(file: String
    )
}


public struct FfiConverterTypeAuth: FfiConverterRustBuffer {
    typealias SwiftType = Auth

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Auth {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .none
        
        case 2: return .userPass(username: try FfiConverterString.read(from: &buf), password: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .cookie(file: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Auth, into buf: inout [UInt8]) {
        switch value {
        
        
        case .none:
            writeInt(&buf, Int32(1))
        
        
        case let .userPass(username,password):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(username, into: &buf)
            FfiConverterString.write(password, into: &buf)
            
        
        case let .cookie(file):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(file, into: &buf)
            
        }
    }
}


public func FfiConverterTypeAuth_lift(_ buf: RustBuffer) throws -> Auth {
    return try FfiConverterTypeAuth.lift(buf)
}

public func FfiConverterTypeAuth_lower(_ value: Auth) -> RustBuffer {
    return FfiConverterTypeAuth.lower(value)
}



extension Auth: Equatable, Hashable {}




public enum BdkError {

    
    
    case InvalidU32Bytes(message: String)
    
    case Generic(message: String)
    
    case MissingCachedScripts(message: String)
    
    case ScriptDoesntHaveAddressForm(message: String)
    
    case NoRecipients(message: String)
    
    case NoUtxosSelected(message: String)
    
    case OutputBelowDustLimit(message: String)
    
    case InsufficientFunds(message: String)
    
    case BnBTotalTriesExceeded(message: String)
    
    case BnBNoExactMatch(message: String)
    
    case UnknownUtxo(message: String)
    
    case TransactionNotFound(message: String)
    
    case TransactionConfirmed(message: String)
    
    case IrreplaceableTransaction(message: String)
    
    case FeeRateTooLow(message: String)
    
    case FeeTooLow(message: String)
    
    case FeeRateUnavailable(message: String)
    
    case MissingKeyOrigin(message: String)
    
    case Key(message: String)
    
    case ChecksumMismatch(message: String)
    
    case SpendingPolicyRequired(message: String)
    
    case InvalidPolicyPathError(message: String)
    
    case Signer(message: String)
    
    case InvalidNetwork(message: String)
    
    case InvalidProgressValue(message: String)
    
    case ProgressUpdateError(message: String)
    
    case InvalidOutpoint(message: String)
    
    case Descriptor(message: String)
    
    case Encode(message: String)
    
    case Miniscript(message: String)
    
    case MiniscriptPsbt(message: String)
    
    case Bip32(message: String)
    
    case Secp256k1(message: String)
    
    case Json(message: String)
    
    case Hex(message: String)
    
    case Psbt(message: String)
    
    case PsbtParse(message: String)
    
    case Electrum(message: String)
    
    case Esplora(message: String)
    
    case Sled(message: String)
    
    case Rusqlite(message: String)
    
    case Rpc(message: String)
    
    case HardenedIndex(message: String)
    
}


public struct FfiConverterTypeBdkError: FfiConverterRustBuffer {
    typealias SwiftType = BdkError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BdkError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidU32Bytes(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .MissingCachedScripts(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .ScriptDoesntHaveAddressForm(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .NoRecipients(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .NoUtxosSelected(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .OutputBelowDustLimit(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .InsufficientFunds(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .BnBTotalTriesExceeded(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .BnBNoExactMatch(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 11: return .UnknownUtxo(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 12: return .TransactionNotFound(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 13: return .TransactionConfirmed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 14: return .IrreplaceableTransaction(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 15: return .FeeRateTooLow(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 16: return .FeeTooLow(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 17: return .FeeRateUnavailable(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 18: return .MissingKeyOrigin(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 19: return .Key(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 20: return .ChecksumMismatch(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 21: return .SpendingPolicyRequired(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 22: return .InvalidPolicyPathError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 23: return .Signer(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 24: return .InvalidNetwork(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 25: return .InvalidProgressValue(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 26: return .ProgressUpdateError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 27: return .InvalidOutpoint(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 28: return .Descriptor(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 29: return .Encode(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 30: return .Miniscript(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 31: return .MiniscriptPsbt(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 32: return .Bip32(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 33: return .Secp256k1(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 34: return .Json(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 35: return .Hex(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 36: return .Psbt(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 37: return .PsbtParse(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 38: return .Electrum(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 39: return .Esplora(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 40: return .Sled(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 41: return .Rusqlite(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 42: return .Rpc(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 43: return .HardenedIndex(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BdkError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .InvalidU32Bytes(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .Generic(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .MissingCachedScripts(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .ScriptDoesntHaveAddressForm(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .NoRecipients(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .NoUtxosSelected(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))
        case .OutputBelowDustLimit(_ /* message is ignored*/):
            writeInt(&buf, Int32(7))
        case .InsufficientFunds(_ /* message is ignored*/):
            writeInt(&buf, Int32(8))
        case .BnBTotalTriesExceeded(_ /* message is ignored*/):
            writeInt(&buf, Int32(9))
        case .BnBNoExactMatch(_ /* message is ignored*/):
            writeInt(&buf, Int32(10))
        case .UnknownUtxo(_ /* message is ignored*/):
            writeInt(&buf, Int32(11))
        case .TransactionNotFound(_ /* message is ignored*/):
            writeInt(&buf, Int32(12))
        case .TransactionConfirmed(_ /* message is ignored*/):
            writeInt(&buf, Int32(13))
        case .IrreplaceableTransaction(_ /* message is ignored*/):
            writeInt(&buf, Int32(14))
        case .FeeRateTooLow(_ /* message is ignored*/):
            writeInt(&buf, Int32(15))
        case .FeeTooLow(_ /* message is ignored*/):
            writeInt(&buf, Int32(16))
        case .FeeRateUnavailable(_ /* message is ignored*/):
            writeInt(&buf, Int32(17))
        case .MissingKeyOrigin(_ /* message is ignored*/):
            writeInt(&buf, Int32(18))
        case .Key(_ /* message is ignored*/):
            writeInt(&buf, Int32(19))
        case .ChecksumMismatch(_ /* message is ignored*/):
            writeInt(&buf, Int32(20))
        case .SpendingPolicyRequired(_ /* message is ignored*/):
            writeInt(&buf, Int32(21))
        case .InvalidPolicyPathError(_ /* message is ignored*/):
            writeInt(&buf, Int32(22))
        case .Signer(_ /* message is ignored*/):
            writeInt(&buf, Int32(23))
        case .InvalidNetwork(_ /* message is ignored*/):
            writeInt(&buf, Int32(24))
        case .InvalidProgressValue(_ /* message is ignored*/):
            writeInt(&buf, Int32(25))
        case .ProgressUpdateError(_ /* message is ignored*/):
            writeInt(&buf, Int32(26))
        case .InvalidOutpoint(_ /* message is ignored*/):
            writeInt(&buf, Int32(27))
        case .Descriptor(_ /* message is ignored*/):
            writeInt(&buf, Int32(28))
        case .Encode(_ /* message is ignored*/):
            writeInt(&buf, Int32(29))
        case .Miniscript(_ /* message is ignored*/):
            writeInt(&buf, Int32(30))
        case .MiniscriptPsbt(_ /* message is ignored*/):
            writeInt(&buf, Int32(31))
        case .Bip32(_ /* message is ignored*/):
            writeInt(&buf, Int32(32))
        case .Secp256k1(_ /* message is ignored*/):
            writeInt(&buf, Int32(33))
        case .Json(_ /* message is ignored*/):
            writeInt(&buf, Int32(34))
        case .Hex(_ /* message is ignored*/):
            writeInt(&buf, Int32(35))
        case .Psbt(_ /* message is ignored*/):
            writeInt(&buf, Int32(36))
        case .PsbtParse(_ /* message is ignored*/):
            writeInt(&buf, Int32(37))
        case .Electrum(_ /* message is ignored*/):
            writeInt(&buf, Int32(38))
        case .Esplora(_ /* message is ignored*/):
            writeInt(&buf, Int32(39))
        case .Sled(_ /* message is ignored*/):
            writeInt(&buf, Int32(40))
        case .Rusqlite(_ /* message is ignored*/):
            writeInt(&buf, Int32(41))
        case .Rpc(_ /* message is ignored*/):
            writeInt(&buf, Int32(42))
        case .HardenedIndex(_ /* message is ignored*/):
            writeInt(&buf, Int32(43))

        
        }
    }
}


extension BdkError: Equatable, Hashable {}

extension BdkError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum BlockchainConfig {
    
    case electrum(config: ElectrumConfig
    )
    case esplora(config: EsploraConfig
    )
    case rpc(config: RpcConfig
    )
}


public struct FfiConverterTypeBlockchainConfig: FfiConverterRustBuffer {
    typealias SwiftType = BlockchainConfig

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlockchainConfig {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .electrum(config: try FfiConverterTypeElectrumConfig.read(from: &buf)
        )
        
        case 2: return .esplora(config: try FfiConverterTypeEsploraConfig.read(from: &buf)
        )
        
        case 3: return .rpc(config: try FfiConverterTypeRpcConfig.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BlockchainConfig, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .electrum(config):
            writeInt(&buf, Int32(1))
            FfiConverterTypeElectrumConfig.write(config, into: &buf)
            
        
        case let .esplora(config):
            writeInt(&buf, Int32(2))
            FfiConverterTypeEsploraConfig.write(config, into: &buf)
            
        
        case let .rpc(config):
            writeInt(&buf, Int32(3))
            FfiConverterTypeRpcConfig.write(config, into: &buf)
            
        }
    }
}


public func FfiConverterTypeBlockchainConfig_lift(_ buf: RustBuffer) throws -> BlockchainConfig {
    return try FfiConverterTypeBlockchainConfig.lift(buf)
}

public func FfiConverterTypeBlockchainConfig_lower(_ value: BlockchainConfig) -> RustBuffer {
    return FfiConverterTypeBlockchainConfig.lower(value)
}



extension BlockchainConfig: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DatabaseConfig {
    
    case memory
    case sled(config: SledDbConfiguration
    )
    case sqlite(config: SqliteDbConfiguration
    )
}


public struct FfiConverterTypeDatabaseConfig: FfiConverterRustBuffer {
    typealias SwiftType = DatabaseConfig

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DatabaseConfig {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .memory
        
        case 2: return .sled(config: try FfiConverterTypeSledDbConfiguration.read(from: &buf)
        )
        
        case 3: return .sqlite(config: try FfiConverterTypeSqliteDbConfiguration.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DatabaseConfig, into buf: inout [UInt8]) {
        switch value {
        
        
        case .memory:
            writeInt(&buf, Int32(1))
        
        
        case let .sled(config):
            writeInt(&buf, Int32(2))
            FfiConverterTypeSledDbConfiguration.write(config, into: &buf)
            
        
        case let .sqlite(config):
            writeInt(&buf, Int32(3))
            FfiConverterTypeSqliteDbConfiguration.write(config, into: &buf)
            
        }
    }
}


public func FfiConverterTypeDatabaseConfig_lift(_ buf: RustBuffer) throws -> DatabaseConfig {
    return try FfiConverterTypeDatabaseConfig.lift(buf)
}

public func FfiConverterTypeDatabaseConfig_lower(_ value: DatabaseConfig) -> RustBuffer {
    return FfiConverterTypeDatabaseConfig.lower(value)
}



extension DatabaseConfig: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum KeychainKind {
    
    case external
    case `internal`
}


public struct FfiConverterTypeKeychainKind: FfiConverterRustBuffer {
    typealias SwiftType = KeychainKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeychainKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .external
        
        case 2: return .`internal`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: KeychainKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .external:
            writeInt(&buf, Int32(1))
        
        
        case .`internal`:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeKeychainKind_lift(_ buf: RustBuffer) throws -> KeychainKind {
    return try FfiConverterTypeKeychainKind.lift(buf)
}

public func FfiConverterTypeKeychainKind_lower(_ value: KeychainKind) -> RustBuffer {
    return FfiConverterTypeKeychainKind.lower(value)
}



extension KeychainKind: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Network {
    
    case bitcoin
    case testnet
    case signet
    case regtest
}


public struct FfiConverterTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = Network

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Network {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoin
        
        case 2: return .testnet
        
        case 3: return .signet
        
        case 4: return .regtest
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Network, into buf: inout [UInt8]) {
        switch value {
        
        
        case .bitcoin:
            writeInt(&buf, Int32(1))
        
        
        case .testnet:
            writeInt(&buf, Int32(2))
        
        
        case .signet:
            writeInt(&buf, Int32(3))
        
        
        case .regtest:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeNetwork_lift(_ buf: RustBuffer) throws -> Network {
    return try FfiConverterTypeNetwork.lift(buf)
}

public func FfiConverterTypeNetwork_lower(_ value: Network) -> RustBuffer {
    return FfiConverterTypeNetwork.lower(value)
}



extension Network: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Payload {
    
    case pubkeyHash(pubkeyHash: String
    )
    case scriptHash(scriptHash: String
    )
    case witnessProgram(version: WitnessVersion, program: [UInt8]
    )
}


public struct FfiConverterTypePayload: FfiConverterRustBuffer {
    typealias SwiftType = Payload

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Payload {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .pubkeyHash(pubkeyHash: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .scriptHash(scriptHash: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .witnessProgram(version: try FfiConverterTypeWitnessVersion.read(from: &buf), program: try FfiConverterSequenceUInt8.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Payload, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .pubkeyHash(pubkeyHash):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(pubkeyHash, into: &buf)
            
        
        case let .scriptHash(scriptHash):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(scriptHash, into: &buf)
            
        
        case let .witnessProgram(version,program):
            writeInt(&buf, Int32(3))
            FfiConverterTypeWitnessVersion.write(version, into: &buf)
            FfiConverterSequenceUInt8.write(program, into: &buf)
            
        }
    }
}


public func FfiConverterTypePayload_lift(_ buf: RustBuffer) throws -> Payload {
    return try FfiConverterTypePayload.lift(buf)
}

public func FfiConverterTypePayload_lower(_ value: Payload) -> RustBuffer {
    return FfiConverterTypePayload.lower(value)
}



extension Payload: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WitnessVersion {
    
    case v0
    case v1
    case v2
    case v3
    case v4
    case v5
    case v6
    case v7
    case v8
    case v9
    case v10
    case v11
    case v12
    case v13
    case v14
    case v15
    case v16
}


public struct FfiConverterTypeWitnessVersion: FfiConverterRustBuffer {
    typealias SwiftType = WitnessVersion

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WitnessVersion {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .v0
        
        case 2: return .v1
        
        case 3: return .v2
        
        case 4: return .v3
        
        case 5: return .v4
        
        case 6: return .v5
        
        case 7: return .v6
        
        case 8: return .v7
        
        case 9: return .v8
        
        case 10: return .v9
        
        case 11: return .v10
        
        case 12: return .v11
        
        case 13: return .v12
        
        case 14: return .v13
        
        case 15: return .v14
        
        case 16: return .v15
        
        case 17: return .v16
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WitnessVersion, into buf: inout [UInt8]) {
        switch value {
        
        
        case .v0:
            writeInt(&buf, Int32(1))
        
        
        case .v1:
            writeInt(&buf, Int32(2))
        
        
        case .v2:
            writeInt(&buf, Int32(3))
        
        
        case .v3:
            writeInt(&buf, Int32(4))
        
        
        case .v4:
            writeInt(&buf, Int32(5))
        
        
        case .v5:
            writeInt(&buf, Int32(6))
        
        
        case .v6:
            writeInt(&buf, Int32(7))
        
        
        case .v7:
            writeInt(&buf, Int32(8))
        
        
        case .v8:
            writeInt(&buf, Int32(9))
        
        
        case .v9:
            writeInt(&buf, Int32(10))
        
        
        case .v10:
            writeInt(&buf, Int32(11))
        
        
        case .v11:
            writeInt(&buf, Int32(12))
        
        
        case .v12:
            writeInt(&buf, Int32(13))
        
        
        case .v13:
            writeInt(&buf, Int32(14))
        
        
        case .v14:
            writeInt(&buf, Int32(15))
        
        
        case .v15:
            writeInt(&buf, Int32(16))
        
        
        case .v16:
            writeInt(&buf, Int32(17))
        
        }
    }
}


public func FfiConverterTypeWitnessVersion_lift(_ buf: RustBuffer) throws -> WitnessVersion {
    return try FfiConverterTypeWitnessVersion.lift(buf)
}

public func FfiConverterTypeWitnessVersion_lower(_ value: WitnessVersion) -> RustBuffer {
    return FfiConverterTypeWitnessVersion.lower(value)
}



extension WitnessVersion: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WordCount {
    
    case words12
    case words15
    case words18
    case words21
    case words24
}


public struct FfiConverterTypeWordCount: FfiConverterRustBuffer {
    typealias SwiftType = WordCount

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WordCount {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .words12
        
        case 2: return .words15
        
        case 3: return .words18
        
        case 4: return .words21
        
        case 5: return .words24
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WordCount, into buf: inout [UInt8]) {
        switch value {
        
        
        case .words12:
            writeInt(&buf, Int32(1))
        
        
        case .words15:
            writeInt(&buf, Int32(2))
        
        
        case .words18:
            writeInt(&buf, Int32(3))
        
        
        case .words21:
            writeInt(&buf, Int32(4))
        
        
        case .words24:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeWordCount_lift(_ buf: RustBuffer) throws -> WordCount {
    return try FfiConverterTypeWordCount.lift(buf)
}

public func FfiConverterTypeWordCount_lower(_ value: WordCount) -> RustBuffer {
    return FfiConverterTypeWordCount.lower(value)
}



extension WordCount: Equatable, Hashable {}






public protocol Progress : AnyObject {
    
    func update(progress: Float, message: String?) 
    
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceProgress {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceProgress = UniffiVTableCallbackInterfaceProgress(
        update: { (
            uniffiHandle: UInt64,
            progress: Float,
            message: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceProgress.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.update(
                     progress: try FfiConverterFloat.lift(progress),
                     message: try FfiConverterOptionString.lift(message)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceProgress.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface Progress: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitProgress() {
    uniffi_bdkffi_fn_init_callback_vtable_progress(&UniffiCallbackInterfaceProgress.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceProgress {
    fileprivate static var handleMap = UniffiHandleMap<Progress>()
}

extension FfiConverterCallbackInterfaceProgress : FfiConverter {
    typealias SwiftType = Progress
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

fileprivate struct FfiConverterOptionUInt8: FfiConverterRustBuffer {
    typealias SwiftType = UInt8?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt8.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt8.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeDescriptor: FfiConverterRustBuffer {
    typealias SwiftType = Descriptor?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDescriptor.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDescriptor.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeFeeRate: FfiConverterRustBuffer {
    typealias SwiftType = FeeRate?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFeeRate.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFeeRate.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeTransaction: FfiConverterRustBuffer {
    typealias SwiftType = Transaction?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTransaction.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTransaction.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeBlockTime: FfiConverterRustBuffer {
    typealias SwiftType = BlockTime?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBlockTime.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBlockTime.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRpcSyncParams: FfiConverterRustBuffer {
    typealias SwiftType = RpcSyncParams?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRpcSyncParams.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRpcSyncParams.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSignOptions: FfiConverterRustBuffer {
    typealias SwiftType = SignOptions?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSignOptions.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSignOptions.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionCallbackInterfaceProgress: FfiConverterRustBuffer {
    typealias SwiftType = Progress?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceProgress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceProgress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]

    public static func write(_ value: [UInt8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt8.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeLocalUtxo: FfiConverterRustBuffer {
    typealias SwiftType = [LocalUtxo]

    public static func write(_ value: [LocalUtxo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLocalUtxo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LocalUtxo] {
        let len: Int32 = try readInt(&buf)
        var seq = [LocalUtxo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLocalUtxo.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeOutPoint: FfiConverterRustBuffer {
    typealias SwiftType = [OutPoint]

    public static func write(_ value: [OutPoint], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeOutPoint.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [OutPoint] {
        let len: Int32 = try readInt(&buf)
        var seq = [OutPoint]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeOutPoint.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeScriptAmount: FfiConverterRustBuffer {
    typealias SwiftType = [ScriptAmount]

    public static func write(_ value: [ScriptAmount], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeScriptAmount.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ScriptAmount] {
        let len: Int32 = try readInt(&buf)
        var seq = [ScriptAmount]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeScriptAmount.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTransactionDetails: FfiConverterRustBuffer {
    typealias SwiftType = [TransactionDetails]

    public static func write(_ value: [TransactionDetails], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTransactionDetails.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TransactionDetails] {
        let len: Int32 = try readInt(&buf)
        var seq = [TransactionDetails]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTransactionDetails.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTxIn: FfiConverterRustBuffer {
    typealias SwiftType = [TxIn]

    public static func write(_ value: [TxIn], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTxIn.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TxIn] {
        let len: Int32 = try readInt(&buf)
        var seq = [TxIn]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTxIn.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTxOut: FfiConverterRustBuffer {
    typealias SwiftType = [TxOut]

    public static func write(_ value: [TxOut], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTxOut.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TxOut] {
        let len: Int32 = try readInt(&buf)
        var seq = [TxOut]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTxOut.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [[UInt8]]

    public static func write(_ value: [[UInt8]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterSequenceUInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[UInt8]] {
        let len: Int32 = try readInt(&buf)
        var seq = [[UInt8]]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterSequenceUInt8.read(from: &buf))
        }
        return seq
    }
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_bdkffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_bdkffi_checksum_method_address_as_string() != 26179) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_address_is_valid_for_network() != 10350) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_address_network() != 33317) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_address_payload() != 29657) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_address_script_pubkey() != 10722) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_address_to_qr_uri() != 48141) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_blockchain_broadcast() != 34917) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_blockchain_estimate_fee() != 15613) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_blockchain_get_block_hash() != 11615) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_blockchain_get_height() != 34657) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_blockchain_get_tx() != 29310) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_bumpfeetxbuilder_allow_shrinking() != 57772) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_bumpfeetxbuilder_enable_rbf() != 30060) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_bumpfeetxbuilder_enable_rbf_with_sequence() != 3682) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_bumpfeetxbuilder_finish() != 63571) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptor_as_string() != 23756) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptor_as_string_private() != 64930) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptorpublickey_as_string() != 37256) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptorpublickey_derive() != 37338) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptorpublickey_extend() != 46199) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptorsecretkey_as_public() != 56954) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptorsecretkey_as_string() != 28335) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptorsecretkey_derive() != 44428) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptorsecretkey_extend() != 46796) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptorsecretkey_secret_bytes() != 40876) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_feerate_as_sat_per_vb() != 60213) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_mnemonic_as_string() != 3181) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_partiallysignedtransaction_combine() != 22013) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_partiallysignedtransaction_extract_tx() != 10768) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_partiallysignedtransaction_fee_amount() != 51074) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_partiallysignedtransaction_fee_rate() != 53236) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_partiallysignedtransaction_json_serialize() != 42145) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_partiallysignedtransaction_serialize() != 39126) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_partiallysignedtransaction_txid() != 60285) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_script_to_bytes() != 31368) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_input() != 5374) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_is_coin_base() != 42930) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_is_explicitly_rbf() != 32682) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_is_lock_time_enabled() != 48885) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_lock_time() != 49321) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_output() != 30237) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_serialize() != 62862) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_size() != 63453) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_txid() != 29904) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_version() != 15271) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_vsize() != 3804) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_weight() != 21879) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_add_data() != 7385) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_add_recipient() != 52335) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_add_unspendable() != 33319) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_add_utxo() != 43637) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_add_utxos() != 34089) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_do_not_spend_change() != 51770) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_drain_to() != 58882) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_drain_wallet() != 5081) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_enable_rbf() != 38825) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_enable_rbf_with_sequence() != 26979) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_fee_absolute() != 3622) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_fee_rate() != 62655) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_finish() != 17491) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_manually_selected_only() != 12623) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_only_spend_change() != 18757) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_set_recipients() != 20461) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_unspendable() != 49004) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_get_address() != 52401) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_get_balance() != 10566) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_get_internal_address() != 5308) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_is_mine() != 10955) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_list_transactions() != 18014) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_list_unspent() != 42342) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_network() != 32197) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_sign() != 53268) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_sync() != 52330) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_address_from_script() != 51133) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_address_new() != 33853) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_blockchain_new() != 36607) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_bumpfeetxbuilder_new() != 52889) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_derivationpath_new() != 57618) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptor_new() != 57144) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptor_new_bip44() != 44216) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptor_new_bip44_public() != 55284) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptor_new_bip49() != 10038) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptor_new_bip49_public() != 14422) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptor_new_bip84() != 4773) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptor_new_bip84_public() != 45733) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptor_new_bip86() != 42468) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptor_new_bip86_public() != 60819) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptorpublickey_from_string() != 26782) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptorsecretkey_from_string() != 53598) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptorsecretkey_new() != 61342) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_feerate_from_sat_per_vb() != 6833) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_mnemonic_from_entropy() != 49208) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_mnemonic_from_string() != 40755) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_mnemonic_new() != 51578) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_partiallysignedtransaction_new() != 51370) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_script_new() != 43552) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_transaction_new() != 56229) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_txbuilder_new() != 6280) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_wallet_new() != 23901) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_progress_update() != 64474) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitProgress()
    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all