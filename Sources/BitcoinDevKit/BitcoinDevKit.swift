// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(BitcoinDevKitFFI)
import BitcoinDevKitFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_bdkffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_bdkffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureBdkffiInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterFloat: FfiConverterPrimitive {
    typealias FfiType = Float
    typealias SwiftType = Float

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Float {
        return try lift(readFloat(&buf))
    }

    public static func write(_ value: Float, into buf: inout [UInt8]) {
        writeFloat(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




/**
 * A bitcoin address
 */
public protocol AddressProtocol: AnyObject, Sendable {
    
    /**
     * Is the address valid for the provided network
     */
    func isValidForNetwork(network: Network)  -> Bool
    
    /**
     * Return the `scriptPubKey` underlying an address.
     */
    func scriptPubkey()  -> Script
    
    /**
     * Return the data for the address.
     */
    func toAddressData()  -> AddressData
    
    /**
     * Return a BIP-21 URI string for this address.
     */
    func toQrUri()  -> String
    
}
/**
 * A bitcoin address
 */
open class Address: AddressProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_address(self.pointer, $0) }
    }
    /**
     * Parse a string as an address for the given network.
     */
public convenience init(address: String, network: Network)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeAddressParseError_lift) {
    uniffi_bdkffi_fn_constructor_address_new(
        FfiConverterString.lower(address),
        FfiConverterTypeNetwork_lower(network),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_address(pointer, $0) }
    }

    
    /**
     * Parse a script as an address for the given network
     */
public static func fromScript(script: Script, network: Network)throws  -> Address  {
    return try  FfiConverterTypeAddress_lift(try rustCallWithError(FfiConverterTypeFromScriptError_lift) {
    uniffi_bdkffi_fn_constructor_address_from_script(
        FfiConverterTypeScript_lower(script),
        FfiConverterTypeNetwork_lower(network),$0
    )
})
}
    

    
    /**
     * Is the address valid for the provided network
     */
open func isValidForNetwork(network: Network) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_address_is_valid_for_network(self.uniffiClonePointer(),
        FfiConverterTypeNetwork_lower(network),$0
    )
})
}
    
    /**
     * Return the `scriptPubKey` underlying an address.
     */
open func scriptPubkey() -> Script  {
    return try!  FfiConverterTypeScript_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_address_script_pubkey(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the data for the address.
     */
open func toAddressData() -> AddressData  {
    return try!  FfiConverterTypeAddressData_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_address_to_address_data(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return a BIP-21 URI string for this address.
     */
open func toQrUri() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_address_to_qr_uri(self.uniffiClonePointer(),$0
    )
})
}
    
    open var description: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_address_uniffi_trait_display(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Address, other: Address) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_address_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeAddress_lower(other),$0
    )
}
        )
    }

}
extension Address: CustomStringConvertible {}
extension Address: Equatable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddress: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Address

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Address {
        return Address(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Address) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Address {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Address, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddress_lift(_ pointer: UnsafeMutableRawPointer) throws -> Address {
    return try FfiConverterTypeAddress.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddress_lower(_ value: Address) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAddress.lower(value)
}






/**
 * The Amount type can be used to express Bitcoin amounts that support arithmetic and conversion
 * to various denominations. The operations that Amount implements will panic when overflow or
 * underflow occurs. Also note that since the internal representation of amounts is unsigned,
 * subtracting below zero is considered an underflow and will cause a panic.
 */
public protocol AmountProtocol: AnyObject, Sendable {
    
    /**
     * Express this Amount as a floating-point value in Bitcoin. Please be aware of the risk of
     * using floating-point numbers.
     */
    func toBtc()  -> Double
    
    /**
     * Get the number of satoshis in this Amount.
     */
    func toSat()  -> UInt64
    
}
/**
 * The Amount type can be used to express Bitcoin amounts that support arithmetic and conversion
 * to various denominations. The operations that Amount implements will panic when overflow or
 * underflow occurs. Also note that since the internal representation of amounts is unsigned,
 * subtracting below zero is considered an underflow and will cause a panic.
 */
open class Amount: AmountProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_amount(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_amount(pointer, $0) }
    }

    
    /**
     * Convert from a value expressing bitcoins to an Amount.
     */
public static func fromBtc(btc: Double)throws  -> Amount  {
    return try  FfiConverterTypeAmount_lift(try rustCallWithError(FfiConverterTypeParseAmountError_lift) {
    uniffi_bdkffi_fn_constructor_amount_from_btc(
        FfiConverterDouble.lower(btc),$0
    )
})
}
    
    /**
     * Create an Amount with satoshi precision and the given number of satoshis.
     */
public static func fromSat(satoshi: UInt64) -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_amount_from_sat(
        FfiConverterUInt64.lower(satoshi),$0
    )
})
}
    

    
    /**
     * Express this Amount as a floating-point value in Bitcoin. Please be aware of the risk of
     * using floating-point numbers.
     */
open func toBtc() -> Double  {
    return try!  FfiConverterDouble.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_amount_to_btc(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get the number of satoshis in this Amount.
     */
open func toSat() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_amount_to_sat(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAmount: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Amount

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Amount {
        return Amount(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Amount) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Amount {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Amount, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAmount_lift(_ pointer: UnsafeMutableRawPointer) throws -> Amount {
    return try FfiConverterTypeAmount.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAmount_lower(_ value: Amount) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAmount.lower(value)
}






/**
 * A bitcoin Block hash
 */
public protocol BlockHashProtocol: AnyObject, Sendable {
    
    /**
     * Serialize this type into a 32 byte array.
     */
    func serialize()  -> Data
    
}
/**
 * A bitcoin Block hash
 */
open class BlockHash: BlockHashProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_blockhash(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_blockhash(pointer, $0) }
    }

    
    /**
     * Construct a hash-like type from 32 bytes.
     */
public static func fromBytes(bytes: Data)throws  -> BlockHash  {
    return try  FfiConverterTypeBlockHash_lift(try rustCallWithError(FfiConverterTypeHashParseError_lift) {
    uniffi_bdkffi_fn_constructor_blockhash_from_bytes(
        FfiConverterData.lower(bytes),$0
    )
})
}
    
    /**
     * Construct a hash-like type from a hex string.
     */
public static func fromString(hex: String)throws  -> BlockHash  {
    return try  FfiConverterTypeBlockHash_lift(try rustCallWithError(FfiConverterTypeHashParseError_lift) {
    uniffi_bdkffi_fn_constructor_blockhash_from_string(
        FfiConverterString.lower(hex),$0
    )
})
}
    

    
    /**
     * Serialize this type into a 32 byte array.
     */
open func serialize() -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_blockhash_serialize(self.uniffiClonePointer(),$0
    )
})
}
    
    open var description: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_blockhash_uniffi_trait_display(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: BlockHash, other: BlockHash) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_blockhash_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeBlockHash_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_blockhash_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension BlockHash: CustomStringConvertible {}
extension BlockHash: Equatable {}
extension BlockHash: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBlockHash: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BlockHash

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BlockHash {
        return BlockHash(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BlockHash) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlockHash {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BlockHash, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlockHash_lift(_ pointer: UnsafeMutableRawPointer) throws -> BlockHash {
    return try FfiConverterTypeBlockHash.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlockHash_lower(_ value: BlockHash) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBlockHash.lower(value)
}






/**
 * A `BumpFeeTxBuilder` is created by calling `build_fee_bump` on a wallet. After assigning it, you set options on it
 * until finally calling `finish` to consume the builder and generate the transaction.
 */
public protocol BumpFeeTxBuilderProtocol: AnyObject, Sendable {
    
    /**
     * Set whether the dust limit is checked.
     *
     * Note: by avoiding a dust limit check you may end up with a transaction that is non-standard.
     */
    func allowDust(allowDust: Bool)  -> BumpFeeTxBuilder
    
    /**
     * Set the current blockchain height.
     *
     * This will be used to:
     *
     * 1. Set the `nLockTime` for preventing fee sniping. Note: This will be ignored if you manually specify a
     * `nlocktime` using `TxBuilder::nlocktime`.
     *
     * 2. Decide whether coinbase outputs are mature or not. If the coinbase outputs are not mature at `current_height`,
     * we ignore them in the coin selection. If you want to create a transaction that spends immature coinbase inputs,
     * manually add them using `TxBuilder::add_utxos`.
     * In both cases, if you don’t provide a current height, we use the last sync height.
     */
    func currentHeight(height: UInt32)  -> BumpFeeTxBuilder
    
    /**
     * Finish building the transaction.
     *
     * Uses the thread-local random number generator (rng).
     *
     * Returns a new `Psbt` per BIP174.
     *
     * WARNING: To avoid change address reuse you must persist the changes resulting from one or more calls to this
     * method before closing the wallet. See `Wallet::reveal_next_address`.
     */
    func finish(wallet: Wallet) throws  -> Psbt
    
    /**
     * Use a specific nLockTime while creating the transaction.
     *
     * This can cause conflicts if the wallet’s descriptors contain an "after" (`OP_CLTV`) operator.
     */
    func nlocktime(locktime: LockTime)  -> BumpFeeTxBuilder
    
    /**
     * Set an exact `nSequence` value.
     *
     * This can cause conflicts if the wallet’s descriptors contain an "older" (`OP_CSV`) operator and the given
     * `nsequence` is lower than the CSV value.
     */
    func setExactSequence(nsequence: UInt32)  -> BumpFeeTxBuilder
    
    /**
     * Build a transaction with a specific version.
     *
     * The version should always be greater than 0 and greater than 1 if the wallet’s descriptors contain an "older"
     * (`OP_CSV`) operator.
     */
    func version(version: Int32)  -> BumpFeeTxBuilder
    
}
/**
 * A `BumpFeeTxBuilder` is created by calling `build_fee_bump` on a wallet. After assigning it, you set options on it
 * until finally calling `finish` to consume the builder and generate the transaction.
 */
open class BumpFeeTxBuilder: BumpFeeTxBuilderProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_bumpfeetxbuilder(self.pointer, $0) }
    }
public convenience init(txid: Txid, feeRate: FeeRate) {
    let pointer =
        try! rustCall() {
    uniffi_bdkffi_fn_constructor_bumpfeetxbuilder_new(
        FfiConverterTypeTxid_lower(txid),
        FfiConverterTypeFeeRate_lower(feeRate),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_bumpfeetxbuilder(pointer, $0) }
    }

    

    
    /**
     * Set whether the dust limit is checked.
     *
     * Note: by avoiding a dust limit check you may end up with a transaction that is non-standard.
     */
open func allowDust(allowDust: Bool) -> BumpFeeTxBuilder  {
    return try!  FfiConverterTypeBumpFeeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_bumpfeetxbuilder_allow_dust(self.uniffiClonePointer(),
        FfiConverterBool.lower(allowDust),$0
    )
})
}
    
    /**
     * Set the current blockchain height.
     *
     * This will be used to:
     *
     * 1. Set the `nLockTime` for preventing fee sniping. Note: This will be ignored if you manually specify a
     * `nlocktime` using `TxBuilder::nlocktime`.
     *
     * 2. Decide whether coinbase outputs are mature or not. If the coinbase outputs are not mature at `current_height`,
     * we ignore them in the coin selection. If you want to create a transaction that spends immature coinbase inputs,
     * manually add them using `TxBuilder::add_utxos`.
     * In both cases, if you don’t provide a current height, we use the last sync height.
     */
open func currentHeight(height: UInt32) -> BumpFeeTxBuilder  {
    return try!  FfiConverterTypeBumpFeeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_bumpfeetxbuilder_current_height(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(height),$0
    )
})
}
    
    /**
     * Finish building the transaction.
     *
     * Uses the thread-local random number generator (rng).
     *
     * Returns a new `Psbt` per BIP174.
     *
     * WARNING: To avoid change address reuse you must persist the changes resulting from one or more calls to this
     * method before closing the wallet. See `Wallet::reveal_next_address`.
     */
open func finish(wallet: Wallet)throws  -> Psbt  {
    return try  FfiConverterTypePsbt_lift(try rustCallWithError(FfiConverterTypeCreateTxError_lift) {
    uniffi_bdkffi_fn_method_bumpfeetxbuilder_finish(self.uniffiClonePointer(),
        FfiConverterTypeWallet_lower(wallet),$0
    )
})
}
    
    /**
     * Use a specific nLockTime while creating the transaction.
     *
     * This can cause conflicts if the wallet’s descriptors contain an "after" (`OP_CLTV`) operator.
     */
open func nlocktime(locktime: LockTime) -> BumpFeeTxBuilder  {
    return try!  FfiConverterTypeBumpFeeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_bumpfeetxbuilder_nlocktime(self.uniffiClonePointer(),
        FfiConverterTypeLockTime_lower(locktime),$0
    )
})
}
    
    /**
     * Set an exact `nSequence` value.
     *
     * This can cause conflicts if the wallet’s descriptors contain an "older" (`OP_CSV`) operator and the given
     * `nsequence` is lower than the CSV value.
     */
open func setExactSequence(nsequence: UInt32) -> BumpFeeTxBuilder  {
    return try!  FfiConverterTypeBumpFeeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_bumpfeetxbuilder_set_exact_sequence(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(nsequence),$0
    )
})
}
    
    /**
     * Build a transaction with a specific version.
     *
     * The version should always be greater than 0 and greater than 1 if the wallet’s descriptors contain an "older"
     * (`OP_CSV`) operator.
     */
open func version(version: Int32) -> BumpFeeTxBuilder  {
    return try!  FfiConverterTypeBumpFeeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_bumpfeetxbuilder_version(self.uniffiClonePointer(),
        FfiConverterInt32.lower(version),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBumpFeeTxBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BumpFeeTxBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BumpFeeTxBuilder {
        return BumpFeeTxBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BumpFeeTxBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BumpFeeTxBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BumpFeeTxBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBumpFeeTxBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> BumpFeeTxBuilder {
    return try FfiConverterTypeBumpFeeTxBuilder.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBumpFeeTxBuilder_lower(_ value: BumpFeeTxBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBumpFeeTxBuilder.lower(value)
}






/**
 * Build a BIP 157/158 light client to fetch transactions for a `Wallet`.
 *
 * Options:
 * * List of `Peer`: Bitcoin full-nodes for the light client to connect to. May be empty.
 * * `connections`: The number of connections for the light client to maintain.
 * * `scan_type`: Sync, recover, or start a new wallet. For more information see [`ScanType`].
 * * `data_dir`: Optional directory to store block headers and peers.
 *
 * A note on recovering wallets. Developers should allow users to provide an
 * approximate recovery height and an estimated number of transactions for the
 * wallet. When determining how many scripts to check filters for, the `Wallet`
 * `lookahead` value will be used. To ensure all transactions are recovered, the
 * `lookahead` should be roughly the number of transactions in the wallet history.
 */
public protocol CbfBuilderProtocol: AnyObject, Sendable {
    
    /**
     * Construct a [`CbfComponents`] for a [`Wallet`].
     */
    func build(wallet: Wallet)  -> CbfComponents
    
    /**
     * Configure the time in milliseconds that a node has to:
     * 1. Respond to the initial connection
     * 2. Respond to a request
     */
    func configureTimeoutMillis(handshake: UInt64, response: UInt64)  -> CbfBuilder
    
    /**
     * The number of connections for the light client to maintain. Default is two.
     */
    func connections(connections: UInt8)  -> CbfBuilder
    
    /**
     * Directory to store block headers and peers. If none is provided, the current
     * working directory will be used.
     */
    func dataDir(dataDir: String)  -> CbfBuilder
    
    /**
     * Bitcoin full-nodes to attempt a connection with.
     */
    func peers(peers: [Peer])  -> CbfBuilder
    
    /**
     * Select between syncing, recovering, or scanning for new wallets.
     */
    func scanType(scanType: ScanType)  -> CbfBuilder
    
    /**
     * Configure connections to be established through a `Socks5 proxy. The vast majority of the
     * time, the connection is to a local Tor daemon, which is typically exposed at
     * `127.0.0.1:9050`.
     */
    func socks5Proxy(proxy: Socks5Proxy)  -> CbfBuilder
    
}
/**
 * Build a BIP 157/158 light client to fetch transactions for a `Wallet`.
 *
 * Options:
 * * List of `Peer`: Bitcoin full-nodes for the light client to connect to. May be empty.
 * * `connections`: The number of connections for the light client to maintain.
 * * `scan_type`: Sync, recover, or start a new wallet. For more information see [`ScanType`].
 * * `data_dir`: Optional directory to store block headers and peers.
 *
 * A note on recovering wallets. Developers should allow users to provide an
 * approximate recovery height and an estimated number of transactions for the
 * wallet. When determining how many scripts to check filters for, the `Wallet`
 * `lookahead` value will be used. To ensure all transactions are recovered, the
 * `lookahead` should be roughly the number of transactions in the wallet history.
 */
open class CbfBuilder: CbfBuilderProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_cbfbuilder(self.pointer, $0) }
    }
    /**
     * Start a new [`CbfBuilder`]
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_bdkffi_fn_constructor_cbfbuilder_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_cbfbuilder(pointer, $0) }
    }

    

    
    /**
     * Construct a [`CbfComponents`] for a [`Wallet`].
     */
open func build(wallet: Wallet) -> CbfComponents  {
    return try!  FfiConverterTypeCbfComponents_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_cbfbuilder_build(self.uniffiClonePointer(),
        FfiConverterTypeWallet_lower(wallet),$0
    )
})
}
    
    /**
     * Configure the time in milliseconds that a node has to:
     * 1. Respond to the initial connection
     * 2. Respond to a request
     */
open func configureTimeoutMillis(handshake: UInt64, response: UInt64) -> CbfBuilder  {
    return try!  FfiConverterTypeCbfBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_cbfbuilder_configure_timeout_millis(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(handshake),
        FfiConverterUInt64.lower(response),$0
    )
})
}
    
    /**
     * The number of connections for the light client to maintain. Default is two.
     */
open func connections(connections: UInt8) -> CbfBuilder  {
    return try!  FfiConverterTypeCbfBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_cbfbuilder_connections(self.uniffiClonePointer(),
        FfiConverterUInt8.lower(connections),$0
    )
})
}
    
    /**
     * Directory to store block headers and peers. If none is provided, the current
     * working directory will be used.
     */
open func dataDir(dataDir: String) -> CbfBuilder  {
    return try!  FfiConverterTypeCbfBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_cbfbuilder_data_dir(self.uniffiClonePointer(),
        FfiConverterString.lower(dataDir),$0
    )
})
}
    
    /**
     * Bitcoin full-nodes to attempt a connection with.
     */
open func peers(peers: [Peer]) -> CbfBuilder  {
    return try!  FfiConverterTypeCbfBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_cbfbuilder_peers(self.uniffiClonePointer(),
        FfiConverterSequenceTypePeer.lower(peers),$0
    )
})
}
    
    /**
     * Select between syncing, recovering, or scanning for new wallets.
     */
open func scanType(scanType: ScanType) -> CbfBuilder  {
    return try!  FfiConverterTypeCbfBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_cbfbuilder_scan_type(self.uniffiClonePointer(),
        FfiConverterTypeScanType_lower(scanType),$0
    )
})
}
    
    /**
     * Configure connections to be established through a `Socks5 proxy. The vast majority of the
     * time, the connection is to a local Tor daemon, which is typically exposed at
     * `127.0.0.1:9050`.
     */
open func socks5Proxy(proxy: Socks5Proxy) -> CbfBuilder  {
    return try!  FfiConverterTypeCbfBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_cbfbuilder_socks5_proxy(self.uniffiClonePointer(),
        FfiConverterTypeSocks5Proxy_lower(proxy),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCbfBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = CbfBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> CbfBuilder {
        return CbfBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: CbfBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CbfBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: CbfBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCbfBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> CbfBuilder {
    return try FfiConverterTypeCbfBuilder.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCbfBuilder_lower(_ value: CbfBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeCbfBuilder.lower(value)
}






/**
 * A [`CbfClient`] handles wallet updates from a [`CbfNode`].
 */
public protocol CbfClientProtocol: AnyObject, Sendable {
    
    /**
     * Fetch the average fee rate for a block by requesting it from a peer. Not recommend for
     * resource-limited devices.
     */
    func averageFeeRate(blockhash: BlockHash) async throws  -> FeeRate
    
    /**
     * Broadcast a transaction to the network, erroring if the node has stopped running.
     */
    func broadcast(transaction: Transaction) async throws  -> Wtxid
    
    /**
     * Add another [`Peer`] to attempt a connection with.
     */
    func connect(peer: Peer) throws 
    
    /**
     * Check if the node is still running in the background.
     */
    func isRunning()  -> Bool
    
    /**
     * Query a Bitcoin DNS seeder using the configured resolver.
     *
     * This is **not** a generic DNS implementation. Host names are prefixed with a `x849` to filter
     * for compact block filter nodes from the seeder. For example `dns.myseeder.com` will be queried
     * as `x849.dns.myseeder.com`. This has no guarantee to return any `IpAddr`.
     */
    func lookupHost(hostname: String)  -> [IpAddress]
    
    /**
     * The minimum fee rate required to broadcast a transcation to all connected peers.
     */
    func minBroadcastFeerate() async throws  -> FeeRate
    
    /**
     * Return the next available info message from a node. If none is returned, the node has stopped.
     */
    func nextInfo() async throws  -> Info
    
    /**
     * Return the next available warning message from a node. If none is returned, the node has stopped.
     */
    func nextWarning() async throws  -> Warning
    
    /**
     * Stop the [`CbfNode`]. Errors if the node is already stopped.
     */
    func shutdown() throws 
    
    /**
     * Return an [`Update`]. This is method returns once the node syncs to the rest of
     * the network or a new block has been gossiped.
     */
    func update() async throws  -> Update
    
}
/**
 * A [`CbfClient`] handles wallet updates from a [`CbfNode`].
 */
open class CbfClient: CbfClientProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_cbfclient(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_cbfclient(pointer, $0) }
    }

    

    
    /**
     * Fetch the average fee rate for a block by requesting it from a peer. Not recommend for
     * resource-limited devices.
     */
open func averageFeeRate(blockhash: BlockHash)async throws  -> FeeRate  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bdkffi_fn_method_cbfclient_average_fee_rate(
                    self.uniffiClonePointer(),
                    FfiConverterTypeBlockHash_lower(blockhash)
                )
            },
            pollFunc: ffi_bdkffi_rust_future_poll_pointer,
            completeFunc: ffi_bdkffi_rust_future_complete_pointer,
            freeFunc: ffi_bdkffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFeeRate_lift,
            errorHandler: FfiConverterTypeCbfError_lift
        )
}
    
    /**
     * Broadcast a transaction to the network, erroring if the node has stopped running.
     */
open func broadcast(transaction: Transaction)async throws  -> Wtxid  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bdkffi_fn_method_cbfclient_broadcast(
                    self.uniffiClonePointer(),
                    FfiConverterTypeTransaction_lower(transaction)
                )
            },
            pollFunc: ffi_bdkffi_rust_future_poll_pointer,
            completeFunc: ffi_bdkffi_rust_future_complete_pointer,
            freeFunc: ffi_bdkffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeWtxid_lift,
            errorHandler: FfiConverterTypeCbfError_lift
        )
}
    
    /**
     * Add another [`Peer`] to attempt a connection with.
     */
open func connect(peer: Peer)throws   {try rustCallWithError(FfiConverterTypeCbfError_lift) {
    uniffi_bdkffi_fn_method_cbfclient_connect(self.uniffiClonePointer(),
        FfiConverterTypePeer_lower(peer),$0
    )
}
}
    
    /**
     * Check if the node is still running in the background.
     */
open func isRunning() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_cbfclient_is_running(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Query a Bitcoin DNS seeder using the configured resolver.
     *
     * This is **not** a generic DNS implementation. Host names are prefixed with a `x849` to filter
     * for compact block filter nodes from the seeder. For example `dns.myseeder.com` will be queried
     * as `x849.dns.myseeder.com`. This has no guarantee to return any `IpAddr`.
     */
open func lookupHost(hostname: String) -> [IpAddress]  {
    return try!  FfiConverterSequenceTypeIpAddress.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_cbfclient_lookup_host(self.uniffiClonePointer(),
        FfiConverterString.lower(hostname),$0
    )
})
}
    
    /**
     * The minimum fee rate required to broadcast a transcation to all connected peers.
     */
open func minBroadcastFeerate()async throws  -> FeeRate  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bdkffi_fn_method_cbfclient_min_broadcast_feerate(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_bdkffi_rust_future_poll_pointer,
            completeFunc: ffi_bdkffi_rust_future_complete_pointer,
            freeFunc: ffi_bdkffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFeeRate_lift,
            errorHandler: FfiConverterTypeCbfError_lift
        )
}
    
    /**
     * Return the next available info message from a node. If none is returned, the node has stopped.
     */
open func nextInfo()async throws  -> Info  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bdkffi_fn_method_cbfclient_next_info(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_bdkffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_bdkffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_bdkffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeInfo_lift,
            errorHandler: FfiConverterTypeCbfError_lift
        )
}
    
    /**
     * Return the next available warning message from a node. If none is returned, the node has stopped.
     */
open func nextWarning()async throws  -> Warning  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bdkffi_fn_method_cbfclient_next_warning(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_bdkffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_bdkffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_bdkffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeWarning_lift,
            errorHandler: FfiConverterTypeCbfError_lift
        )
}
    
    /**
     * Stop the [`CbfNode`]. Errors if the node is already stopped.
     */
open func shutdown()throws   {try rustCallWithError(FfiConverterTypeCbfError_lift) {
    uniffi_bdkffi_fn_method_cbfclient_shutdown(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Return an [`Update`]. This is method returns once the node syncs to the rest of
     * the network or a new block has been gossiped.
     */
open func update()async throws  -> Update  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bdkffi_fn_method_cbfclient_update(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_bdkffi_rust_future_poll_pointer,
            completeFunc: ffi_bdkffi_rust_future_complete_pointer,
            freeFunc: ffi_bdkffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeUpdate_lift,
            errorHandler: FfiConverterTypeCbfError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCbfClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = CbfClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> CbfClient {
        return CbfClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: CbfClient) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CbfClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: CbfClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCbfClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> CbfClient {
    return try FfiConverterTypeCbfClient.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCbfClient_lower(_ value: CbfClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeCbfClient.lower(value)
}






/**
 * A [`CbfNode`] gathers transactions for a [`Wallet`].
 * To receive [`Update`] for [`Wallet`], refer to the
 * [`CbfClient`]. The [`CbfNode`] will run until instructed
 * to stop.
 */
public protocol CbfNodeProtocol: AnyObject, Sendable {
    
    /**
     * Start the node on a detached OS thread and immediately return.
     */
    func run() 
    
}
/**
 * A [`CbfNode`] gathers transactions for a [`Wallet`].
 * To receive [`Update`] for [`Wallet`], refer to the
 * [`CbfClient`]. The [`CbfNode`] will run until instructed
 * to stop.
 */
open class CbfNode: CbfNodeProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_cbfnode(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_cbfnode(pointer, $0) }
    }

    

    
    /**
     * Start the node on a detached OS thread and immediately return.
     */
open func run()  {try! rustCall() {
    uniffi_bdkffi_fn_method_cbfnode_run(self.uniffiClonePointer(),$0
    )
}
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCbfNode: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = CbfNode

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> CbfNode {
        return CbfNode(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: CbfNode) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CbfNode {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: CbfNode, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCbfNode_lift(_ pointer: UnsafeMutableRawPointer) throws -> CbfNode {
    return try FfiConverterTypeCbfNode.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCbfNode_lower(_ value: CbfNode) -> UnsafeMutableRawPointer {
    return FfiConverterTypeCbfNode.lower(value)
}






public protocol ChangeSetProtocol: AnyObject, Sendable {
    
    /**
     * Get the change `Descriptor`
     */
    func changeDescriptor()  -> Descriptor?
    
    /**
     * Get the receiving `Descriptor`.
     */
    func descriptor()  -> Descriptor?
    
    /**
     * Get the changes to the indexer.
     */
    func indexerChangeset()  -> IndexerChangeSet
    
    /**
     * Get the changes to the local chain.
     */
    func localchainChangeset()  -> LocalChainChangeSet
    
    /**
     * Get the `Network`
     */
    func network()  -> Network?
    
    /**
     * Get the changes to the transaction graph.
     */
    func txGraphChangeset()  -> TxGraphChangeSet
    
}
open class ChangeSet: ChangeSetProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_changeset(self.pointer, $0) }
    }
    /**
     * Create an empty `ChangeSet`.
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_bdkffi_fn_constructor_changeset_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_changeset(pointer, $0) }
    }

    
public static func fromAggregate(descriptor: Descriptor?, changeDescriptor: Descriptor?, network: Network?, localChain: LocalChainChangeSet, txGraph: TxGraphChangeSet, indexer: IndexerChangeSet) -> ChangeSet  {
    return try!  FfiConverterTypeChangeSet_lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_changeset_from_aggregate(
        FfiConverterOptionTypeDescriptor.lower(descriptor),
        FfiConverterOptionTypeDescriptor.lower(changeDescriptor),
        FfiConverterOptionTypeNetwork.lower(network),
        FfiConverterTypeLocalChainChangeSet_lower(localChain),
        FfiConverterTypeTxGraphChangeSet_lower(txGraph),
        FfiConverterTypeIndexerChangeSet_lower(indexer),$0
    )
})
}
    
public static func fromDescriptorAndNetwork(descriptor: Descriptor?, changeDescriptor: Descriptor?, network: Network?) -> ChangeSet  {
    return try!  FfiConverterTypeChangeSet_lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_changeset_from_descriptor_and_network(
        FfiConverterOptionTypeDescriptor.lower(descriptor),
        FfiConverterOptionTypeDescriptor.lower(changeDescriptor),
        FfiConverterOptionTypeNetwork.lower(network),$0
    )
})
}
    
    /**
     * Start a wallet `ChangeSet` from indexer changes.
     */
public static func fromIndexerChangeset(indexerChanges: IndexerChangeSet) -> ChangeSet  {
    return try!  FfiConverterTypeChangeSet_lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_changeset_from_indexer_changeset(
        FfiConverterTypeIndexerChangeSet_lower(indexerChanges),$0
    )
})
}
    
    /**
     * Start a wallet `ChangeSet` from local chain changes.
     */
public static func fromLocalChainChanges(localChainChanges: LocalChainChangeSet) -> ChangeSet  {
    return try!  FfiConverterTypeChangeSet_lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_changeset_from_local_chain_changes(
        FfiConverterTypeLocalChainChangeSet_lower(localChainChanges),$0
    )
})
}
    
    /**
     * Build a `ChangeSet` by merging together two `ChangeSet`.
     */
public static func fromMerge(left: ChangeSet, right: ChangeSet) -> ChangeSet  {
    return try!  FfiConverterTypeChangeSet_lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_changeset_from_merge(
        FfiConverterTypeChangeSet_lower(left),
        FfiConverterTypeChangeSet_lower(right),$0
    )
})
}
    
    /**
     * Start a wallet `ChangeSet` from transaction graph changes.
     */
public static func fromTxGraphChangeset(txGraphChangeset: TxGraphChangeSet) -> ChangeSet  {
    return try!  FfiConverterTypeChangeSet_lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_changeset_from_tx_graph_changeset(
        FfiConverterTypeTxGraphChangeSet_lower(txGraphChangeset),$0
    )
})
}
    

    
    /**
     * Get the change `Descriptor`
     */
open func changeDescriptor() -> Descriptor?  {
    return try!  FfiConverterOptionTypeDescriptor.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_changeset_change_descriptor(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get the receiving `Descriptor`.
     */
open func descriptor() -> Descriptor?  {
    return try!  FfiConverterOptionTypeDescriptor.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_changeset_descriptor(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get the changes to the indexer.
     */
open func indexerChangeset() -> IndexerChangeSet  {
    return try!  FfiConverterTypeIndexerChangeSet_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_changeset_indexer_changeset(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get the changes to the local chain.
     */
open func localchainChangeset() -> LocalChainChangeSet  {
    return try!  FfiConverterTypeLocalChainChangeSet_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_changeset_localchain_changeset(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get the `Network`
     */
open func network() -> Network?  {
    return try!  FfiConverterOptionTypeNetwork.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_changeset_network(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get the changes to the transaction graph.
     */
open func txGraphChangeset() -> TxGraphChangeSet  {
    return try!  FfiConverterTypeTxGraphChangeSet_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_changeset_tx_graph_changeset(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeChangeSet: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ChangeSet

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ChangeSet {
        return ChangeSet(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ChangeSet) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChangeSet {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ChangeSet, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChangeSet_lift(_ pointer: UnsafeMutableRawPointer) throws -> ChangeSet {
    return try FfiConverterTypeChangeSet.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChangeSet_lower(_ value: ChangeSet) -> UnsafeMutableRawPointer {
    return FfiConverterTypeChangeSet.lower(value)
}






/**
 * A BIP-32 derivation path.
 */
public protocol DerivationPathProtocol: AnyObject, Sendable {
    
}
/**
 * A BIP-32 derivation path.
 */
open class DerivationPath: DerivationPathProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_derivationpath(self.pointer, $0) }
    }
    /**
     * Parse a string as a BIP-32 derivation path.
     */
public convenience init(path: String)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeBip32Error_lift) {
    uniffi_bdkffi_fn_constructor_derivationpath_new(
        FfiConverterString.lower(path),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_derivationpath(pointer, $0) }
    }

    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDerivationPath: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = DerivationPath

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> DerivationPath {
        return DerivationPath(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: DerivationPath) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DerivationPath {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: DerivationPath, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDerivationPath_lift(_ pointer: UnsafeMutableRawPointer) throws -> DerivationPath {
    return try FfiConverterTypeDerivationPath.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDerivationPath_lower(_ value: DerivationPath) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDerivationPath.lower(value)
}






/**
 * An expression of how to derive output scripts: https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md
 */
public protocol DescriptorProtocol: AnyObject, Sendable {
    
    func descType()  -> DescriptorType
    
    /**
     * A unique identifier for the descriptor.
     */
    func descriptorId()  -> DescriptorId
    
    /**
     * Does this descriptor contain paths: https://github.com/bitcoin/bips/blob/master/bip-0389.mediawiki
     */
    func isMultipath()  -> Bool
    
    /**
     * Computes an upper bound on the difference between a non-satisfied `TxIn`'s
     * `segwit_weight` and a satisfied `TxIn`'s `segwit_weight`.
     */
    func maxWeightToSatisfy() throws  -> UInt64
    
    /**
     * Return descriptors for all valid paths.
     */
    func toSingleDescriptors() throws  -> [Descriptor]
    
    /**
     * Dangerously convert the descriptor to a string.
     */
    func toStringWithSecret()  -> String
    
}
/**
 * An expression of how to derive output scripts: https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md
 */
open class Descriptor: DescriptorProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_descriptor(self.pointer, $0) }
    }
    /**
     * Parse a string as a descriptor for the given network.
     */
public convenience init(descriptor: String, network: Network)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeDescriptorError_lift) {
    uniffi_bdkffi_fn_constructor_descriptor_new(
        FfiConverterString.lower(descriptor),
        FfiConverterTypeNetwork_lower(network),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_descriptor(pointer, $0) }
    }

    
    /**
     * Multi-account hierarchy descriptor: https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki
     */
public static func newBip44(secretKey: DescriptorSecretKey, keychainKind: KeychainKind, network: Network) -> Descriptor  {
    return try!  FfiConverterTypeDescriptor_lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_descriptor_new_bip44(
        FfiConverterTypeDescriptorSecretKey_lower(secretKey),
        FfiConverterTypeKeychainKind_lower(keychainKind),
        FfiConverterTypeNetwork_lower(network),$0
    )
})
}
    
    /**
     * Multi-account hierarchy descriptor: https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki
     */
public static func newBip44Public(publicKey: DescriptorPublicKey, fingerprint: String, keychainKind: KeychainKind, network: Network) -> Descriptor  {
    return try!  FfiConverterTypeDescriptor_lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_descriptor_new_bip44_public(
        FfiConverterTypeDescriptorPublicKey_lower(publicKey),
        FfiConverterString.lower(fingerprint),
        FfiConverterTypeKeychainKind_lower(keychainKind),
        FfiConverterTypeNetwork_lower(network),$0
    )
})
}
    
    /**
     * P2SH nested P2WSH descriptor: https://github.com/bitcoin/bips/blob/master/bip-0049.mediawiki
     */
public static func newBip49(secretKey: DescriptorSecretKey, keychainKind: KeychainKind, network: Network) -> Descriptor  {
    return try!  FfiConverterTypeDescriptor_lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_descriptor_new_bip49(
        FfiConverterTypeDescriptorSecretKey_lower(secretKey),
        FfiConverterTypeKeychainKind_lower(keychainKind),
        FfiConverterTypeNetwork_lower(network),$0
    )
})
}
    
    /**
     * P2SH nested P2WSH descriptor: https://github.com/bitcoin/bips/blob/master/bip-0049.mediawiki
     */
public static func newBip49Public(publicKey: DescriptorPublicKey, fingerprint: String, keychainKind: KeychainKind, network: Network) -> Descriptor  {
    return try!  FfiConverterTypeDescriptor_lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_descriptor_new_bip49_public(
        FfiConverterTypeDescriptorPublicKey_lower(publicKey),
        FfiConverterString.lower(fingerprint),
        FfiConverterTypeKeychainKind_lower(keychainKind),
        FfiConverterTypeNetwork_lower(network),$0
    )
})
}
    
    /**
     * Pay to witness PKH descriptor: https://github.com/bitcoin/bips/blob/master/bip-0084.mediawiki
     */
public static func newBip84(secretKey: DescriptorSecretKey, keychainKind: KeychainKind, network: Network) -> Descriptor  {
    return try!  FfiConverterTypeDescriptor_lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_descriptor_new_bip84(
        FfiConverterTypeDescriptorSecretKey_lower(secretKey),
        FfiConverterTypeKeychainKind_lower(keychainKind),
        FfiConverterTypeNetwork_lower(network),$0
    )
})
}
    
    /**
     * Pay to witness PKH descriptor: https://github.com/bitcoin/bips/blob/master/bip-0084.mediawiki
     */
public static func newBip84Public(publicKey: DescriptorPublicKey, fingerprint: String, keychainKind: KeychainKind, network: Network) -> Descriptor  {
    return try!  FfiConverterTypeDescriptor_lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_descriptor_new_bip84_public(
        FfiConverterTypeDescriptorPublicKey_lower(publicKey),
        FfiConverterString.lower(fingerprint),
        FfiConverterTypeKeychainKind_lower(keychainKind),
        FfiConverterTypeNetwork_lower(network),$0
    )
})
}
    
    /**
     * Single key P2TR descriptor: https://github.com/bitcoin/bips/blob/master/bip-0086.mediawiki
     */
public static func newBip86(secretKey: DescriptorSecretKey, keychainKind: KeychainKind, network: Network) -> Descriptor  {
    return try!  FfiConverterTypeDescriptor_lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_descriptor_new_bip86(
        FfiConverterTypeDescriptorSecretKey_lower(secretKey),
        FfiConverterTypeKeychainKind_lower(keychainKind),
        FfiConverterTypeNetwork_lower(network),$0
    )
})
}
    
    /**
     * Single key P2TR descriptor: https://github.com/bitcoin/bips/blob/master/bip-0086.mediawiki
     */
public static func newBip86Public(publicKey: DescriptorPublicKey, fingerprint: String, keychainKind: KeychainKind, network: Network) -> Descriptor  {
    return try!  FfiConverterTypeDescriptor_lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_descriptor_new_bip86_public(
        FfiConverterTypeDescriptorPublicKey_lower(publicKey),
        FfiConverterString.lower(fingerprint),
        FfiConverterTypeKeychainKind_lower(keychainKind),
        FfiConverterTypeNetwork_lower(network),$0
    )
})
}
    

    
open func descType() -> DescriptorType  {
    return try!  FfiConverterTypeDescriptorType_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_descriptor_desc_type(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * A unique identifier for the descriptor.
     */
open func descriptorId() -> DescriptorId  {
    return try!  FfiConverterTypeDescriptorId_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_descriptor_descriptor_id(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Does this descriptor contain paths: https://github.com/bitcoin/bips/blob/master/bip-0389.mediawiki
     */
open func isMultipath() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_descriptor_is_multipath(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Computes an upper bound on the difference between a non-satisfied `TxIn`'s
     * `segwit_weight` and a satisfied `TxIn`'s `segwit_weight`.
     */
open func maxWeightToSatisfy()throws  -> UInt64  {
    return try  FfiConverterUInt64.lift(try rustCallWithError(FfiConverterTypeDescriptorError_lift) {
    uniffi_bdkffi_fn_method_descriptor_max_weight_to_satisfy(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return descriptors for all valid paths.
     */
open func toSingleDescriptors()throws  -> [Descriptor]  {
    return try  FfiConverterSequenceTypeDescriptor.lift(try rustCallWithError(FfiConverterTypeMiniscriptError_lift) {
    uniffi_bdkffi_fn_method_descriptor_to_single_descriptors(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Dangerously convert the descriptor to a string.
     */
open func toStringWithSecret() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_descriptor_to_string_with_secret(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_descriptor_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    open var description: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_descriptor_uniffi_trait_display(self.uniffiClonePointer(),$0
    )
}
        )
    }

}
extension Descriptor: CustomDebugStringConvertible {}
extension Descriptor: CustomStringConvertible {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDescriptor: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Descriptor

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Descriptor {
        return Descriptor(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Descriptor) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Descriptor {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Descriptor, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDescriptor_lift(_ pointer: UnsafeMutableRawPointer) throws -> Descriptor {
    return try FfiConverterTypeDescriptor.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDescriptor_lower(_ value: Descriptor) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDescriptor.lower(value)
}






/**
 * A collision-proof unique identifier for a descriptor.
 */
public protocol DescriptorIdProtocol: AnyObject, Sendable {
    
    /**
     * Serialize this type into a 32 byte array.
     */
    func serialize()  -> Data
    
}
/**
 * A collision-proof unique identifier for a descriptor.
 */
open class DescriptorId: DescriptorIdProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_descriptorid(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_descriptorid(pointer, $0) }
    }

    
    /**
     * Construct a hash-like type from 32 bytes.
     */
public static func fromBytes(bytes: Data)throws  -> DescriptorId  {
    return try  FfiConverterTypeDescriptorId_lift(try rustCallWithError(FfiConverterTypeHashParseError_lift) {
    uniffi_bdkffi_fn_constructor_descriptorid_from_bytes(
        FfiConverterData.lower(bytes),$0
    )
})
}
    
    /**
     * Construct a hash-like type from a hex string.
     */
public static func fromString(hex: String)throws  -> DescriptorId  {
    return try  FfiConverterTypeDescriptorId_lift(try rustCallWithError(FfiConverterTypeHashParseError_lift) {
    uniffi_bdkffi_fn_constructor_descriptorid_from_string(
        FfiConverterString.lower(hex),$0
    )
})
}
    

    
    /**
     * Serialize this type into a 32 byte array.
     */
open func serialize() -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_descriptorid_serialize(self.uniffiClonePointer(),$0
    )
})
}
    
    open var description: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_descriptorid_uniffi_trait_display(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: DescriptorId, other: DescriptorId) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_descriptorid_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeDescriptorId_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_descriptorid_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension DescriptorId: CustomStringConvertible {}
extension DescriptorId: Equatable {}
extension DescriptorId: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDescriptorId: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = DescriptorId

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> DescriptorId {
        return DescriptorId(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: DescriptorId) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DescriptorId {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: DescriptorId, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDescriptorId_lift(_ pointer: UnsafeMutableRawPointer) throws -> DescriptorId {
    return try FfiConverterTypeDescriptorId.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDescriptorId_lower(_ value: DescriptorId) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDescriptorId.lower(value)
}






/**
 * A descriptor public key.
 */
public protocol DescriptorPublicKeyProtocol: AnyObject, Sendable {
    
    /**
     * Derive the descriptor public key at the given derivation path.
     */
    func derive(path: DerivationPath) throws  -> DescriptorPublicKey
    
    /**
     * Extend the descriptor public key by the given derivation path.
     */
    func extend(path: DerivationPath) throws  -> DescriptorPublicKey
    
    /**
     * Whether or not this key has multiple derivation paths.
     */
    func isMultipath()  -> Bool
    
    /**
     * The fingerprint of the master key associated with this key, `0x00000000` if none.
     */
    func masterFingerprint()  -> String
    
}
/**
 * A descriptor public key.
 */
open class DescriptorPublicKey: DescriptorPublicKeyProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_descriptorpublickey(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_descriptorpublickey(pointer, $0) }
    }

    
    /**
     * Attempt to parse a string as a descriptor public key.
     */
public static func fromString(publicKey: String)throws  -> DescriptorPublicKey  {
    return try  FfiConverterTypeDescriptorPublicKey_lift(try rustCallWithError(FfiConverterTypeDescriptorKeyError_lift) {
    uniffi_bdkffi_fn_constructor_descriptorpublickey_from_string(
        FfiConverterString.lower(publicKey),$0
    )
})
}
    

    
    /**
     * Derive the descriptor public key at the given derivation path.
     */
open func derive(path: DerivationPath)throws  -> DescriptorPublicKey  {
    return try  FfiConverterTypeDescriptorPublicKey_lift(try rustCallWithError(FfiConverterTypeDescriptorKeyError_lift) {
    uniffi_bdkffi_fn_method_descriptorpublickey_derive(self.uniffiClonePointer(),
        FfiConverterTypeDerivationPath_lower(path),$0
    )
})
}
    
    /**
     * Extend the descriptor public key by the given derivation path.
     */
open func extend(path: DerivationPath)throws  -> DescriptorPublicKey  {
    return try  FfiConverterTypeDescriptorPublicKey_lift(try rustCallWithError(FfiConverterTypeDescriptorKeyError_lift) {
    uniffi_bdkffi_fn_method_descriptorpublickey_extend(self.uniffiClonePointer(),
        FfiConverterTypeDerivationPath_lower(path),$0
    )
})
}
    
    /**
     * Whether or not this key has multiple derivation paths.
     */
open func isMultipath() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_descriptorpublickey_is_multipath(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The fingerprint of the master key associated with this key, `0x00000000` if none.
     */
open func masterFingerprint() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_descriptorpublickey_master_fingerprint(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_descriptorpublickey_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    open var description: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_descriptorpublickey_uniffi_trait_display(self.uniffiClonePointer(),$0
    )
}
        )
    }

}
extension DescriptorPublicKey: CustomDebugStringConvertible {}
extension DescriptorPublicKey: CustomStringConvertible {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDescriptorPublicKey: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = DescriptorPublicKey

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> DescriptorPublicKey {
        return DescriptorPublicKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: DescriptorPublicKey) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DescriptorPublicKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: DescriptorPublicKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDescriptorPublicKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> DescriptorPublicKey {
    return try FfiConverterTypeDescriptorPublicKey.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDescriptorPublicKey_lower(_ value: DescriptorPublicKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDescriptorPublicKey.lower(value)
}






/**
 * A descriptor containing secret data.
 */
public protocol DescriptorSecretKeyProtocol: AnyObject, Sendable {
    
    /**
     * Return the descriptor public key corresponding to this secret.
     */
    func asPublic()  -> DescriptorPublicKey
    
    /**
     * Derive a descriptor secret key at a given derivation path.
     */
    func derive(path: DerivationPath) throws  -> DescriptorSecretKey
    
    /**
     * Extend the descriptor secret key by the derivation path.
     */
    func extend(path: DerivationPath) throws  -> DescriptorSecretKey
    
    /**
     * Return the bytes of this descriptor secret key.
     */
    func secretBytes()  -> Data
    
}
/**
 * A descriptor containing secret data.
 */
open class DescriptorSecretKey: DescriptorSecretKeyProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_descriptorsecretkey(self.pointer, $0) }
    }
    /**
     * Construct a secret descriptor using a mnemonic.
     */
public convenience init(network: Network, mnemonic: Mnemonic, password: String?) {
    let pointer =
        try! rustCall() {
    uniffi_bdkffi_fn_constructor_descriptorsecretkey_new(
        FfiConverterTypeNetwork_lower(network),
        FfiConverterTypeMnemonic_lower(mnemonic),
        FfiConverterOptionString.lower(password),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_descriptorsecretkey(pointer, $0) }
    }

    
    /**
     * Attempt to parse a string as a descriptor secret key.
     */
public static func fromString(privateKey: String)throws  -> DescriptorSecretKey  {
    return try  FfiConverterTypeDescriptorSecretKey_lift(try rustCallWithError(FfiConverterTypeDescriptorKeyError_lift) {
    uniffi_bdkffi_fn_constructor_descriptorsecretkey_from_string(
        FfiConverterString.lower(privateKey),$0
    )
})
}
    

    
    /**
     * Return the descriptor public key corresponding to this secret.
     */
open func asPublic() -> DescriptorPublicKey  {
    return try!  FfiConverterTypeDescriptorPublicKey_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_descriptorsecretkey_as_public(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Derive a descriptor secret key at a given derivation path.
     */
open func derive(path: DerivationPath)throws  -> DescriptorSecretKey  {
    return try  FfiConverterTypeDescriptorSecretKey_lift(try rustCallWithError(FfiConverterTypeDescriptorKeyError_lift) {
    uniffi_bdkffi_fn_method_descriptorsecretkey_derive(self.uniffiClonePointer(),
        FfiConverterTypeDerivationPath_lower(path),$0
    )
})
}
    
    /**
     * Extend the descriptor secret key by the derivation path.
     */
open func extend(path: DerivationPath)throws  -> DescriptorSecretKey  {
    return try  FfiConverterTypeDescriptorSecretKey_lift(try rustCallWithError(FfiConverterTypeDescriptorKeyError_lift) {
    uniffi_bdkffi_fn_method_descriptorsecretkey_extend(self.uniffiClonePointer(),
        FfiConverterTypeDerivationPath_lower(path),$0
    )
})
}
    
    /**
     * Return the bytes of this descriptor secret key.
     */
open func secretBytes() -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_descriptorsecretkey_secret_bytes(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_descriptorsecretkey_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    open var description: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_descriptorsecretkey_uniffi_trait_display(self.uniffiClonePointer(),$0
    )
}
        )
    }

}
extension DescriptorSecretKey: CustomDebugStringConvertible {}
extension DescriptorSecretKey: CustomStringConvertible {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDescriptorSecretKey: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = DescriptorSecretKey

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> DescriptorSecretKey {
        return DescriptorSecretKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: DescriptorSecretKey) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DescriptorSecretKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: DescriptorSecretKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDescriptorSecretKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> DescriptorSecretKey {
    return try FfiConverterTypeDescriptorSecretKey.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDescriptorSecretKey_lower(_ value: DescriptorSecretKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDescriptorSecretKey.lower(value)
}






/**
 * Wrapper around an electrum_client::ElectrumApi which includes an internal in-memory transaction
 * cache to avoid re-fetching already downloaded transactions.
 */
public protocol ElectrumClientProtocol: AnyObject, Sendable {
    
    /**
     * Subscribes to notifications for new block headers, by sending a blockchain.headers.subscribe call.
     */
    func blockHeadersSubscribe() throws  -> HeaderNotification
    
    /**
     * Estimates the fee required in bitcoin per kilobyte to confirm a transaction in `number` blocks.
     */
    func estimateFee(number: UInt64) throws  -> Double
    
    /**
     * Full scan the keychain scripts specified with the blockchain (via an Electrum client) and
     * returns updates for bdk_chain data structures.
     *
     * - `request`: struct with data required to perform a spk-based blockchain client
     * full scan, see `FullScanRequest`.
     * - `stop_gap`: the full scan for each keychain stops after a gap of script pubkeys with no
     * associated transactions.
     * - `batch_size`: specifies the max number of script pubkeys to request for in a single batch
     * request.
     * - `fetch_prev_txouts`: specifies whether we want previous `TxOuts` for fee calculation. Note
     * that this requires additional calls to the Electrum server, but is necessary for
     * calculating the fee on a transaction if your wallet does not own the inputs. Methods like
     * `Wallet.calculate_fee` and `Wallet.calculate_fee_rate` will return a
     * `CalculateFeeError::MissingTxOut` error if those TxOuts are not present in the transaction
     * graph.
     */
    func fullScan(request: FullScanRequest, stopGap: UInt64, batchSize: UInt64, fetchPrevTxouts: Bool) throws  -> Update
    
    /**
     * Pings the server.
     */
    func ping() throws 
    
    /**
     * Returns the capabilities of the server.
     */
    func serverFeatures() throws  -> ServerFeaturesRes
    
    /**
     * Sync a set of scripts with the blockchain (via an Electrum client) for the data specified and returns updates for bdk_chain data structures.
     *
     * - `request`: struct with data required to perform a spk-based blockchain client
     * sync, see `SyncRequest`.
     * - `batch_size`: specifies the max number of script pubkeys to request for in a single batch
     * request.
     * - `fetch_prev_txouts`: specifies whether we want previous `TxOuts` for fee calculation. Note
     * that this requires additional calls to the Electrum server, but is necessary for
     * calculating the fee on a transaction if your wallet does not own the inputs. Methods like
     * `Wallet.calculate_fee` and `Wallet.calculate_fee_rate` will return a
     * `CalculateFeeError::MissingTxOut` error if those TxOuts are not present in the transaction
     * graph.
     *
     * If the scripts to sync are unknown, such as when restoring or importing a keychain that may
     * include scripts that have been used, use full_scan with the keychain.
     */
    func sync(request: SyncRequest, batchSize: UInt64, fetchPrevTxouts: Bool) throws  -> Update
    
    /**
     * Broadcasts a transaction to the network.
     */
    func transactionBroadcast(tx: Transaction) throws  -> Txid
    
}
/**
 * Wrapper around an electrum_client::ElectrumApi which includes an internal in-memory transaction
 * cache to avoid re-fetching already downloaded transactions.
 */
open class ElectrumClient: ElectrumClientProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_electrumclient(self.pointer, $0) }
    }
    /**
     * Creates a new bdk client from a electrum_client::ElectrumApi
     * Optional: Set the proxy of the builder
     */
public convenience init(url: String, socks5: String? = nil)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeElectrumError_lift) {
    uniffi_bdkffi_fn_constructor_electrumclient_new(
        FfiConverterString.lower(url),
        FfiConverterOptionString.lower(socks5),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_electrumclient(pointer, $0) }
    }

    

    
    /**
     * Subscribes to notifications for new block headers, by sending a blockchain.headers.subscribe call.
     */
open func blockHeadersSubscribe()throws  -> HeaderNotification  {
    return try  FfiConverterTypeHeaderNotification_lift(try rustCallWithError(FfiConverterTypeElectrumError_lift) {
    uniffi_bdkffi_fn_method_electrumclient_block_headers_subscribe(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Estimates the fee required in bitcoin per kilobyte to confirm a transaction in `number` blocks.
     */
open func estimateFee(number: UInt64)throws  -> Double  {
    return try  FfiConverterDouble.lift(try rustCallWithError(FfiConverterTypeElectrumError_lift) {
    uniffi_bdkffi_fn_method_electrumclient_estimate_fee(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(number),$0
    )
})
}
    
    /**
     * Full scan the keychain scripts specified with the blockchain (via an Electrum client) and
     * returns updates for bdk_chain data structures.
     *
     * - `request`: struct with data required to perform a spk-based blockchain client
     * full scan, see `FullScanRequest`.
     * - `stop_gap`: the full scan for each keychain stops after a gap of script pubkeys with no
     * associated transactions.
     * - `batch_size`: specifies the max number of script pubkeys to request for in a single batch
     * request.
     * - `fetch_prev_txouts`: specifies whether we want previous `TxOuts` for fee calculation. Note
     * that this requires additional calls to the Electrum server, but is necessary for
     * calculating the fee on a transaction if your wallet does not own the inputs. Methods like
     * `Wallet.calculate_fee` and `Wallet.calculate_fee_rate` will return a
     * `CalculateFeeError::MissingTxOut` error if those TxOuts are not present in the transaction
     * graph.
     */
open func fullScan(request: FullScanRequest, stopGap: UInt64, batchSize: UInt64, fetchPrevTxouts: Bool)throws  -> Update  {
    return try  FfiConverterTypeUpdate_lift(try rustCallWithError(FfiConverterTypeElectrumError_lift) {
    uniffi_bdkffi_fn_method_electrumclient_full_scan(self.uniffiClonePointer(),
        FfiConverterTypeFullScanRequest_lower(request),
        FfiConverterUInt64.lower(stopGap),
        FfiConverterUInt64.lower(batchSize),
        FfiConverterBool.lower(fetchPrevTxouts),$0
    )
})
}
    
    /**
     * Pings the server.
     */
open func ping()throws   {try rustCallWithError(FfiConverterTypeElectrumError_lift) {
    uniffi_bdkffi_fn_method_electrumclient_ping(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Returns the capabilities of the server.
     */
open func serverFeatures()throws  -> ServerFeaturesRes  {
    return try  FfiConverterTypeServerFeaturesRes_lift(try rustCallWithError(FfiConverterTypeElectrumError_lift) {
    uniffi_bdkffi_fn_method_electrumclient_server_features(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Sync a set of scripts with the blockchain (via an Electrum client) for the data specified and returns updates for bdk_chain data structures.
     *
     * - `request`: struct with data required to perform a spk-based blockchain client
     * sync, see `SyncRequest`.
     * - `batch_size`: specifies the max number of script pubkeys to request for in a single batch
     * request.
     * - `fetch_prev_txouts`: specifies whether we want previous `TxOuts` for fee calculation. Note
     * that this requires additional calls to the Electrum server, but is necessary for
     * calculating the fee on a transaction if your wallet does not own the inputs. Methods like
     * `Wallet.calculate_fee` and `Wallet.calculate_fee_rate` will return a
     * `CalculateFeeError::MissingTxOut` error if those TxOuts are not present in the transaction
     * graph.
     *
     * If the scripts to sync are unknown, such as when restoring or importing a keychain that may
     * include scripts that have been used, use full_scan with the keychain.
     */
open func sync(request: SyncRequest, batchSize: UInt64, fetchPrevTxouts: Bool)throws  -> Update  {
    return try  FfiConverterTypeUpdate_lift(try rustCallWithError(FfiConverterTypeElectrumError_lift) {
    uniffi_bdkffi_fn_method_electrumclient_sync(self.uniffiClonePointer(),
        FfiConverterTypeSyncRequest_lower(request),
        FfiConverterUInt64.lower(batchSize),
        FfiConverterBool.lower(fetchPrevTxouts),$0
    )
})
}
    
    /**
     * Broadcasts a transaction to the network.
     */
open func transactionBroadcast(tx: Transaction)throws  -> Txid  {
    return try  FfiConverterTypeTxid_lift(try rustCallWithError(FfiConverterTypeElectrumError_lift) {
    uniffi_bdkffi_fn_method_electrumclient_transaction_broadcast(self.uniffiClonePointer(),
        FfiConverterTypeTransaction_lower(tx),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeElectrumClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ElectrumClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ElectrumClient {
        return ElectrumClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ElectrumClient) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ElectrumClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ElectrumClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeElectrumClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> ElectrumClient {
    return try FfiConverterTypeElectrumClient.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeElectrumClient_lower(_ value: ElectrumClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeElectrumClient.lower(value)
}






/**
 * Wrapper around an esplora_client::BlockingClient which includes an internal in-memory transaction
 * cache to avoid re-fetching already downloaded transactions.
 */
public protocol EsploraClientProtocol: AnyObject, Sendable {
    
    /**
     * Broadcast a [`Transaction`] to Esplora.
     */
    func broadcast(transaction: Transaction) throws 
    
    /**
     * Scan keychain scripts for transactions against Esplora, returning an update that can be
     * applied to the receiving structures.
     *
     * `request` provides the data required to perform a script-pubkey-based full scan
     * (see [`FullScanRequest`]). The full scan for each keychain (`K`) stops after a gap of
     * `stop_gap` script pubkeys with no associated transactions. `parallel_requests` specifies
     * the maximum number of HTTP requests to make in parallel.
     */
    func fullScan(request: FullScanRequest, stopGap: UInt64, parallelRequests: UInt64) throws  -> Update
    
    /**
     * Get the [`BlockHash`] of a specific block height.
     */
    func getBlockHash(blockHeight: UInt32) throws  -> BlockHash
    
    /**
     * Get a map where the key is the confirmation target (in number of
     * blocks) and the value is the estimated feerate (in sat/vB).
     */
    func getFeeEstimates() throws  -> [UInt16: Double]
    
    /**
     * Get the height of the current blockchain tip.
     */
    func getHeight() throws  -> UInt32
    
    /**
     * Get a [`Transaction`] option given its [`Txid`].
     */
    func getTx(txid: Txid) throws  -> Transaction?
    
    /**
     * Get transaction info given its [`Txid`].
     */
    func getTxInfo(txid: Txid) throws  -> Tx?
    
    /**
     * Get the status of a [`Transaction`] given its [`Txid`].
     */
    func getTxStatus(txid: Txid) throws  -> TxStatus
    
    /**
     * Sync a set of scripts, txids, and/or outpoints against Esplora.
     *
     * `request` provides the data required to perform a script-pubkey-based sync (see
     * [`SyncRequest`]). `parallel_requests` specifies the maximum number of HTTP requests to make
     * in parallel.
     */
    func sync(request: SyncRequest, parallelRequests: UInt64) throws  -> Update
    
}
/**
 * Wrapper around an esplora_client::BlockingClient which includes an internal in-memory transaction
 * cache to avoid re-fetching already downloaded transactions.
 */
open class EsploraClient: EsploraClientProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_esploraclient(self.pointer, $0) }
    }
    /**
     * Creates a new bdk client from an esplora_client::BlockingClient.
     * Optional: Set the proxy of the builder.
     */
public convenience init(url: String, proxy: String? = nil) {
    let pointer =
        try! rustCall() {
    uniffi_bdkffi_fn_constructor_esploraclient_new(
        FfiConverterString.lower(url),
        FfiConverterOptionString.lower(proxy),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_esploraclient(pointer, $0) }
    }

    

    
    /**
     * Broadcast a [`Transaction`] to Esplora.
     */
open func broadcast(transaction: Transaction)throws   {try rustCallWithError(FfiConverterTypeEsploraError_lift) {
    uniffi_bdkffi_fn_method_esploraclient_broadcast(self.uniffiClonePointer(),
        FfiConverterTypeTransaction_lower(transaction),$0
    )
}
}
    
    /**
     * Scan keychain scripts for transactions against Esplora, returning an update that can be
     * applied to the receiving structures.
     *
     * `request` provides the data required to perform a script-pubkey-based full scan
     * (see [`FullScanRequest`]). The full scan for each keychain (`K`) stops after a gap of
     * `stop_gap` script pubkeys with no associated transactions. `parallel_requests` specifies
     * the maximum number of HTTP requests to make in parallel.
     */
open func fullScan(request: FullScanRequest, stopGap: UInt64, parallelRequests: UInt64)throws  -> Update  {
    return try  FfiConverterTypeUpdate_lift(try rustCallWithError(FfiConverterTypeEsploraError_lift) {
    uniffi_bdkffi_fn_method_esploraclient_full_scan(self.uniffiClonePointer(),
        FfiConverterTypeFullScanRequest_lower(request),
        FfiConverterUInt64.lower(stopGap),
        FfiConverterUInt64.lower(parallelRequests),$0
    )
})
}
    
    /**
     * Get the [`BlockHash`] of a specific block height.
     */
open func getBlockHash(blockHeight: UInt32)throws  -> BlockHash  {
    return try  FfiConverterTypeBlockHash_lift(try rustCallWithError(FfiConverterTypeEsploraError_lift) {
    uniffi_bdkffi_fn_method_esploraclient_get_block_hash(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(blockHeight),$0
    )
})
}
    
    /**
     * Get a map where the key is the confirmation target (in number of
     * blocks) and the value is the estimated feerate (in sat/vB).
     */
open func getFeeEstimates()throws  -> [UInt16: Double]  {
    return try  FfiConverterDictionaryUInt16Double.lift(try rustCallWithError(FfiConverterTypeEsploraError_lift) {
    uniffi_bdkffi_fn_method_esploraclient_get_fee_estimates(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get the height of the current blockchain tip.
     */
open func getHeight()throws  -> UInt32  {
    return try  FfiConverterUInt32.lift(try rustCallWithError(FfiConverterTypeEsploraError_lift) {
    uniffi_bdkffi_fn_method_esploraclient_get_height(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get a [`Transaction`] option given its [`Txid`].
     */
open func getTx(txid: Txid)throws  -> Transaction?  {
    return try  FfiConverterOptionTypeTransaction.lift(try rustCallWithError(FfiConverterTypeEsploraError_lift) {
    uniffi_bdkffi_fn_method_esploraclient_get_tx(self.uniffiClonePointer(),
        FfiConverterTypeTxid_lower(txid),$0
    )
})
}
    
    /**
     * Get transaction info given its [`Txid`].
     */
open func getTxInfo(txid: Txid)throws  -> Tx?  {
    return try  FfiConverterOptionTypeTx.lift(try rustCallWithError(FfiConverterTypeEsploraError_lift) {
    uniffi_bdkffi_fn_method_esploraclient_get_tx_info(self.uniffiClonePointer(),
        FfiConverterTypeTxid_lower(txid),$0
    )
})
}
    
    /**
     * Get the status of a [`Transaction`] given its [`Txid`].
     */
open func getTxStatus(txid: Txid)throws  -> TxStatus  {
    return try  FfiConverterTypeTxStatus_lift(try rustCallWithError(FfiConverterTypeEsploraError_lift) {
    uniffi_bdkffi_fn_method_esploraclient_get_tx_status(self.uniffiClonePointer(),
        FfiConverterTypeTxid_lower(txid),$0
    )
})
}
    
    /**
     * Sync a set of scripts, txids, and/or outpoints against Esplora.
     *
     * `request` provides the data required to perform a script-pubkey-based sync (see
     * [`SyncRequest`]). `parallel_requests` specifies the maximum number of HTTP requests to make
     * in parallel.
     */
open func sync(request: SyncRequest, parallelRequests: UInt64)throws  -> Update  {
    return try  FfiConverterTypeUpdate_lift(try rustCallWithError(FfiConverterTypeEsploraError_lift) {
    uniffi_bdkffi_fn_method_esploraclient_sync(self.uniffiClonePointer(),
        FfiConverterTypeSyncRequest_lower(request),
        FfiConverterUInt64.lower(parallelRequests),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEsploraClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = EsploraClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EsploraClient {
        return EsploraClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: EsploraClient) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EsploraClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: EsploraClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEsploraClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> EsploraClient {
    return try FfiConverterTypeEsploraClient.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEsploraClient_lower(_ value: EsploraClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEsploraClient.lower(value)
}






/**
 * Represents fee rate.
 *
 * This is an integer type representing fee rate in sat/kwu. It provides protection against mixing
 * up the types as well as basic formatting features.
 */
public protocol FeeRateProtocol: AnyObject, Sendable {
    
    func toSatPerKwu()  -> UInt64
    
    func toSatPerVbCeil()  -> UInt64
    
    func toSatPerVbFloor()  -> UInt64
    
}
/**
 * Represents fee rate.
 *
 * This is an integer type representing fee rate in sat/kwu. It provides protection against mixing
 * up the types as well as basic formatting features.
 */
open class FeeRate: FeeRateProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_feerate(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_feerate(pointer, $0) }
    }

    
public static func fromSatPerKwu(satKwu: UInt64) -> FeeRate  {
    return try!  FfiConverterTypeFeeRate_lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_feerate_from_sat_per_kwu(
        FfiConverterUInt64.lower(satKwu),$0
    )
})
}
    
public static func fromSatPerVb(satVb: UInt64)throws  -> FeeRate  {
    return try  FfiConverterTypeFeeRate_lift(try rustCallWithError(FfiConverterTypeFeeRateError_lift) {
    uniffi_bdkffi_fn_constructor_feerate_from_sat_per_vb(
        FfiConverterUInt64.lower(satVb),$0
    )
})
}
    

    
open func toSatPerKwu() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_feerate_to_sat_per_kwu(self.uniffiClonePointer(),$0
    )
})
}
    
open func toSatPerVbCeil() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_feerate_to_sat_per_vb_ceil(self.uniffiClonePointer(),$0
    )
})
}
    
open func toSatPerVbFloor() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_feerate_to_sat_per_vb_floor(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFeeRate: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FeeRate

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRate {
        return FeeRate(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FeeRate) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeRate {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FeeRate, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRate_lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRate {
    return try FfiConverterTypeFeeRate.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRate_lower(_ value: FeeRate) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFeeRate.lower(value)
}






public protocol FullScanRequestProtocol: AnyObject, Sendable {
    
}
open class FullScanRequest: FullScanRequestProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_fullscanrequest(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_fullscanrequest(pointer, $0) }
    }

    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFullScanRequest: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FullScanRequest

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FullScanRequest {
        return FullScanRequest(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FullScanRequest) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FullScanRequest {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FullScanRequest, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFullScanRequest_lift(_ pointer: UnsafeMutableRawPointer) throws -> FullScanRequest {
    return try FfiConverterTypeFullScanRequest.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFullScanRequest_lower(_ value: FullScanRequest) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFullScanRequest.lower(value)
}






public protocol FullScanRequestBuilderProtocol: AnyObject, Sendable {
    
    func build() throws  -> FullScanRequest
    
    func inspectSpksForAllKeychains(inspector: FullScanScriptInspector) throws  -> FullScanRequestBuilder
    
}
open class FullScanRequestBuilder: FullScanRequestBuilderProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_fullscanrequestbuilder(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_fullscanrequestbuilder(pointer, $0) }
    }

    

    
open func build()throws  -> FullScanRequest  {
    return try  FfiConverterTypeFullScanRequest_lift(try rustCallWithError(FfiConverterTypeRequestBuilderError_lift) {
    uniffi_bdkffi_fn_method_fullscanrequestbuilder_build(self.uniffiClonePointer(),$0
    )
})
}
    
open func inspectSpksForAllKeychains(inspector: FullScanScriptInspector)throws  -> FullScanRequestBuilder  {
    return try  FfiConverterTypeFullScanRequestBuilder_lift(try rustCallWithError(FfiConverterTypeRequestBuilderError_lift) {
    uniffi_bdkffi_fn_method_fullscanrequestbuilder_inspect_spks_for_all_keychains(self.uniffiClonePointer(),
        FfiConverterTypeFullScanScriptInspector_lower(inspector),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFullScanRequestBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FullScanRequestBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FullScanRequestBuilder {
        return FullScanRequestBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FullScanRequestBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FullScanRequestBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FullScanRequestBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFullScanRequestBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> FullScanRequestBuilder {
    return try FfiConverterTypeFullScanRequestBuilder.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFullScanRequestBuilder_lower(_ value: FullScanRequestBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFullScanRequestBuilder.lower(value)
}






public protocol FullScanScriptInspector: AnyObject, Sendable {
    
    func inspect(keychain: KeychainKind, index: UInt32, script: Script) 
    
}
open class FullScanScriptInspectorImpl: FullScanScriptInspector, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_fullscanscriptinspector(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_fullscanscriptinspector(pointer, $0) }
    }

    

    
open func inspect(keychain: KeychainKind, index: UInt32, script: Script)  {try! rustCall() {
    uniffi_bdkffi_fn_method_fullscanscriptinspector_inspect(self.uniffiClonePointer(),
        FfiConverterTypeKeychainKind_lower(keychain),
        FfiConverterUInt32.lower(index),
        FfiConverterTypeScript_lower(script),$0
    )
}
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceFullScanScriptInspector {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceFullScanScriptInspector] = [UniffiVTableCallbackInterfaceFullScanScriptInspector(
        inspect: { (
            uniffiHandle: UInt64,
            keychain: RustBuffer,
            index: UInt32,
            script: UnsafeMutableRawPointer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeFullScanScriptInspector.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.inspect(
                     keychain: try FfiConverterTypeKeychainKind_lift(keychain),
                     index: try FfiConverterUInt32.lift(index),
                     script: try FfiConverterTypeScript_lift(script)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeFullScanScriptInspector.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface FullScanScriptInspector: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitFullScanScriptInspector() {
    uniffi_bdkffi_fn_init_callback_vtable_fullscanscriptinspector(UniffiCallbackInterfaceFullScanScriptInspector.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFullScanScriptInspector: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<FullScanScriptInspector>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FullScanScriptInspector

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FullScanScriptInspector {
        return FullScanScriptInspectorImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FullScanScriptInspector) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FullScanScriptInspector {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FullScanScriptInspector, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFullScanScriptInspector_lift(_ pointer: UnsafeMutableRawPointer) throws -> FullScanScriptInspector {
    return try FfiConverterTypeFullScanScriptInspector.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFullScanScriptInspector_lower(_ value: FullScanScriptInspector) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFullScanScriptInspector.lower(value)
}






/**
 * An [`OutPoint`] used as a key in a hash map.
 *
 * Due to limitations in generating the foreign language bindings, we cannot use [`OutPoint`] as a
 * key for hash maps.
 */
public protocol HashableOutPointProtocol: AnyObject, Sendable {
    
    /**
     * Get the internal [`OutPoint`]
     */
    func outpoint()  -> OutPoint
    
}
/**
 * An [`OutPoint`] used as a key in a hash map.
 *
 * Due to limitations in generating the foreign language bindings, we cannot use [`OutPoint`] as a
 * key for hash maps.
 */
open class HashableOutPoint: HashableOutPointProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_hashableoutpoint(self.pointer, $0) }
    }
    /**
     * Create a key for a key-value store from an [`OutPoint`]
     */
public convenience init(outpoint: OutPoint) {
    let pointer =
        try! rustCall() {
    uniffi_bdkffi_fn_constructor_hashableoutpoint_new(
        FfiConverterTypeOutPoint_lower(outpoint),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_hashableoutpoint(pointer, $0) }
    }

    

    
    /**
     * Get the internal [`OutPoint`]
     */
open func outpoint() -> OutPoint  {
    return try!  FfiConverterTypeOutPoint_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_hashableoutpoint_outpoint(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_hashableoutpoint_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: HashableOutPoint, other: HashableOutPoint) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_hashableoutpoint_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeHashableOutPoint_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_hashableoutpoint_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension HashableOutPoint: CustomDebugStringConvertible {}
extension HashableOutPoint: Equatable {}
extension HashableOutPoint: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHashableOutPoint: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = HashableOutPoint

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HashableOutPoint {
        return HashableOutPoint(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: HashableOutPoint) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HashableOutPoint {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: HashableOutPoint, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHashableOutPoint_lift(_ pointer: UnsafeMutableRawPointer) throws -> HashableOutPoint {
    return try FfiConverterTypeHashableOutPoint.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHashableOutPoint_lower(_ value: HashableOutPoint) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHashableOutPoint.lower(value)
}






/**
 * An IP address to connect to over TCP.
 */
public protocol IpAddressProtocol: AnyObject, Sendable {
    
}
/**
 * An IP address to connect to over TCP.
 */
open class IpAddress: IpAddressProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_ipaddress(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_ipaddress(pointer, $0) }
    }

    
    /**
     * Build an IPv4 address.
     */
public static func fromIpv4(q1: UInt8, q2: UInt8, q3: UInt8, q4: UInt8) -> IpAddress  {
    return try!  FfiConverterTypeIpAddress_lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_ipaddress_from_ipv4(
        FfiConverterUInt8.lower(q1),
        FfiConverterUInt8.lower(q2),
        FfiConverterUInt8.lower(q3),
        FfiConverterUInt8.lower(q4),$0
    )
})
}
    
    /**
     * Build an IPv6 address.
     */
public static func fromIpv6(a: UInt16, b: UInt16, c: UInt16, d: UInt16, e: UInt16, f: UInt16, g: UInt16, h: UInt16) -> IpAddress  {
    return try!  FfiConverterTypeIpAddress_lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_ipaddress_from_ipv6(
        FfiConverterUInt16.lower(a),
        FfiConverterUInt16.lower(b),
        FfiConverterUInt16.lower(c),
        FfiConverterUInt16.lower(d),
        FfiConverterUInt16.lower(e),
        FfiConverterUInt16.lower(f),
        FfiConverterUInt16.lower(g),
        FfiConverterUInt16.lower(h),$0
    )
})
}
    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIpAddress: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = IpAddress

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> IpAddress {
        return IpAddress(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: IpAddress) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IpAddress {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: IpAddress, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIpAddress_lift(_ pointer: UnsafeMutableRawPointer) throws -> IpAddress {
    return try FfiConverterTypeIpAddress.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIpAddress_lower(_ value: IpAddress) -> UnsafeMutableRawPointer {
    return FfiConverterTypeIpAddress.lower(value)
}






/**
 * A mnemonic seed phrase to recover a BIP-32 wallet.
 */
public protocol MnemonicProtocol: AnyObject, Sendable {
    
}
/**
 * A mnemonic seed phrase to recover a BIP-32 wallet.
 */
open class Mnemonic: MnemonicProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_mnemonic(self.pointer, $0) }
    }
    /**
     * Generate a mnemonic given a word count.
     */
public convenience init(wordCount: WordCount) {
    let pointer =
        try! rustCall() {
    uniffi_bdkffi_fn_constructor_mnemonic_new(
        FfiConverterTypeWordCount_lower(wordCount),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_mnemonic(pointer, $0) }
    }

    
    /**
     * Construct a mnemonic given an array of bytes. Note that using weak entropy will result in a loss
     * of funds. To ensure the entropy is generated properly, read about your operating
     * system specific ways to generate secure random numbers.
     */
public static func fromEntropy(entropy: Data)throws  -> Mnemonic  {
    return try  FfiConverterTypeMnemonic_lift(try rustCallWithError(FfiConverterTypeBip39Error_lift) {
    uniffi_bdkffi_fn_constructor_mnemonic_from_entropy(
        FfiConverterData.lower(entropy),$0
    )
})
}
    
    /**
     * Parse a string as a mnemonic seed phrase.
     */
public static func fromString(mnemonic: String)throws  -> Mnemonic  {
    return try  FfiConverterTypeMnemonic_lift(try rustCallWithError(FfiConverterTypeBip39Error_lift) {
    uniffi_bdkffi_fn_constructor_mnemonic_from_string(
        FfiConverterString.lower(mnemonic),$0
    )
})
}
    

    
    open var description: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_mnemonic_uniffi_trait_display(self.uniffiClonePointer(),$0
    )
}
        )
    }

}
extension Mnemonic: CustomStringConvertible {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMnemonic: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Mnemonic

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Mnemonic {
        return Mnemonic(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Mnemonic) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Mnemonic {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Mnemonic, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMnemonic_lift(_ pointer: UnsafeMutableRawPointer) throws -> Mnemonic {
    return try FfiConverterTypeMnemonic.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMnemonic_lower(_ value: Mnemonic) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMnemonic.lower(value)
}






/**
 * Definition of a wallet persistence implementation.
 */
public protocol Persistence: AnyObject, Sendable {
    
    /**
     * Initialize the total aggregate `ChangeSet` for the underlying wallet.
     */
    func initialize() throws  -> ChangeSet
    
    /**
     * Persist a `ChangeSet` to the total aggregate changeset of the wallet.
     */
    func persist(changeset: ChangeSet) throws 
    
}
/**
 * Definition of a wallet persistence implementation.
 */
open class PersistenceImpl: Persistence, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_persistence(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_persistence(pointer, $0) }
    }

    

    
    /**
     * Initialize the total aggregate `ChangeSet` for the underlying wallet.
     */
open func initialize()throws  -> ChangeSet  {
    return try  FfiConverterTypeChangeSet_lift(try rustCallWithError(FfiConverterTypePersistenceError_lift) {
    uniffi_bdkffi_fn_method_persistence_initialize(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Persist a `ChangeSet` to the total aggregate changeset of the wallet.
     */
open func persist(changeset: ChangeSet)throws   {try rustCallWithError(FfiConverterTypePersistenceError_lift) {
    uniffi_bdkffi_fn_method_persistence_persist(self.uniffiClonePointer(),
        FfiConverterTypeChangeSet_lower(changeset),$0
    )
}
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfacePersistence {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfacePersistence] = [UniffiVTableCallbackInterfacePersistence(
        initialize: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UnsafeMutableRawPointer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> ChangeSet in
                guard let uniffiObj = try? FfiConverterTypePersistence.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.initialize(
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeChangeSet_lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypePersistenceError_lower
            )
        },
        persist: { (
            uniffiHandle: UInt64,
            changeset: UnsafeMutableRawPointer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypePersistence.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.persist(
                     changeset: try FfiConverterTypeChangeSet_lift(changeset)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypePersistenceError_lower
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypePersistence.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface Persistence: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitPersistence() {
    uniffi_bdkffi_fn_init_callback_vtable_persistence(UniffiCallbackInterfacePersistence.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePersistence: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<Persistence>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Persistence

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Persistence {
        return PersistenceImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Persistence) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Persistence {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Persistence, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePersistence_lift(_ pointer: UnsafeMutableRawPointer) throws -> Persistence {
    return try FfiConverterTypePersistence.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePersistence_lower(_ value: Persistence) -> UnsafeMutableRawPointer {
    return FfiConverterTypePersistence.lower(value)
}






/**
 * Wallet backend implementations.
 */
public protocol PersisterProtocol: AnyObject, Sendable {
    
}
/**
 * Wallet backend implementations.
 */
open class Persister: PersisterProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_persister(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_persister(pointer, $0) }
    }

    
    /**
     * Use a native persistence layer.
     */
public static func custom(persistence: Persistence) -> Persister  {
    return try!  FfiConverterTypePersister_lift(try! rustCall() {
    uniffi_bdkffi_fn_constructor_persister_custom(
        FfiConverterTypePersistence_lower(persistence),$0
    )
})
}
    
    /**
     * Create a new connection in memory.
     */
public static func newInMemory()throws  -> Persister  {
    return try  FfiConverterTypePersister_lift(try rustCallWithError(FfiConverterTypePersistenceError_lift) {
    uniffi_bdkffi_fn_constructor_persister_new_in_memory($0
    )
})
}
    
    /**
     * Create a new Sqlite connection at the specified file path.
     */
public static func newSqlite(path: String)throws  -> Persister  {
    return try  FfiConverterTypePersister_lift(try rustCallWithError(FfiConverterTypePersistenceError_lift) {
    uniffi_bdkffi_fn_constructor_persister_new_sqlite(
        FfiConverterString.lower(path),$0
    )
})
}
    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePersister: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Persister

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Persister {
        return Persister(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Persister) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Persister {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Persister, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePersister_lift(_ pointer: UnsafeMutableRawPointer) throws -> Persister {
    return try FfiConverterTypePersister.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePersister_lower(_ value: Persister) -> UnsafeMutableRawPointer {
    return FfiConverterTypePersister.lower(value)
}






/**
 * Descriptor spending policy
 */
public protocol PolicyProtocol: AnyObject, Sendable {
    
    func asString()  -> String
    
    func contribution()  -> Satisfaction
    
    func id()  -> String
    
    func item()  -> SatisfiableItem
    
    func requiresPath()  -> Bool
    
    func satisfaction()  -> Satisfaction
    
}
/**
 * Descriptor spending policy
 */
open class Policy: PolicyProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_policy(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_policy(pointer, $0) }
    }

    

    
open func asString() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_policy_as_string(self.uniffiClonePointer(),$0
    )
})
}
    
open func contribution() -> Satisfaction  {
    return try!  FfiConverterTypeSatisfaction_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_policy_contribution(self.uniffiClonePointer(),$0
    )
})
}
    
open func id() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_policy_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func item() -> SatisfiableItem  {
    return try!  FfiConverterTypeSatisfiableItem_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_policy_item(self.uniffiClonePointer(),$0
    )
})
}
    
open func requiresPath() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_policy_requires_path(self.uniffiClonePointer(),$0
    )
})
}
    
open func satisfaction() -> Satisfaction  {
    return try!  FfiConverterTypeSatisfaction_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_policy_satisfaction(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePolicy: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Policy

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Policy {
        return Policy(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Policy) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Policy {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Policy, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePolicy_lift(_ pointer: UnsafeMutableRawPointer) throws -> Policy {
    return try FfiConverterTypePolicy.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePolicy_lower(_ value: Policy) -> UnsafeMutableRawPointer {
    return FfiConverterTypePolicy.lower(value)
}






/**
 * A Partially Signed Transaction.
 */
public protocol PsbtProtocol: AnyObject, Sendable {
    
    /**
     * Combines this `Psbt` with `other` PSBT as described by BIP 174.
     *
     * In accordance with BIP 174 this function is commutative i.e., `A.combine(B) == B.combine(A)`
     */
    func combine(other: Psbt) throws  -> Psbt
    
    /**
     * Extracts the `Transaction` from a `Psbt` by filling in the available signature information.
     *
     * #### Errors
     *
     * `ExtractTxError` variants will contain either the `Psbt` itself or the `Transaction`
     * that was extracted. These can be extracted from the Errors in order to recover.
     * See the error documentation for info on the variants. In general, it covers large fees.
     */
    func extractTx() throws  -> Transaction
    
    /**
     * Calculates transaction fee.
     *
     * 'Fee' being the amount that will be paid for mining a transaction with the current inputs
     * and outputs i.e., the difference in value of the total inputs and the total outputs.
     *
     * #### Errors
     *
     * - `MissingUtxo` when UTXO information for any input is not present or is invalid.
     * - `NegativeFee` if calculated value is negative.
     * - `FeeOverflow` if an integer overflow occurs.
     */
    func fee() throws  -> UInt64
    
    /**
     * Finalizes the current PSBT and produces a result indicating
     *
     * whether the finalization was successful or not.
     */
    func finalize()  -> FinalizedPsbtResult
    
    /**
     * Serializes the PSBT into a JSON string representation.
     */
    func jsonSerialize()  -> String
    
    /**
     * Serialize the PSBT into a base64-encoded string.
     */
    func serialize()  -> String
    
    /**
     * Returns the spending utxo for this PSBT's input at `input_index`.
     */
    func spendUtxo(inputIndex: UInt64)  -> String
    
    /**
     * Write the `Psbt` to a file. Note that the file must not yet exist.
     */
    func writeToFile(path: String) throws 
    
}
/**
 * A Partially Signed Transaction.
 */
open class Psbt: PsbtProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_psbt(self.pointer, $0) }
    }
    /**
     * Creates a new `Psbt` instance from a base64-encoded string.
     */
public convenience init(psbtBase64: String)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypePsbtParseError_lift) {
    uniffi_bdkffi_fn_constructor_psbt_new(
        FfiConverterString.lower(psbtBase64),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_psbt(pointer, $0) }
    }

    
    /**
     * Create a new `Psbt` from a `.psbt` file.
     */
public static func fromFile(path: String)throws  -> Psbt  {
    return try  FfiConverterTypePsbt_lift(try rustCallWithError(FfiConverterTypePsbtError_lift) {
    uniffi_bdkffi_fn_constructor_psbt_from_file(
        FfiConverterString.lower(path),$0
    )
})
}
    
    /**
     * Creates a PSBT from an unsigned transaction.
     *
     * # Errors
     *
     * If transactions is not unsigned.
     */
public static func fromUnsignedTx(tx: Transaction)throws  -> Psbt  {
    return try  FfiConverterTypePsbt_lift(try rustCallWithError(FfiConverterTypePsbtError_lift) {
    uniffi_bdkffi_fn_constructor_psbt_from_unsigned_tx(
        FfiConverterTypeTransaction_lower(tx),$0
    )
})
}
    

    
    /**
     * Combines this `Psbt` with `other` PSBT as described by BIP 174.
     *
     * In accordance with BIP 174 this function is commutative i.e., `A.combine(B) == B.combine(A)`
     */
open func combine(other: Psbt)throws  -> Psbt  {
    return try  FfiConverterTypePsbt_lift(try rustCallWithError(FfiConverterTypePsbtError_lift) {
    uniffi_bdkffi_fn_method_psbt_combine(self.uniffiClonePointer(),
        FfiConverterTypePsbt_lower(other),$0
    )
})
}
    
    /**
     * Extracts the `Transaction` from a `Psbt` by filling in the available signature information.
     *
     * #### Errors
     *
     * `ExtractTxError` variants will contain either the `Psbt` itself or the `Transaction`
     * that was extracted. These can be extracted from the Errors in order to recover.
     * See the error documentation for info on the variants. In general, it covers large fees.
     */
open func extractTx()throws  -> Transaction  {
    return try  FfiConverterTypeTransaction_lift(try rustCallWithError(FfiConverterTypeExtractTxError_lift) {
    uniffi_bdkffi_fn_method_psbt_extract_tx(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Calculates transaction fee.
     *
     * 'Fee' being the amount that will be paid for mining a transaction with the current inputs
     * and outputs i.e., the difference in value of the total inputs and the total outputs.
     *
     * #### Errors
     *
     * - `MissingUtxo` when UTXO information for any input is not present or is invalid.
     * - `NegativeFee` if calculated value is negative.
     * - `FeeOverflow` if an integer overflow occurs.
     */
open func fee()throws  -> UInt64  {
    return try  FfiConverterUInt64.lift(try rustCallWithError(FfiConverterTypePsbtError_lift) {
    uniffi_bdkffi_fn_method_psbt_fee(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Finalizes the current PSBT and produces a result indicating
     *
     * whether the finalization was successful or not.
     */
open func finalize() -> FinalizedPsbtResult  {
    return try!  FfiConverterTypeFinalizedPsbtResult_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_psbt_finalize(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Serializes the PSBT into a JSON string representation.
     */
open func jsonSerialize() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_psbt_json_serialize(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Serialize the PSBT into a base64-encoded string.
     */
open func serialize() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_psbt_serialize(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns the spending utxo for this PSBT's input at `input_index`.
     */
open func spendUtxo(inputIndex: UInt64) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_psbt_spend_utxo(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(inputIndex),$0
    )
})
}
    
    /**
     * Write the `Psbt` to a file. Note that the file must not yet exist.
     */
open func writeToFile(path: String)throws   {try rustCallWithError(FfiConverterTypePsbtError_lift) {
    uniffi_bdkffi_fn_method_psbt_write_to_file(self.uniffiClonePointer(),
        FfiConverterString.lower(path),$0
    )
}
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePsbt: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Psbt

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Psbt {
        return Psbt(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Psbt) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Psbt {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Psbt, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePsbt_lift(_ pointer: UnsafeMutableRawPointer) throws -> Psbt {
    return try FfiConverterTypePsbt.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePsbt_lower(_ value: Psbt) -> UnsafeMutableRawPointer {
    return FfiConverterTypePsbt.lower(value)
}






/**
 * A bitcoin script: https://en.bitcoin.it/wiki/Script
 */
public protocol ScriptProtocol: AnyObject, Sendable {
    
    /**
     * Convert a script into an array of bytes.
     */
    func toBytes()  -> Data
    
}
/**
 * A bitcoin script: https://en.bitcoin.it/wiki/Script
 */
open class Script: ScriptProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_script(self.pointer, $0) }
    }
    /**
     * Interpret an array of bytes as a bitcoin script.
     */
public convenience init(rawOutputScript: Data) {
    let pointer =
        try! rustCall() {
    uniffi_bdkffi_fn_constructor_script_new(
        FfiConverterData.lower(rawOutputScript),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_script(pointer, $0) }
    }

    

    
    /**
     * Convert a script into an array of bytes.
     */
open func toBytes() -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_script_to_bytes(self.uniffiClonePointer(),$0
    )
})
}
    
    open var description: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_script_uniffi_trait_display(self.uniffiClonePointer(),$0
    )
}
        )
    }

}
extension Script: CustomStringConvertible {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeScript: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Script

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Script {
        return Script(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Script) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Script {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Script, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeScript_lift(_ pointer: UnsafeMutableRawPointer) throws -> Script {
    return try FfiConverterTypeScript.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeScript_lower(_ value: Script) -> UnsafeMutableRawPointer {
    return FfiConverterTypeScript.lower(value)
}






public protocol SyncRequestProtocol: AnyObject, Sendable {
    
}
open class SyncRequest: SyncRequestProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_syncrequest(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_syncrequest(pointer, $0) }
    }

    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSyncRequest: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SyncRequest

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SyncRequest {
        return SyncRequest(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SyncRequest) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncRequest {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SyncRequest, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncRequest_lift(_ pointer: UnsafeMutableRawPointer) throws -> SyncRequest {
    return try FfiConverterTypeSyncRequest.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncRequest_lower(_ value: SyncRequest) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSyncRequest.lower(value)
}






public protocol SyncRequestBuilderProtocol: AnyObject, Sendable {
    
    func build() throws  -> SyncRequest
    
    func inspectSpks(inspector: SyncScriptInspector) throws  -> SyncRequestBuilder
    
}
open class SyncRequestBuilder: SyncRequestBuilderProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_syncrequestbuilder(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_syncrequestbuilder(pointer, $0) }
    }

    

    
open func build()throws  -> SyncRequest  {
    return try  FfiConverterTypeSyncRequest_lift(try rustCallWithError(FfiConverterTypeRequestBuilderError_lift) {
    uniffi_bdkffi_fn_method_syncrequestbuilder_build(self.uniffiClonePointer(),$0
    )
})
}
    
open func inspectSpks(inspector: SyncScriptInspector)throws  -> SyncRequestBuilder  {
    return try  FfiConverterTypeSyncRequestBuilder_lift(try rustCallWithError(FfiConverterTypeRequestBuilderError_lift) {
    uniffi_bdkffi_fn_method_syncrequestbuilder_inspect_spks(self.uniffiClonePointer(),
        FfiConverterTypeSyncScriptInspector_lower(inspector),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSyncRequestBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SyncRequestBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SyncRequestBuilder {
        return SyncRequestBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SyncRequestBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncRequestBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SyncRequestBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncRequestBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> SyncRequestBuilder {
    return try FfiConverterTypeSyncRequestBuilder.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncRequestBuilder_lower(_ value: SyncRequestBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSyncRequestBuilder.lower(value)
}






public protocol SyncScriptInspector: AnyObject, Sendable {
    
    func inspect(script: Script, total: UInt64) 
    
}
open class SyncScriptInspectorImpl: SyncScriptInspector, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_syncscriptinspector(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_syncscriptinspector(pointer, $0) }
    }

    

    
open func inspect(script: Script, total: UInt64)  {try! rustCall() {
    uniffi_bdkffi_fn_method_syncscriptinspector_inspect(self.uniffiClonePointer(),
        FfiConverterTypeScript_lower(script),
        FfiConverterUInt64.lower(total),$0
    )
}
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceSyncScriptInspector {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceSyncScriptInspector] = [UniffiVTableCallbackInterfaceSyncScriptInspector(
        inspect: { (
            uniffiHandle: UInt64,
            script: UnsafeMutableRawPointer,
            total: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeSyncScriptInspector.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.inspect(
                     script: try FfiConverterTypeScript_lift(script),
                     total: try FfiConverterUInt64.lift(total)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeSyncScriptInspector.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface SyncScriptInspector: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitSyncScriptInspector() {
    uniffi_bdkffi_fn_init_callback_vtable_syncscriptinspector(UniffiCallbackInterfaceSyncScriptInspector.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSyncScriptInspector: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<SyncScriptInspector>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SyncScriptInspector

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SyncScriptInspector {
        return SyncScriptInspectorImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SyncScriptInspector) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncScriptInspector {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SyncScriptInspector, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncScriptInspector_lift(_ pointer: UnsafeMutableRawPointer) throws -> SyncScriptInspector {
    return try FfiConverterTypeSyncScriptInspector.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncScriptInspector_lower(_ value: SyncScriptInspector) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSyncScriptInspector.lower(value)
}






/**
 * Bitcoin transaction.
 * An authenticated movement of coins.
 */
public protocol TransactionProtocol: AnyObject, Sendable {
    
    /**
     * Computes the Txid.
     * Hashes the transaction excluding the segwit data (i.e. the marker, flag bytes, and the witness fields themselves).
     */
    func computeTxid()  -> Txid
    
    /**
     * Compute the Wtxid, which includes the witness in the transaction hash.
     */
    func computeWtxid()  -> Wtxid
    
    /**
     * List of transaction inputs.
     */
    func input()  -> [TxIn]
    
    /**
     * Checks if this is a coinbase transaction.
     * The first transaction in the block distributes the mining reward and is called the coinbase transaction.
     * It is impossible to check if the transaction is first in the block, so this function checks the structure
     * of the transaction instead - the previous output must be all-zeros (creates satoshis “out of thin air”).
     */
    func isCoinbase()  -> Bool
    
    /**
     * Returns `true` if the transaction itself opted in to be BIP-125-replaceable (RBF).
     *
     * # Warning
     *
     * **Incorrectly relying on RBF may lead to monetary loss!**
     *
     * This **does not** cover the case where a transaction becomes replaceable due to ancestors
     * being RBF. Please note that transactions **may be replaced** even if they **do not** include
     * the RBF signal: <https://bitcoinops.org/en/newsletters/2022/10/19/#transaction-replacement-option>.
     */
    func isExplicitlyRbf()  -> Bool
    
    /**
     * Returns `true` if this transactions nLockTime is enabled ([BIP-65]).
     *
     * [BIP-65]: https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki
     */
    func isLockTimeEnabled()  -> Bool
    
    /**
     * Block height or timestamp. Transaction cannot be included in a block until this height/time.
     *
     * /// ### Relevant BIPs
     *
     * * [BIP-65 OP_CHECKLOCKTIMEVERIFY](https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki)
     * * [BIP-113 Median time-past as endpoint for lock-time calculations](https://github.com/bitcoin/bips/blob/master/bip-0113.mediawiki)
     */
    func lockTime()  -> UInt32
    
    /**
     * List of transaction outputs.
     */
    func output()  -> [TxOut]
    
    /**
     * Serialize transaction into consensus-valid format. See https://docs.rs/bitcoin/latest/bitcoin/struct.Transaction.html#serialization-notes for more notes on transaction serialization.
     */
    func serialize()  -> Data
    
    /**
     * Returns the total transaction size
     *
     * Total transaction size is the transaction size in bytes serialized as described in BIP144,
     * including base data and witness data.
     */
    func totalSize()  -> UInt64
    
    /**
     * The protocol version, is currently expected to be 1 or 2 (BIP 68).
     */
    func version()  -> Int32
    
    /**
     * Returns the "virtual size" (vsize) of this transaction.
     *
     * Will be `ceil(weight / 4.0)`. Note this implements the virtual size as per [`BIP141`], which
     * is different to what is implemented in Bitcoin Core.
     * > Virtual transaction size is defined as Transaction weight / 4 (rounded up to the next integer).
     *
     * [`BIP141`]: https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki
     */
    func vsize()  -> UInt64
    
    /**
     * Returns the weight of this transaction, as defined by BIP-141.
     *
     * > Transaction weight is defined as Base transaction size * 3 + Total transaction size (ie.
     * > the same method as calculating Block weight from Base size and Total size).
     *
     * For transactions with an empty witness, this is simply the consensus-serialized size times
     * four. For transactions with a witness, this is the non-witness consensus-serialized size
     * multiplied by three plus the with-witness consensus-serialized size.
     *
     * For transactions with no inputs, this function will return a value 2 less than the actual
     * weight of the serialized transaction. The reason is that zero-input transactions, post-segwit,
     * cannot be unambiguously serialized; we make a choice that adds two extra bytes. For more
     * details see [BIP 141](https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki)
     * which uses a "input count" of `0x00` as a `marker` for a Segwit-encoded transaction.
     *
     * If you need to use 0-input transactions, we strongly recommend you do so using the PSBT
     * API. The unsigned transaction encoded within PSBT is always a non-segwit transaction
     * and can therefore avoid this ambiguity.
     */
    func weight()  -> UInt64
    
}
/**
 * Bitcoin transaction.
 * An authenticated movement of coins.
 */
open class Transaction: TransactionProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_transaction(self.pointer, $0) }
    }
    /**
     * Creates a new `Transaction` instance from serialized transaction bytes.
     */
public convenience init(transactionBytes: Data)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeTransactionError_lift) {
    uniffi_bdkffi_fn_constructor_transaction_new(
        FfiConverterData.lower(transactionBytes),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_transaction(pointer, $0) }
    }

    

    
    /**
     * Computes the Txid.
     * Hashes the transaction excluding the segwit data (i.e. the marker, flag bytes, and the witness fields themselves).
     */
open func computeTxid() -> Txid  {
    return try!  FfiConverterTypeTxid_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_compute_txid(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Compute the Wtxid, which includes the witness in the transaction hash.
     */
open func computeWtxid() -> Wtxid  {
    return try!  FfiConverterTypeWtxid_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_compute_wtxid(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * List of transaction inputs.
     */
open func input() -> [TxIn]  {
    return try!  FfiConverterSequenceTypeTxIn.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_input(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Checks if this is a coinbase transaction.
     * The first transaction in the block distributes the mining reward and is called the coinbase transaction.
     * It is impossible to check if the transaction is first in the block, so this function checks the structure
     * of the transaction instead - the previous output must be all-zeros (creates satoshis “out of thin air”).
     */
open func isCoinbase() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_is_coinbase(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns `true` if the transaction itself opted in to be BIP-125-replaceable (RBF).
     *
     * # Warning
     *
     * **Incorrectly relying on RBF may lead to monetary loss!**
     *
     * This **does not** cover the case where a transaction becomes replaceable due to ancestors
     * being RBF. Please note that transactions **may be replaced** even if they **do not** include
     * the RBF signal: <https://bitcoinops.org/en/newsletters/2022/10/19/#transaction-replacement-option>.
     */
open func isExplicitlyRbf() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_is_explicitly_rbf(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns `true` if this transactions nLockTime is enabled ([BIP-65]).
     *
     * [BIP-65]: https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki
     */
open func isLockTimeEnabled() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_is_lock_time_enabled(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Block height or timestamp. Transaction cannot be included in a block until this height/time.
     *
     * /// ### Relevant BIPs
     *
     * * [BIP-65 OP_CHECKLOCKTIMEVERIFY](https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki)
     * * [BIP-113 Median time-past as endpoint for lock-time calculations](https://github.com/bitcoin/bips/blob/master/bip-0113.mediawiki)
     */
open func lockTime() -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_lock_time(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * List of transaction outputs.
     */
open func output() -> [TxOut]  {
    return try!  FfiConverterSequenceTypeTxOut.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_output(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Serialize transaction into consensus-valid format. See https://docs.rs/bitcoin/latest/bitcoin/struct.Transaction.html#serialization-notes for more notes on transaction serialization.
     */
open func serialize() -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_serialize(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns the total transaction size
     *
     * Total transaction size is the transaction size in bytes serialized as described in BIP144,
     * including base data and witness data.
     */
open func totalSize() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_total_size(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The protocol version, is currently expected to be 1 or 2 (BIP 68).
     */
open func version() -> Int32  {
    return try!  FfiConverterInt32.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_version(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns the "virtual size" (vsize) of this transaction.
     *
     * Will be `ceil(weight / 4.0)`. Note this implements the virtual size as per [`BIP141`], which
     * is different to what is implemented in Bitcoin Core.
     * > Virtual transaction size is defined as Transaction weight / 4 (rounded up to the next integer).
     *
     * [`BIP141`]: https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki
     */
open func vsize() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_vsize(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns the weight of this transaction, as defined by BIP-141.
     *
     * > Transaction weight is defined as Base transaction size * 3 + Total transaction size (ie.
     * > the same method as calculating Block weight from Base size and Total size).
     *
     * For transactions with an empty witness, this is simply the consensus-serialized size times
     * four. For transactions with a witness, this is the non-witness consensus-serialized size
     * multiplied by three plus the with-witness consensus-serialized size.
     *
     * For transactions with no inputs, this function will return a value 2 less than the actual
     * weight of the serialized transaction. The reason is that zero-input transactions, post-segwit,
     * cannot be unambiguously serialized; we make a choice that adds two extra bytes. For more
     * details see [BIP 141](https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki)
     * which uses a "input count" of `0x00` as a `marker` for a Segwit-encoded transaction.
     *
     * If you need to use 0-input transactions, we strongly recommend you do so using the PSBT
     * API. The unsigned transaction encoded within PSBT is always a non-segwit transaction
     * and can therefore avoid this ambiguity.
     */
open func weight() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_weight(self.uniffiClonePointer(),$0
    )
})
}
    
    open var description: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_uniffi_trait_display(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Transaction, other: Transaction) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_transaction_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeTransaction_lower(other),$0
    )
}
        )
    }

}
extension Transaction: CustomStringConvertible {}
extension Transaction: Equatable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransaction: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Transaction

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Transaction {
        return Transaction(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Transaction) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Transaction {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Transaction, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransaction_lift(_ pointer: UnsafeMutableRawPointer) throws -> Transaction {
    return try FfiConverterTypeTransaction.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransaction_lower(_ value: Transaction) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTransaction.lower(value)
}






/**
 * A `TxBuilder` is created by calling `build_tx` on a wallet. After assigning it, you set options on it until finally
 * calling `finish` to consume the builder and generate the transaction.
 */
public protocol TxBuilderProtocol: AnyObject, Sendable {
    
    /**
     * Add data as an output using `OP_RETURN`.
     */
    func addData(data: Data)  -> TxBuilder
    
    /**
     * Fill-in the `PSBT_GLOBAL_XPUB` field with the extended keys contained in both the external and internal
     * descriptors.
     *
     * This is useful for offline signers that take part to a multisig. Some hardware wallets like BitBox and ColdCard
     * are known to require this.
     */
    func addGlobalXpubs()  -> TxBuilder
    
    /**
     * Add a recipient to the internal list of recipients.
     */
    func addRecipient(script: Script, amount: Amount)  -> TxBuilder
    
    /**
     * Add a utxo to the internal list of unspendable utxos.
     *
     * It’s important to note that the "must-be-spent" utxos added with `TxBuilder::add_utxo` have priority over this.
     */
    func addUnspendable(unspendable: OutPoint)  -> TxBuilder
    
    /**
     * Add a utxo to the internal list of utxos that must be spent.
     *
     * These have priority over the "unspendable" utxos, meaning that if a utxo is present both in the "utxos" and the
     * "unspendable" list, it will be spent.
     */
    func addUtxo(outpoint: OutPoint)  -> TxBuilder
    
    /**
     * Add the list of outpoints to the internal list of UTXOs that must be spent.
     */
    func addUtxos(outpoints: [OutPoint])  -> TxBuilder
    
    /**
     * Set whether or not the dust limit is checked.
     *
     * Note: by avoiding a dust limit check you may end up with a transaction that is non-standard.
     */
    func allowDust(allowDust: Bool)  -> TxBuilder
    
    /**
     * Set a specific `ChangeSpendPolicy`. See `TxBuilder::do_not_spend_change` and `TxBuilder::only_spend_change` for
     * some shortcuts. This method assumes the presence of an internal keychain, otherwise it has no effect.
     */
    func changePolicy(changePolicy: ChangeSpendPolicy)  -> TxBuilder
    
    /**
     * Set the current blockchain height.
     *
     * This will be used to:
     *
     * 1. Set the `nLockTime` for preventing fee sniping. Note: This will be ignored if you manually specify a
     * `nlocktime` using `TxBuilder::nlocktime`.
     *
     * 2. Decide whether coinbase outputs are mature or not. If the coinbase outputs are not mature at `current_height`,
     * we ignore them in the coin selection. If you want to create a transaction that spends immature coinbase inputs,
     * manually add them using `TxBuilder::add_utxos`.
     * In both cases, if you don’t provide a current height, we use the last sync height.
     */
    func currentHeight(height: UInt32)  -> TxBuilder
    
    /**
     * Do not spend change outputs.
     *
     * This effectively adds all the change outputs to the "unspendable" list. See `TxBuilder::unspendable`. This method
     * assumes the presence of an internal keychain, otherwise it has no effect.
     */
    func doNotSpendChange()  -> TxBuilder
    
    /**
     * Sets the address to drain excess coins to.
     *
     * Usually, when there are excess coins they are sent to a change address generated by the wallet. This option
     * replaces the usual change address with an arbitrary script_pubkey of your choosing. Just as with a change output,
     * if the drain output is not needed (the excess coins are too small) it will not be included in the resulting
     * transaction. The only difference is that it is valid to use `drain_to` without setting any ordinary recipients
     * with `add_recipient` (but it is perfectly fine to add recipients as well).
     *
     * If you choose not to set any recipients, you should provide the utxos that the transaction should spend via
     * `add_utxos`. `drain_to` is very useful for draining all the coins in a wallet with `drain_wallet` to a single
     * address.
     */
    func drainTo(script: Script)  -> TxBuilder
    
    /**
     * Spend all the available inputs. This respects filters like `TxBuilder::unspendable` and the change policy.
     */
    func drainWallet()  -> TxBuilder
    
    /**
     * Excludes any outpoints whose enclosing transaction has fewer than `min_confirms`
     * confirmations.
     *
     * `min_confirms` is the minimum number of confirmations a transaction must have in order for
     * its outpoints to remain spendable.
     * - Passing `0` will include all transactions (no filtering).
     * - Passing `1` will exclude all unconfirmed transactions (equivalent to
     * `exclude_unconfirmed`).
     * - Passing `6` will only allow outpoints from transactions with at least 6 confirmations.
     *
     * If you chain this with other filtering methods, the final set of unspendable outpoints will
     * be the union of all filters.
     */
    func excludeBelowConfirmations(minConfirms: UInt32)  -> TxBuilder
    
    /**
     * Exclude outpoints whose enclosing transaction is unconfirmed.
     * This is a shorthand for exclude_below_confirmations(1).
     */
    func excludeUnconfirmed()  -> TxBuilder
    
    /**
     * Set an absolute fee The `fee_absolute` method refers to the absolute transaction fee in `Amount`. If anyone sets
     * both the `fee_absolute` method and the `fee_rate` method, the `FeePolicy` enum will be set by whichever method was
     * called last, as the `FeeRate` and `FeeAmount` are mutually exclusive.
     *
     * Note that this is really a minimum absolute fee – it’s possible to overshoot it slightly since adding a change output to drain the remaining excess might not be viable.
     */
    func feeAbsolute(feeAmount: Amount)  -> TxBuilder
    
    /**
     * Set a custom fee rate.
     *
     * This method sets the mining fee paid by the transaction as a rate on its size. This means that the total fee paid
     * is equal to fee_rate times the size of the transaction. Default is 1 sat/vB in accordance with Bitcoin Core’s
     * default relay policy.
     *
     * Note that this is really a minimum feerate – it’s possible to overshoot it slightly since adding a change output
     * to drain the remaining excess might not be viable.
     */
    func feeRate(feeRate: FeeRate)  -> TxBuilder
    
    /**
     * Finish building the transaction.
     *
     * Uses the thread-local random number generator (rng).
     *
     * Returns a new `Psbt` per BIP174.
     *
     * WARNING: To avoid change address reuse you must persist the changes resulting from one or more calls to this
     * method before closing the wallet. See `Wallet::reveal_next_address`.
     */
    func finish(wallet: Wallet) throws  -> Psbt
    
    /**
     * Only spend utxos added by `TxBuilder::add_utxo`.
     *
     * The wallet will not add additional utxos to the transaction even if they are needed to make the transaction valid.
     */
    func manuallySelectedOnly()  -> TxBuilder
    
    /**
     * Use a specific nLockTime while creating the transaction.
     *
     * This can cause conflicts if the wallet’s descriptors contain an "after" (`OP_CLTV`) operator.
     */
    func nlocktime(locktime: LockTime)  -> TxBuilder
    
    /**
     * Only spend change outputs.
     *
     * This effectively adds all the non-change outputs to the "unspendable" list. See `TxBuilder::unspendable`. This
     * method assumes the presence of an internal keychain, otherwise it has no effect.
     */
    func onlySpendChange()  -> TxBuilder
    
    /**
     * The TxBuilder::policy_path is a complex API. See the Rust docs for complete       information: https://docs.rs/bdk_wallet/latest/bdk_wallet/struct.TxBuilder.html#method.policy_path
     */
    func policyPath(policyPath: [String: [UInt64]], keychain: KeychainKind)  -> TxBuilder
    
    /**
     * Set an exact `nSequence` value.
     *
     * This can cause conflicts if the wallet’s descriptors contain an "older" (`OP_CSV`) operator and the given
     * `nsequence` is lower than the CSV value.
     */
    func setExactSequence(nsequence: UInt32)  -> TxBuilder
    
    /**
     * Replace the recipients already added with a new list of recipients.
     */
    func setRecipients(recipients: [ScriptAmount])  -> TxBuilder
    
    /**
     * Replace the internal list of unspendable utxos with a new list.
     *
     * It’s important to note that the "must-be-spent" utxos added with `TxBuilder::add_utxo` have priority over these.
     */
    func unspendable(unspendable: [OutPoint])  -> TxBuilder
    
    /**
     * Build a transaction with a specific version.
     *
     * The version should always be greater than 0 and greater than 1 if the wallet’s descriptors contain an "older"
     * (`OP_CSV`) operator.
     */
    func version(version: Int32)  -> TxBuilder
    
}
/**
 * A `TxBuilder` is created by calling `build_tx` on a wallet. After assigning it, you set options on it until finally
 * calling `finish` to consume the builder and generate the transaction.
 */
open class TxBuilder: TxBuilderProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_txbuilder(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_bdkffi_fn_constructor_txbuilder_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_txbuilder(pointer, $0) }
    }

    

    
    /**
     * Add data as an output using `OP_RETURN`.
     */
open func addData(data: Data) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_add_data(self.uniffiClonePointer(),
        FfiConverterData.lower(data),$0
    )
})
}
    
    /**
     * Fill-in the `PSBT_GLOBAL_XPUB` field with the extended keys contained in both the external and internal
     * descriptors.
     *
     * This is useful for offline signers that take part to a multisig. Some hardware wallets like BitBox and ColdCard
     * are known to require this.
     */
open func addGlobalXpubs() -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_add_global_xpubs(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Add a recipient to the internal list of recipients.
     */
open func addRecipient(script: Script, amount: Amount) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_add_recipient(self.uniffiClonePointer(),
        FfiConverterTypeScript_lower(script),
        FfiConverterTypeAmount_lower(amount),$0
    )
})
}
    
    /**
     * Add a utxo to the internal list of unspendable utxos.
     *
     * It’s important to note that the "must-be-spent" utxos added with `TxBuilder::add_utxo` have priority over this.
     */
open func addUnspendable(unspendable: OutPoint) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_add_unspendable(self.uniffiClonePointer(),
        FfiConverterTypeOutPoint_lower(unspendable),$0
    )
})
}
    
    /**
     * Add a utxo to the internal list of utxos that must be spent.
     *
     * These have priority over the "unspendable" utxos, meaning that if a utxo is present both in the "utxos" and the
     * "unspendable" list, it will be spent.
     */
open func addUtxo(outpoint: OutPoint) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_add_utxo(self.uniffiClonePointer(),
        FfiConverterTypeOutPoint_lower(outpoint),$0
    )
})
}
    
    /**
     * Add the list of outpoints to the internal list of UTXOs that must be spent.
     */
open func addUtxos(outpoints: [OutPoint]) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_add_utxos(self.uniffiClonePointer(),
        FfiConverterSequenceTypeOutPoint.lower(outpoints),$0
    )
})
}
    
    /**
     * Set whether or not the dust limit is checked.
     *
     * Note: by avoiding a dust limit check you may end up with a transaction that is non-standard.
     */
open func allowDust(allowDust: Bool) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_allow_dust(self.uniffiClonePointer(),
        FfiConverterBool.lower(allowDust),$0
    )
})
}
    
    /**
     * Set a specific `ChangeSpendPolicy`. See `TxBuilder::do_not_spend_change` and `TxBuilder::only_spend_change` for
     * some shortcuts. This method assumes the presence of an internal keychain, otherwise it has no effect.
     */
open func changePolicy(changePolicy: ChangeSpendPolicy) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_change_policy(self.uniffiClonePointer(),
        FfiConverterTypeChangeSpendPolicy_lower(changePolicy),$0
    )
})
}
    
    /**
     * Set the current blockchain height.
     *
     * This will be used to:
     *
     * 1. Set the `nLockTime` for preventing fee sniping. Note: This will be ignored if you manually specify a
     * `nlocktime` using `TxBuilder::nlocktime`.
     *
     * 2. Decide whether coinbase outputs are mature or not. If the coinbase outputs are not mature at `current_height`,
     * we ignore them in the coin selection. If you want to create a transaction that spends immature coinbase inputs,
     * manually add them using `TxBuilder::add_utxos`.
     * In both cases, if you don’t provide a current height, we use the last sync height.
     */
open func currentHeight(height: UInt32) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_current_height(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(height),$0
    )
})
}
    
    /**
     * Do not spend change outputs.
     *
     * This effectively adds all the change outputs to the "unspendable" list. See `TxBuilder::unspendable`. This method
     * assumes the presence of an internal keychain, otherwise it has no effect.
     */
open func doNotSpendChange() -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_do_not_spend_change(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Sets the address to drain excess coins to.
     *
     * Usually, when there are excess coins they are sent to a change address generated by the wallet. This option
     * replaces the usual change address with an arbitrary script_pubkey of your choosing. Just as with a change output,
     * if the drain output is not needed (the excess coins are too small) it will not be included in the resulting
     * transaction. The only difference is that it is valid to use `drain_to` without setting any ordinary recipients
     * with `add_recipient` (but it is perfectly fine to add recipients as well).
     *
     * If you choose not to set any recipients, you should provide the utxos that the transaction should spend via
     * `add_utxos`. `drain_to` is very useful for draining all the coins in a wallet with `drain_wallet` to a single
     * address.
     */
open func drainTo(script: Script) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_drain_to(self.uniffiClonePointer(),
        FfiConverterTypeScript_lower(script),$0
    )
})
}
    
    /**
     * Spend all the available inputs. This respects filters like `TxBuilder::unspendable` and the change policy.
     */
open func drainWallet() -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_drain_wallet(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Excludes any outpoints whose enclosing transaction has fewer than `min_confirms`
     * confirmations.
     *
     * `min_confirms` is the minimum number of confirmations a transaction must have in order for
     * its outpoints to remain spendable.
     * - Passing `0` will include all transactions (no filtering).
     * - Passing `1` will exclude all unconfirmed transactions (equivalent to
     * `exclude_unconfirmed`).
     * - Passing `6` will only allow outpoints from transactions with at least 6 confirmations.
     *
     * If you chain this with other filtering methods, the final set of unspendable outpoints will
     * be the union of all filters.
     */
open func excludeBelowConfirmations(minConfirms: UInt32) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_exclude_below_confirmations(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(minConfirms),$0
    )
})
}
    
    /**
     * Exclude outpoints whose enclosing transaction is unconfirmed.
     * This is a shorthand for exclude_below_confirmations(1).
     */
open func excludeUnconfirmed() -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_exclude_unconfirmed(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Set an absolute fee The `fee_absolute` method refers to the absolute transaction fee in `Amount`. If anyone sets
     * both the `fee_absolute` method and the `fee_rate` method, the `FeePolicy` enum will be set by whichever method was
     * called last, as the `FeeRate` and `FeeAmount` are mutually exclusive.
     *
     * Note that this is really a minimum absolute fee – it’s possible to overshoot it slightly since adding a change output to drain the remaining excess might not be viable.
     */
open func feeAbsolute(feeAmount: Amount) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_fee_absolute(self.uniffiClonePointer(),
        FfiConverterTypeAmount_lower(feeAmount),$0
    )
})
}
    
    /**
     * Set a custom fee rate.
     *
     * This method sets the mining fee paid by the transaction as a rate on its size. This means that the total fee paid
     * is equal to fee_rate times the size of the transaction. Default is 1 sat/vB in accordance with Bitcoin Core’s
     * default relay policy.
     *
     * Note that this is really a minimum feerate – it’s possible to overshoot it slightly since adding a change output
     * to drain the remaining excess might not be viable.
     */
open func feeRate(feeRate: FeeRate) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_fee_rate(self.uniffiClonePointer(),
        FfiConverterTypeFeeRate_lower(feeRate),$0
    )
})
}
    
    /**
     * Finish building the transaction.
     *
     * Uses the thread-local random number generator (rng).
     *
     * Returns a new `Psbt` per BIP174.
     *
     * WARNING: To avoid change address reuse you must persist the changes resulting from one or more calls to this
     * method before closing the wallet. See `Wallet::reveal_next_address`.
     */
open func finish(wallet: Wallet)throws  -> Psbt  {
    return try  FfiConverterTypePsbt_lift(try rustCallWithError(FfiConverterTypeCreateTxError_lift) {
    uniffi_bdkffi_fn_method_txbuilder_finish(self.uniffiClonePointer(),
        FfiConverterTypeWallet_lower(wallet),$0
    )
})
}
    
    /**
     * Only spend utxos added by `TxBuilder::add_utxo`.
     *
     * The wallet will not add additional utxos to the transaction even if they are needed to make the transaction valid.
     */
open func manuallySelectedOnly() -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_manually_selected_only(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Use a specific nLockTime while creating the transaction.
     *
     * This can cause conflicts if the wallet’s descriptors contain an "after" (`OP_CLTV`) operator.
     */
open func nlocktime(locktime: LockTime) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_nlocktime(self.uniffiClonePointer(),
        FfiConverterTypeLockTime_lower(locktime),$0
    )
})
}
    
    /**
     * Only spend change outputs.
     *
     * This effectively adds all the non-change outputs to the "unspendable" list. See `TxBuilder::unspendable`. This
     * method assumes the presence of an internal keychain, otherwise it has no effect.
     */
open func onlySpendChange() -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_only_spend_change(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The TxBuilder::policy_path is a complex API. See the Rust docs for complete       information: https://docs.rs/bdk_wallet/latest/bdk_wallet/struct.TxBuilder.html#method.policy_path
     */
open func policyPath(policyPath: [String: [UInt64]], keychain: KeychainKind) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_policy_path(self.uniffiClonePointer(),
        FfiConverterDictionaryStringSequenceUInt64.lower(policyPath),
        FfiConverterTypeKeychainKind_lower(keychain),$0
    )
})
}
    
    /**
     * Set an exact `nSequence` value.
     *
     * This can cause conflicts if the wallet’s descriptors contain an "older" (`OP_CSV`) operator and the given
     * `nsequence` is lower than the CSV value.
     */
open func setExactSequence(nsequence: UInt32) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_set_exact_sequence(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(nsequence),$0
    )
})
}
    
    /**
     * Replace the recipients already added with a new list of recipients.
     */
open func setRecipients(recipients: [ScriptAmount]) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_set_recipients(self.uniffiClonePointer(),
        FfiConverterSequenceTypeScriptAmount.lower(recipients),$0
    )
})
}
    
    /**
     * Replace the internal list of unspendable utxos with a new list.
     *
     * It’s important to note that the "must-be-spent" utxos added with `TxBuilder::add_utxo` have priority over these.
     */
open func unspendable(unspendable: [OutPoint]) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_unspendable(self.uniffiClonePointer(),
        FfiConverterSequenceTypeOutPoint.lower(unspendable),$0
    )
})
}
    
    /**
     * Build a transaction with a specific version.
     *
     * The version should always be greater than 0 and greater than 1 if the wallet’s descriptors contain an "older"
     * (`OP_CSV`) operator.
     */
open func version(version: Int32) -> TxBuilder  {
    return try!  FfiConverterTypeTxBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txbuilder_version(self.uniffiClonePointer(),
        FfiConverterInt32.lower(version),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTxBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TxBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TxBuilder {
        return TxBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TxBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TxBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> TxBuilder {
    return try FfiConverterTypeTxBuilder.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxBuilder_lower(_ value: TxBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTxBuilder.lower(value)
}






/**
 * The merkle root of the merkle tree corresponding to a block's transactions.
 */
public protocol TxMerkleNodeProtocol: AnyObject, Sendable {
    
    /**
     * Serialize this type into a 32 byte array.
     */
    func serialize()  -> Data
    
}
/**
 * The merkle root of the merkle tree corresponding to a block's transactions.
 */
open class TxMerkleNode: TxMerkleNodeProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_txmerklenode(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_txmerklenode(pointer, $0) }
    }

    
    /**
     * Construct a hash-like type from 32 bytes.
     */
public static func fromBytes(bytes: Data)throws  -> TxMerkleNode  {
    return try  FfiConverterTypeTxMerkleNode_lift(try rustCallWithError(FfiConverterTypeHashParseError_lift) {
    uniffi_bdkffi_fn_constructor_txmerklenode_from_bytes(
        FfiConverterData.lower(bytes),$0
    )
})
}
    
    /**
     * Construct a hash-like type from a hex string.
     */
public static func fromString(hex: String)throws  -> TxMerkleNode  {
    return try  FfiConverterTypeTxMerkleNode_lift(try rustCallWithError(FfiConverterTypeHashParseError_lift) {
    uniffi_bdkffi_fn_constructor_txmerklenode_from_string(
        FfiConverterString.lower(hex),$0
    )
})
}
    

    
    /**
     * Serialize this type into a 32 byte array.
     */
open func serialize() -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txmerklenode_serialize(self.uniffiClonePointer(),$0
    )
})
}
    
    open var description: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_txmerklenode_uniffi_trait_display(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: TxMerkleNode, other: TxMerkleNode) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_txmerklenode_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeTxMerkleNode_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_txmerklenode_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension TxMerkleNode: CustomStringConvertible {}
extension TxMerkleNode: Equatable {}
extension TxMerkleNode: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTxMerkleNode: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TxMerkleNode

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TxMerkleNode {
        return TxMerkleNode(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TxMerkleNode) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxMerkleNode {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TxMerkleNode, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxMerkleNode_lift(_ pointer: UnsafeMutableRawPointer) throws -> TxMerkleNode {
    return try FfiConverterTypeTxMerkleNode.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxMerkleNode_lower(_ value: TxMerkleNode) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTxMerkleNode.lower(value)
}






/**
 * A bitcoin transaction identifier
 */
public protocol TxidProtocol: AnyObject, Sendable {
    
    /**
     * Serialize this type into a 32 byte array.
     */
    func serialize()  -> Data
    
}
/**
 * A bitcoin transaction identifier
 */
open class Txid: TxidProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_txid(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_txid(pointer, $0) }
    }

    
    /**
     * Construct a hash-like type from 32 bytes.
     */
public static func fromBytes(bytes: Data)throws  -> Txid  {
    return try  FfiConverterTypeTxid_lift(try rustCallWithError(FfiConverterTypeHashParseError_lift) {
    uniffi_bdkffi_fn_constructor_txid_from_bytes(
        FfiConverterData.lower(bytes),$0
    )
})
}
    
    /**
     * Construct a hash-like type from a hex string.
     */
public static func fromString(hex: String)throws  -> Txid  {
    return try  FfiConverterTypeTxid_lift(try rustCallWithError(FfiConverterTypeHashParseError_lift) {
    uniffi_bdkffi_fn_constructor_txid_from_string(
        FfiConverterString.lower(hex),$0
    )
})
}
    

    
    /**
     * Serialize this type into a 32 byte array.
     */
open func serialize() -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_txid_serialize(self.uniffiClonePointer(),$0
    )
})
}
    
    open var description: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_txid_uniffi_trait_display(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Txid, other: Txid) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_txid_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeTxid_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_txid_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension Txid: CustomStringConvertible {}
extension Txid: Equatable {}
extension Txid: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTxid: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Txid

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Txid {
        return Txid(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Txid) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Txid {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Txid, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxid_lift(_ pointer: UnsafeMutableRawPointer) throws -> Txid {
    return try FfiConverterTypeTxid.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxid_lower(_ value: Txid) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTxid.lower(value)
}






/**
 * An update for a wallet containing chain, descriptor index, and transaction data.
 */
public protocol UpdateProtocol: AnyObject, Sendable {
    
}
/**
 * An update for a wallet containing chain, descriptor index, and transaction data.
 */
open class Update: UpdateProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_update(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_update(pointer, $0) }
    }

    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUpdate: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Update

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Update {
        return Update(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Update) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Update {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Update, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUpdate_lift(_ pointer: UnsafeMutableRawPointer) throws -> Update {
    return try FfiConverterTypeUpdate.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUpdate_lower(_ value: Update) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUpdate.lower(value)
}






/**
 * A Bitcoin wallet.
 *
 * The Wallet acts as a way of coherently interfacing with output descriptors and related transactions. Its main components are:
 * 1. output descriptors from which it can derive addresses.
 * 2. signers that can contribute signatures to addresses instantiated from the descriptors.
 *
 * The user is responsible for loading and writing wallet changes which are represented as
 * ChangeSets (see take_staged). Also see individual functions and example for instructions on when
 * Wallet state needs to be persisted.
 *
 * The Wallet descriptor (external) and change descriptor (internal) must not derive the same
 * script pubkeys. See KeychainTxOutIndex::insert_descriptor() for more details.
 */
public protocol WalletProtocol: AnyObject, Sendable {
    
    /**
     * Apply transactions that have been evicted from the mempool.
     * Transactions may be evicted for paying too-low fee, or for being malformed.
     * Irrelevant transactions are ignored.
     *
     * For more information: https://docs.rs/bdk_wallet/latest/bdk_wallet/struct.Wallet.html#method.apply_evicted_txs
     */
    func applyEvictedTxs(evictedTxs: [EvictedTx]) 
    
    /**
     * Apply relevant unconfirmed transactions to the wallet.
     * Transactions that are not relevant are filtered out.
     */
    func applyUnconfirmedTxs(unconfirmedTxs: [UnconfirmedTx]) 
    
    /**
     * Applies an update to the wallet and stages the changes (but does not persist them).
     *
     * Usually you create an `update` by interacting with some blockchain data source and inserting
     * transactions related to your wallet into it.
     *
     * After applying updates you should persist the staged wallet changes. For an example of how
     * to persist staged wallet changes see [`Wallet::reveal_next_address`].
     */
    func applyUpdate(update: Update) throws 
    
    /**
     * Return the balance, separated into available, trusted-pending, untrusted-pending and
     * immature values.
     */
    func balance()  -> Balance
    
    /**
     * Calculates the fee of a given transaction. Returns [`Amount::ZERO`] if `tx` is a coinbase transaction.
     *
     * To calculate the fee for a [`Transaction`] with inputs not owned by this wallet you must
     * manually insert the TxOut(s) into the tx graph using the [`insert_txout`] function.
     *
     * Note `tx` does not have to be in the graph for this to work.
     */
    func calculateFee(tx: Transaction) throws  -> Amount
    
    /**
     * Calculate the [`FeeRate`] for a given transaction.
     *
     * To calculate the fee rate for a [`Transaction`] with inputs not owned by this wallet you must
     * manually insert the TxOut(s) into the tx graph using the [`insert_txout`] function.
     *
     * Note `tx` does not have to be in the graph for this to work.
     */
    func calculateFeeRate(tx: Transaction) throws  -> FeeRate
    
    /**
     * Informs the wallet that you no longer intend to broadcast a tx that was built from it.
     *
     * This frees up the change address used when creating the tx for use in future transactions.
     */
    func cancelTx(tx: Transaction) 
    
    /**
     * The derivation index of this wallet. It will return `None` if it has not derived any addresses.
     * Otherwise, it will return the index of the highest address it has derived.
     */
    func derivationIndex(keychain: KeychainKind)  -> UInt32?
    
    /**
     * Finds how the wallet derived the script pubkey `spk`.
     *
     * Will only return `Some(_)` if the wallet has given out the spk.
     */
    func derivationOfSpk(spk: Script)  -> KeychainAndIndex?
    
    /**
     * Return the checksum of the public descriptor associated to `keychain`.
     *
     * Internally calls [`Self::public_descriptor`] to fetch the right descriptor.
     */
    func descriptorChecksum(keychain: KeychainKind)  -> String
    
    /**
     * Finalize a PSBT, i.e., for each input determine if sufficient data is available to pass
     * validation and construct the respective `scriptSig` or `scriptWitness`. Please refer to
     * [BIP174](https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki#Input_Finalizer),
     * and [BIP371](https://github.com/bitcoin/bips/blob/master/bip-0371.mediawiki)
     * for further information.
     *
     * Returns `true` if the PSBT could be finalized, and `false` otherwise.
     *
     * The [`SignOptions`] can be used to tweak the behavior of the finalizer.
     */
    func finalizePsbt(psbt: Psbt, signOptions: SignOptions?) throws  -> Bool
    
    /**
     * Get a single transaction from the wallet as a [`WalletTx`] (if the transaction exists).
     *
     * `WalletTx` contains the full transaction alongside meta-data such as:
     * * Blocks that the transaction is [`Anchor`]ed in. These may or may not be blocks that exist
     * in the best chain.
     * * The [`ChainPosition`] of the transaction in the best chain - whether the transaction is
     * confirmed or unconfirmed. If the transaction is confirmed, the anchor which proves the
     * confirmation is provided. If the transaction is unconfirmed, the unix timestamp of when
     * the transaction was last seen in the mempool is provided.
     */
    func getTx(txid: Txid) throws  -> CanonicalTx?
    
    /**
     * Returns the utxo owned by this wallet corresponding to `outpoint` if it exists in the
     * wallet's database.
     */
    func getUtxo(op: OutPoint)  -> LocalOutput?
    
    /**
     * Return whether or not a `script` is part of this wallet (either internal or external).
     */
    func isMine(script: Script)  -> Bool
    
    /**
     * Returns the latest checkpoint.
     */
    func latestCheckpoint()  -> BlockId
    
    /**
     * List all relevant outputs (includes both spent and unspent, confirmed and unconfirmed).
     *
     * To list only unspent outputs (UTXOs), use [`Wallet::list_unspent`] instead.
     */
    func listOutput()  -> [LocalOutput]
    
    /**
     * Return the list of unspent outputs of this wallet.
     */
    func listUnspent()  -> [LocalOutput]
    
    /**
     * List addresses that are revealed but unused.
     *
     * Note if the returned iterator is empty you can reveal more addresses
     * by using [`reveal_next_address`](Self::reveal_next_address) or
     * [`reveal_addresses_to`](Self::reveal_addresses_to).
     */
    func listUnusedAddresses(keychain: KeychainKind)  -> [AddressInfo]
    
    /**
     * Marks an address used of the given `keychain` at `index`.
     *
     * Returns whether the given index was present and then removed from the unused set.
     */
    func markUsed(keychain: KeychainKind, index: UInt32)  -> Bool
    
    /**
     * Get the Bitcoin network the wallet is using.
     */
    func network()  -> Network
    
    /**
     * The index of the next address that you would get if you were to ask the wallet for a new
     * address.
     */
    func nextDerivationIndex(keychain: KeychainKind)  -> UInt32
    
    /**
     * Get the next unused address for the given `keychain`, i.e. the address with the lowest
     * derivation index that hasn't been used in a transaction.
     *
     * This will attempt to reveal a new address if all previously revealed addresses have
     * been used, in which case the returned address will be the same as calling [`Wallet::reveal_next_address`].
     *
     * **WARNING**: To avoid address reuse you must persist the changes resulting from one or more
     * calls to this method before closing the wallet. See [`Wallet::reveal_next_address`].
     */
    func nextUnusedAddress(keychain: KeychainKind)  -> AddressInfo
    
    /**
     * Peek an address of the given `keychain` at `index` without revealing it.
     *
     * For non-wildcard descriptors this returns the same address at every provided index.
     *
     * # Panics
     *
     * This panics when the caller requests for an address of derivation index greater than the
     * [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) max index.
     */
    func peekAddress(keychain: KeychainKind, index: UInt32)  -> AddressInfo
    
    /**
     * Persist staged changes of wallet into persister.
     *
     * Returns whether any new changes were persisted.
     *
     * If the persister errors, the staged changes will not be cleared.
     */
    func persist(persister: Persister) throws  -> Bool
    
    /**
     * Return the spending policies for the wallet’s descriptor.
     */
    func policies(keychain: KeychainKind) throws  -> Policy?
    
    /**
     * Returns the descriptor used to create addresses for a particular `keychain`.
     *
     * It's the "public" version of the wallet's descriptor, meaning a new descriptor that has
     * the same structure but with the all secret keys replaced by their corresponding public key.
     * This can be used to build a watch-only version of a wallet.
     */
    func publicDescriptor(keychain: KeychainKind)  -> String
    
    /**
     * Reveal addresses up to and including the target `index` and return an iterator
     * of newly revealed addresses.
     *
     * If the target `index` is unreachable, we make a best effort to reveal up to the last
     * possible index. If all addresses up to the given `index` are already revealed, then
     * no new addresses are returned.
     *
     * **WARNING**: To avoid address reuse you must persist the changes resulting from one or more
     * calls to this method before closing the wallet. See [`Wallet::reveal_next_address`].
     */
    func revealAddressesTo(keychain: KeychainKind, index: UInt32)  -> [AddressInfo]
    
    /**
     * Attempt to reveal the next address of the given `keychain`.
     *
     * This will increment the keychain's derivation index. If the keychain's descriptor doesn't
     * contain a wildcard or every address is already revealed up to the maximum derivation
     * index defined in [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki),
     * then the last revealed address will be returned.
     */
    func revealNextAddress(keychain: KeychainKind)  -> AddressInfo
    
    /**
     * Compute the `tx`'s sent and received [`Amount`]s.
     *
     * This method returns a tuple `(sent, received)`. Sent is the sum of the txin amounts
     * that spend from previous txouts tracked by this wallet. Received is the summation
     * of this tx's outputs that send to script pubkeys tracked by this wallet.
     */
    func sentAndReceived(tx: Transaction)  -> SentAndReceivedValues
    
    /**
     * Sign a transaction with all the wallet's signers, in the order specified by every signer's
     * [`SignerOrdering`]. This function returns the `Result` type with an encapsulated `bool` that
     * has the value true if the PSBT was finalized, or false otherwise.
     *
     * The [`SignOptions`] can be used to tweak the behavior of the software signers, and the way
     * the transaction is finalized at the end. Note that it can't be guaranteed that *every*
     * signers will follow the options, but the "software signers" (WIF keys and `xprv`) defined
     * in this library will.
     */
    func sign(psbt: Psbt, signOptions: SignOptions?) throws  -> Bool
    
    /**
     * Create a [`FullScanRequest] for this wallet.
     *
     * This is the first step when performing a spk-based wallet full scan, the returned
     * [`FullScanRequest] collects iterators for the wallet's keychain script pub keys needed to
     * start a blockchain full scan with a spk based blockchain client.
     *
     * This operation is generally only used when importing or restoring a previously used wallet
     * in which the list of used scripts is not known.
     */
    func startFullScan()  -> FullScanRequestBuilder
    
    /**
     * Create a partial [`SyncRequest`] for this wallet for all revealed spks.
     *
     * This is the first step when performing a spk-based wallet partial sync, the returned
     * [`SyncRequest`] collects all revealed script pubkeys from the wallet keychain needed to
     * start a blockchain sync with a spk based blockchain client.
     */
    func startSyncWithRevealedSpks()  -> SyncRequestBuilder
    
    /**
     * Iterate over the transactions in the wallet.
     */
    func transactions()  -> [CanonicalTx]
    
    /**
     * Get the [`TxDetails`] of a wallet transaction.
     */
    func txDetails(txid: Txid)  -> TxDetails?
    
}
/**
 * A Bitcoin wallet.
 *
 * The Wallet acts as a way of coherently interfacing with output descriptors and related transactions. Its main components are:
 * 1. output descriptors from which it can derive addresses.
 * 2. signers that can contribute signatures to addresses instantiated from the descriptors.
 *
 * The user is responsible for loading and writing wallet changes which are represented as
 * ChangeSets (see take_staged). Also see individual functions and example for instructions on when
 * Wallet state needs to be persisted.
 *
 * The Wallet descriptor (external) and change descriptor (internal) must not derive the same
 * script pubkeys. See KeychainTxOutIndex::insert_descriptor() for more details.
 */
open class Wallet: WalletProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_wallet(self.pointer, $0) }
    }
    /**
     * Build a new Wallet.
     *
     * If you have previously created a wallet, use load instead.
     */
public convenience init(descriptor: Descriptor, changeDescriptor: Descriptor, network: Network, persister: Persister, lookahead: UInt32 = UInt32(25))throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeCreateWithPersistError_lift) {
    uniffi_bdkffi_fn_constructor_wallet_new(
        FfiConverterTypeDescriptor_lower(descriptor),
        FfiConverterTypeDescriptor_lower(changeDescriptor),
        FfiConverterTypeNetwork_lower(network),
        FfiConverterTypePersister_lower(persister),
        FfiConverterUInt32.lower(lookahead),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_wallet(pointer, $0) }
    }

    
    /**
     * Build a new `Wallet` from a two-path descriptor.
     *
     * This function parses a multipath descriptor with exactly 2 paths and creates a wallet using the existing receive and change wallet creation logic.
     *
     * Multipath descriptors follow [BIP-389](https://github.com/bitcoin/bips/blob/master/bip-0389.mediawiki) and allow defining both receive and change derivation paths in a single descriptor using the <0;1> syntax.
     *
     * If you have previously created a wallet, use load instead.
     *
     * Returns an error if the descriptor is invalid or not a 2-path multipath descriptor.
     */
public static func createFromTwoPathDescriptor(twoPathDescriptor: Descriptor, network: Network, persister: Persister, lookahead: UInt32 = UInt32(25))throws  -> Wallet  {
    return try  FfiConverterTypeWallet_lift(try rustCallWithError(FfiConverterTypeCreateWithPersistError_lift) {
    uniffi_bdkffi_fn_constructor_wallet_create_from_two_path_descriptor(
        FfiConverterTypeDescriptor_lower(twoPathDescriptor),
        FfiConverterTypeNetwork_lower(network),
        FfiConverterTypePersister_lower(persister),
        FfiConverterUInt32.lower(lookahead),$0
    )
})
}
    
    /**
     * Build a new single descriptor `Wallet`.
     *
     * If you have previously created a wallet, use `Wallet::load` instead.
     *
     * # Note
     *
     * Only use this method when creating a wallet designed to be used with a single
     * descriptor and keychain. Otherwise the recommended way to construct a new wallet is
     * by using `Wallet::new`. It's worth noting that not all features are available
     * with single descriptor wallets, for example setting a `change_policy` on `TxBuilder`
     * and related methods such as `do_not_spend_change`. This is because all payments are
     * received on the external keychain (including change), and without a change keychain
     * BDK lacks enough information to distinguish between change and outside payments.
     *
     * Additionally because this wallet has no internal (change) keychain, all methods that
     * require a `KeychainKind` as input, e.g. `reveal_next_address` should only be called
     * using the `External` variant. In most cases passing `Internal` is treated as the
     * equivalent of `External` but this behavior must not be relied on.
     */
public static func createSingle(descriptor: Descriptor, network: Network, persister: Persister, lookahead: UInt32 = UInt32(25))throws  -> Wallet  {
    return try  FfiConverterTypeWallet_lift(try rustCallWithError(FfiConverterTypeCreateWithPersistError_lift) {
    uniffi_bdkffi_fn_constructor_wallet_create_single(
        FfiConverterTypeDescriptor_lower(descriptor),
        FfiConverterTypeNetwork_lower(network),
        FfiConverterTypePersister_lower(persister),
        FfiConverterUInt32.lower(lookahead),$0
    )
})
}
    
    /**
     * Build Wallet by loading from persistence.
     *
     * Note that the descriptor secret keys are not persisted to the db.
     */
public static func load(descriptor: Descriptor, changeDescriptor: Descriptor, persister: Persister, lookahead: UInt32 = UInt32(25))throws  -> Wallet  {
    return try  FfiConverterTypeWallet_lift(try rustCallWithError(FfiConverterTypeLoadWithPersistError_lift) {
    uniffi_bdkffi_fn_constructor_wallet_load(
        FfiConverterTypeDescriptor_lower(descriptor),
        FfiConverterTypeDescriptor_lower(changeDescriptor),
        FfiConverterTypePersister_lower(persister),
        FfiConverterUInt32.lower(lookahead),$0
    )
})
}
    

    
    /**
     * Apply transactions that have been evicted from the mempool.
     * Transactions may be evicted for paying too-low fee, or for being malformed.
     * Irrelevant transactions are ignored.
     *
     * For more information: https://docs.rs/bdk_wallet/latest/bdk_wallet/struct.Wallet.html#method.apply_evicted_txs
     */
open func applyEvictedTxs(evictedTxs: [EvictedTx])  {try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_apply_evicted_txs(self.uniffiClonePointer(),
        FfiConverterSequenceTypeEvictedTx.lower(evictedTxs),$0
    )
}
}
    
    /**
     * Apply relevant unconfirmed transactions to the wallet.
     * Transactions that are not relevant are filtered out.
     */
open func applyUnconfirmedTxs(unconfirmedTxs: [UnconfirmedTx])  {try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_apply_unconfirmed_txs(self.uniffiClonePointer(),
        FfiConverterSequenceTypeUnconfirmedTx.lower(unconfirmedTxs),$0
    )
}
}
    
    /**
     * Applies an update to the wallet and stages the changes (but does not persist them).
     *
     * Usually you create an `update` by interacting with some blockchain data source and inserting
     * transactions related to your wallet into it.
     *
     * After applying updates you should persist the staged wallet changes. For an example of how
     * to persist staged wallet changes see [`Wallet::reveal_next_address`].
     */
open func applyUpdate(update: Update)throws   {try rustCallWithError(FfiConverterTypeCannotConnectError_lift) {
    uniffi_bdkffi_fn_method_wallet_apply_update(self.uniffiClonePointer(),
        FfiConverterTypeUpdate_lower(update),$0
    )
}
}
    
    /**
     * Return the balance, separated into available, trusted-pending, untrusted-pending and
     * immature values.
     */
open func balance() -> Balance  {
    return try!  FfiConverterTypeBalance_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_balance(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Calculates the fee of a given transaction. Returns [`Amount::ZERO`] if `tx` is a coinbase transaction.
     *
     * To calculate the fee for a [`Transaction`] with inputs not owned by this wallet you must
     * manually insert the TxOut(s) into the tx graph using the [`insert_txout`] function.
     *
     * Note `tx` does not have to be in the graph for this to work.
     */
open func calculateFee(tx: Transaction)throws  -> Amount  {
    return try  FfiConverterTypeAmount_lift(try rustCallWithError(FfiConverterTypeCalculateFeeError_lift) {
    uniffi_bdkffi_fn_method_wallet_calculate_fee(self.uniffiClonePointer(),
        FfiConverterTypeTransaction_lower(tx),$0
    )
})
}
    
    /**
     * Calculate the [`FeeRate`] for a given transaction.
     *
     * To calculate the fee rate for a [`Transaction`] with inputs not owned by this wallet you must
     * manually insert the TxOut(s) into the tx graph using the [`insert_txout`] function.
     *
     * Note `tx` does not have to be in the graph for this to work.
     */
open func calculateFeeRate(tx: Transaction)throws  -> FeeRate  {
    return try  FfiConverterTypeFeeRate_lift(try rustCallWithError(FfiConverterTypeCalculateFeeError_lift) {
    uniffi_bdkffi_fn_method_wallet_calculate_fee_rate(self.uniffiClonePointer(),
        FfiConverterTypeTransaction_lower(tx),$0
    )
})
}
    
    /**
     * Informs the wallet that you no longer intend to broadcast a tx that was built from it.
     *
     * This frees up the change address used when creating the tx for use in future transactions.
     */
open func cancelTx(tx: Transaction)  {try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_cancel_tx(self.uniffiClonePointer(),
        FfiConverterTypeTransaction_lower(tx),$0
    )
}
}
    
    /**
     * The derivation index of this wallet. It will return `None` if it has not derived any addresses.
     * Otherwise, it will return the index of the highest address it has derived.
     */
open func derivationIndex(keychain: KeychainKind) -> UInt32?  {
    return try!  FfiConverterOptionUInt32.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_derivation_index(self.uniffiClonePointer(),
        FfiConverterTypeKeychainKind_lower(keychain),$0
    )
})
}
    
    /**
     * Finds how the wallet derived the script pubkey `spk`.
     *
     * Will only return `Some(_)` if the wallet has given out the spk.
     */
open func derivationOfSpk(spk: Script) -> KeychainAndIndex?  {
    return try!  FfiConverterOptionTypeKeychainAndIndex.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_derivation_of_spk(self.uniffiClonePointer(),
        FfiConverterTypeScript_lower(spk),$0
    )
})
}
    
    /**
     * Return the checksum of the public descriptor associated to `keychain`.
     *
     * Internally calls [`Self::public_descriptor`] to fetch the right descriptor.
     */
open func descriptorChecksum(keychain: KeychainKind) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_descriptor_checksum(self.uniffiClonePointer(),
        FfiConverterTypeKeychainKind_lower(keychain),$0
    )
})
}
    
    /**
     * Finalize a PSBT, i.e., for each input determine if sufficient data is available to pass
     * validation and construct the respective `scriptSig` or `scriptWitness`. Please refer to
     * [BIP174](https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki#Input_Finalizer),
     * and [BIP371](https://github.com/bitcoin/bips/blob/master/bip-0371.mediawiki)
     * for further information.
     *
     * Returns `true` if the PSBT could be finalized, and `false` otherwise.
     *
     * The [`SignOptions`] can be used to tweak the behavior of the finalizer.
     */
open func finalizePsbt(psbt: Psbt, signOptions: SignOptions? = nil)throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeSignerError_lift) {
    uniffi_bdkffi_fn_method_wallet_finalize_psbt(self.uniffiClonePointer(),
        FfiConverterTypePsbt_lower(psbt),
        FfiConverterOptionTypeSignOptions.lower(signOptions),$0
    )
})
}
    
    /**
     * Get a single transaction from the wallet as a [`WalletTx`] (if the transaction exists).
     *
     * `WalletTx` contains the full transaction alongside meta-data such as:
     * * Blocks that the transaction is [`Anchor`]ed in. These may or may not be blocks that exist
     * in the best chain.
     * * The [`ChainPosition`] of the transaction in the best chain - whether the transaction is
     * confirmed or unconfirmed. If the transaction is confirmed, the anchor which proves the
     * confirmation is provided. If the transaction is unconfirmed, the unix timestamp of when
     * the transaction was last seen in the mempool is provided.
     */
open func getTx(txid: Txid)throws  -> CanonicalTx?  {
    return try  FfiConverterOptionTypeCanonicalTx.lift(try rustCallWithError(FfiConverterTypeTxidParseError_lift) {
    uniffi_bdkffi_fn_method_wallet_get_tx(self.uniffiClonePointer(),
        FfiConverterTypeTxid_lower(txid),$0
    )
})
}
    
    /**
     * Returns the utxo owned by this wallet corresponding to `outpoint` if it exists in the
     * wallet's database.
     */
open func getUtxo(op: OutPoint) -> LocalOutput?  {
    return try!  FfiConverterOptionTypeLocalOutput.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_get_utxo(self.uniffiClonePointer(),
        FfiConverterTypeOutPoint_lower(op),$0
    )
})
}
    
    /**
     * Return whether or not a `script` is part of this wallet (either internal or external).
     */
open func isMine(script: Script) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_is_mine(self.uniffiClonePointer(),
        FfiConverterTypeScript_lower(script),$0
    )
})
}
    
    /**
     * Returns the latest checkpoint.
     */
open func latestCheckpoint() -> BlockId  {
    return try!  FfiConverterTypeBlockId_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_latest_checkpoint(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * List all relevant outputs (includes both spent and unspent, confirmed and unconfirmed).
     *
     * To list only unspent outputs (UTXOs), use [`Wallet::list_unspent`] instead.
     */
open func listOutput() -> [LocalOutput]  {
    return try!  FfiConverterSequenceTypeLocalOutput.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_list_output(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the list of unspent outputs of this wallet.
     */
open func listUnspent() -> [LocalOutput]  {
    return try!  FfiConverterSequenceTypeLocalOutput.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_list_unspent(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * List addresses that are revealed but unused.
     *
     * Note if the returned iterator is empty you can reveal more addresses
     * by using [`reveal_next_address`](Self::reveal_next_address) or
     * [`reveal_addresses_to`](Self::reveal_addresses_to).
     */
open func listUnusedAddresses(keychain: KeychainKind) -> [AddressInfo]  {
    return try!  FfiConverterSequenceTypeAddressInfo.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_list_unused_addresses(self.uniffiClonePointer(),
        FfiConverterTypeKeychainKind_lower(keychain),$0
    )
})
}
    
    /**
     * Marks an address used of the given `keychain` at `index`.
     *
     * Returns whether the given index was present and then removed from the unused set.
     */
open func markUsed(keychain: KeychainKind, index: UInt32) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_mark_used(self.uniffiClonePointer(),
        FfiConverterTypeKeychainKind_lower(keychain),
        FfiConverterUInt32.lower(index),$0
    )
})
}
    
    /**
     * Get the Bitcoin network the wallet is using.
     */
open func network() -> Network  {
    return try!  FfiConverterTypeNetwork_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_network(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The index of the next address that you would get if you were to ask the wallet for a new
     * address.
     */
open func nextDerivationIndex(keychain: KeychainKind) -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_next_derivation_index(self.uniffiClonePointer(),
        FfiConverterTypeKeychainKind_lower(keychain),$0
    )
})
}
    
    /**
     * Get the next unused address for the given `keychain`, i.e. the address with the lowest
     * derivation index that hasn't been used in a transaction.
     *
     * This will attempt to reveal a new address if all previously revealed addresses have
     * been used, in which case the returned address will be the same as calling [`Wallet::reveal_next_address`].
     *
     * **WARNING**: To avoid address reuse you must persist the changes resulting from one or more
     * calls to this method before closing the wallet. See [`Wallet::reveal_next_address`].
     */
open func nextUnusedAddress(keychain: KeychainKind) -> AddressInfo  {
    return try!  FfiConverterTypeAddressInfo_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_next_unused_address(self.uniffiClonePointer(),
        FfiConverterTypeKeychainKind_lower(keychain),$0
    )
})
}
    
    /**
     * Peek an address of the given `keychain` at `index` without revealing it.
     *
     * For non-wildcard descriptors this returns the same address at every provided index.
     *
     * # Panics
     *
     * This panics when the caller requests for an address of derivation index greater than the
     * [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) max index.
     */
open func peekAddress(keychain: KeychainKind, index: UInt32) -> AddressInfo  {
    return try!  FfiConverterTypeAddressInfo_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_peek_address(self.uniffiClonePointer(),
        FfiConverterTypeKeychainKind_lower(keychain),
        FfiConverterUInt32.lower(index),$0
    )
})
}
    
    /**
     * Persist staged changes of wallet into persister.
     *
     * Returns whether any new changes were persisted.
     *
     * If the persister errors, the staged changes will not be cleared.
     */
open func persist(persister: Persister)throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypePersistenceError_lift) {
    uniffi_bdkffi_fn_method_wallet_persist(self.uniffiClonePointer(),
        FfiConverterTypePersister_lower(persister),$0
    )
})
}
    
    /**
     * Return the spending policies for the wallet’s descriptor.
     */
open func policies(keychain: KeychainKind)throws  -> Policy?  {
    return try  FfiConverterOptionTypePolicy.lift(try rustCallWithError(FfiConverterTypeDescriptorError_lift) {
    uniffi_bdkffi_fn_method_wallet_policies(self.uniffiClonePointer(),
        FfiConverterTypeKeychainKind_lower(keychain),$0
    )
})
}
    
    /**
     * Returns the descriptor used to create addresses for a particular `keychain`.
     *
     * It's the "public" version of the wallet's descriptor, meaning a new descriptor that has
     * the same structure but with the all secret keys replaced by their corresponding public key.
     * This can be used to build a watch-only version of a wallet.
     */
open func publicDescriptor(keychain: KeychainKind) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_public_descriptor(self.uniffiClonePointer(),
        FfiConverterTypeKeychainKind_lower(keychain),$0
    )
})
}
    
    /**
     * Reveal addresses up to and including the target `index` and return an iterator
     * of newly revealed addresses.
     *
     * If the target `index` is unreachable, we make a best effort to reveal up to the last
     * possible index. If all addresses up to the given `index` are already revealed, then
     * no new addresses are returned.
     *
     * **WARNING**: To avoid address reuse you must persist the changes resulting from one or more
     * calls to this method before closing the wallet. See [`Wallet::reveal_next_address`].
     */
open func revealAddressesTo(keychain: KeychainKind, index: UInt32) -> [AddressInfo]  {
    return try!  FfiConverterSequenceTypeAddressInfo.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_reveal_addresses_to(self.uniffiClonePointer(),
        FfiConverterTypeKeychainKind_lower(keychain),
        FfiConverterUInt32.lower(index),$0
    )
})
}
    
    /**
     * Attempt to reveal the next address of the given `keychain`.
     *
     * This will increment the keychain's derivation index. If the keychain's descriptor doesn't
     * contain a wildcard or every address is already revealed up to the maximum derivation
     * index defined in [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki),
     * then the last revealed address will be returned.
     */
open func revealNextAddress(keychain: KeychainKind) -> AddressInfo  {
    return try!  FfiConverterTypeAddressInfo_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_reveal_next_address(self.uniffiClonePointer(),
        FfiConverterTypeKeychainKind_lower(keychain),$0
    )
})
}
    
    /**
     * Compute the `tx`'s sent and received [`Amount`]s.
     *
     * This method returns a tuple `(sent, received)`. Sent is the sum of the txin amounts
     * that spend from previous txouts tracked by this wallet. Received is the summation
     * of this tx's outputs that send to script pubkeys tracked by this wallet.
     */
open func sentAndReceived(tx: Transaction) -> SentAndReceivedValues  {
    return try!  FfiConverterTypeSentAndReceivedValues_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_sent_and_received(self.uniffiClonePointer(),
        FfiConverterTypeTransaction_lower(tx),$0
    )
})
}
    
    /**
     * Sign a transaction with all the wallet's signers, in the order specified by every signer's
     * [`SignerOrdering`]. This function returns the `Result` type with an encapsulated `bool` that
     * has the value true if the PSBT was finalized, or false otherwise.
     *
     * The [`SignOptions`] can be used to tweak the behavior of the software signers, and the way
     * the transaction is finalized at the end. Note that it can't be guaranteed that *every*
     * signers will follow the options, but the "software signers" (WIF keys and `xprv`) defined
     * in this library will.
     */
open func sign(psbt: Psbt, signOptions: SignOptions? = nil)throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeSignerError_lift) {
    uniffi_bdkffi_fn_method_wallet_sign(self.uniffiClonePointer(),
        FfiConverterTypePsbt_lower(psbt),
        FfiConverterOptionTypeSignOptions.lower(signOptions),$0
    )
})
}
    
    /**
     * Create a [`FullScanRequest] for this wallet.
     *
     * This is the first step when performing a spk-based wallet full scan, the returned
     * [`FullScanRequest] collects iterators for the wallet's keychain script pub keys needed to
     * start a blockchain full scan with a spk based blockchain client.
     *
     * This operation is generally only used when importing or restoring a previously used wallet
     * in which the list of used scripts is not known.
     */
open func startFullScan() -> FullScanRequestBuilder  {
    return try!  FfiConverterTypeFullScanRequestBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_start_full_scan(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Create a partial [`SyncRequest`] for this wallet for all revealed spks.
     *
     * This is the first step when performing a spk-based wallet partial sync, the returned
     * [`SyncRequest`] collects all revealed script pubkeys from the wallet keychain needed to
     * start a blockchain sync with a spk based blockchain client.
     */
open func startSyncWithRevealedSpks() -> SyncRequestBuilder  {
    return try!  FfiConverterTypeSyncRequestBuilder_lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_start_sync_with_revealed_spks(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Iterate over the transactions in the wallet.
     */
open func transactions() -> [CanonicalTx]  {
    return try!  FfiConverterSequenceTypeCanonicalTx.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_transactions(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get the [`TxDetails`] of a wallet transaction.
     */
open func txDetails(txid: Txid) -> TxDetails?  {
    return try!  FfiConverterOptionTypeTxDetails.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wallet_tx_details(self.uniffiClonePointer(),
        FfiConverterTypeTxid_lower(txid),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWallet: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Wallet

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Wallet {
        return Wallet(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Wallet) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Wallet {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Wallet, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWallet_lift(_ pointer: UnsafeMutableRawPointer) throws -> Wallet {
    return try FfiConverterTypeWallet.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWallet_lower(_ value: Wallet) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWallet.lower(value)
}






/**
 * A bitcoin transaction identifier, including witness data.
 * For transactions with no SegWit inputs, the `txid` will be equivalent to `wtxid`.
 */
public protocol WtxidProtocol: AnyObject, Sendable {
    
    /**
     * Serialize this type into a 32 byte array.
     */
    func serialize()  -> Data
    
}
/**
 * A bitcoin transaction identifier, including witness data.
 * For transactions with no SegWit inputs, the `txid` will be equivalent to `wtxid`.
 */
open class Wtxid: WtxidProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bdkffi_fn_clone_wtxid(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bdkffi_fn_free_wtxid(pointer, $0) }
    }

    
    /**
     * Construct a hash-like type from 32 bytes.
     */
public static func fromBytes(bytes: Data)throws  -> Wtxid  {
    return try  FfiConverterTypeWtxid_lift(try rustCallWithError(FfiConverterTypeHashParseError_lift) {
    uniffi_bdkffi_fn_constructor_wtxid_from_bytes(
        FfiConverterData.lower(bytes),$0
    )
})
}
    
    /**
     * Construct a hash-like type from a hex string.
     */
public static func fromString(hex: String)throws  -> Wtxid  {
    return try  FfiConverterTypeWtxid_lift(try rustCallWithError(FfiConverterTypeHashParseError_lift) {
    uniffi_bdkffi_fn_constructor_wtxid_from_string(
        FfiConverterString.lower(hex),$0
    )
})
}
    

    
    /**
     * Serialize this type into a 32 byte array.
     */
open func serialize() -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_bdkffi_fn_method_wtxid_serialize(self.uniffiClonePointer(),$0
    )
})
}
    
    open var description: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_wtxid_uniffi_trait_display(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Wtxid, other: Wtxid) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_wtxid_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeWtxid_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_bdkffi_fn_method_wtxid_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension Wtxid: CustomStringConvertible {}
extension Wtxid: Equatable {}
extension Wtxid: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWtxid: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Wtxid

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Wtxid {
        return Wtxid(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Wtxid) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Wtxid {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Wtxid, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWtxid_lift(_ pointer: UnsafeMutableRawPointer) throws -> Wtxid {
    return try FfiConverterTypeWtxid.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWtxid_lower(_ value: Wtxid) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWtxid.lower(value)
}




/**
 * A derived address and the index it was found at.
 */
public struct AddressInfo {
    /**
     * Child index of this address
     */
    public var index: UInt32
    /**
     * The address
     */
    public var address: Address
    /**
     * Type of keychain
     */
    public var keychain: KeychainKind

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Child index of this address
         */index: UInt32, 
        /**
         * The address
         */address: Address, 
        /**
         * Type of keychain
         */keychain: KeychainKind) {
        self.index = index
        self.address = address
        self.keychain = keychain
    }
}

#if compiler(>=6)
extension AddressInfo: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddressInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressInfo {
        return
            try AddressInfo(
                index: FfiConverterUInt32.read(from: &buf), 
                address: FfiConverterTypeAddress.read(from: &buf), 
                keychain: FfiConverterTypeKeychainKind.read(from: &buf)
        )
    }

    public static func write(_ value: AddressInfo, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.index, into: &buf)
        FfiConverterTypeAddress.write(value.address, into: &buf)
        FfiConverterTypeKeychainKind.write(value.keychain, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressInfo_lift(_ buf: RustBuffer) throws -> AddressInfo {
    return try FfiConverterTypeAddressInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressInfo_lower(_ value: AddressInfo) -> RustBuffer {
    return FfiConverterTypeAddressInfo.lower(value)
}


public struct Anchor {
    public var confirmationBlockTime: ConfirmationBlockTime
    public var txid: Txid

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(confirmationBlockTime: ConfirmationBlockTime, txid: Txid) {
        self.confirmationBlockTime = confirmationBlockTime
        self.txid = txid
    }
}

#if compiler(>=6)
extension Anchor: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAnchor: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Anchor {
        return
            try Anchor(
                confirmationBlockTime: FfiConverterTypeConfirmationBlockTime.read(from: &buf), 
                txid: FfiConverterTypeTxid.read(from: &buf)
        )
    }

    public static func write(_ value: Anchor, into buf: inout [UInt8]) {
        FfiConverterTypeConfirmationBlockTime.write(value.confirmationBlockTime, into: &buf)
        FfiConverterTypeTxid.write(value.txid, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAnchor_lift(_ buf: RustBuffer) throws -> Anchor {
    return try FfiConverterTypeAnchor.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAnchor_lower(_ value: Anchor) -> RustBuffer {
    return FfiConverterTypeAnchor.lower(value)
}


/**
 * Balance, differentiated into various categories.
 */
public struct Balance {
    /**
     * All coinbase outputs not yet matured
     */
    public var immature: Amount
    /**
     * Unconfirmed UTXOs generated by a wallet tx
     */
    public var trustedPending: Amount
    /**
     * Unconfirmed UTXOs received from an external wallet
     */
    public var untrustedPending: Amount
    /**
     * Confirmed and immediately spendable balance
     */
    public var confirmed: Amount
    /**
     * Get sum of trusted_pending and confirmed coins.
     *
     * This is the balance you can spend right now that shouldn't get cancelled via another party
     * double spending it.
     */
    public var trustedSpendable: Amount
    /**
     * Get the whole balance visible to the wallet.
     */
    public var total: Amount

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * All coinbase outputs not yet matured
         */immature: Amount, 
        /**
         * Unconfirmed UTXOs generated by a wallet tx
         */trustedPending: Amount, 
        /**
         * Unconfirmed UTXOs received from an external wallet
         */untrustedPending: Amount, 
        /**
         * Confirmed and immediately spendable balance
         */confirmed: Amount, 
        /**
         * Get sum of trusted_pending and confirmed coins.
         *
         * This is the balance you can spend right now that shouldn't get cancelled via another party
         * double spending it.
         */trustedSpendable: Amount, 
        /**
         * Get the whole balance visible to the wallet.
         */total: Amount) {
        self.immature = immature
        self.trustedPending = trustedPending
        self.untrustedPending = untrustedPending
        self.confirmed = confirmed
        self.trustedSpendable = trustedSpendable
        self.total = total
    }
}

#if compiler(>=6)
extension Balance: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBalance: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Balance {
        return
            try Balance(
                immature: FfiConverterTypeAmount.read(from: &buf), 
                trustedPending: FfiConverterTypeAmount.read(from: &buf), 
                untrustedPending: FfiConverterTypeAmount.read(from: &buf), 
                confirmed: FfiConverterTypeAmount.read(from: &buf), 
                trustedSpendable: FfiConverterTypeAmount.read(from: &buf), 
                total: FfiConverterTypeAmount.read(from: &buf)
        )
    }

    public static func write(_ value: Balance, into buf: inout [UInt8]) {
        FfiConverterTypeAmount.write(value.immature, into: &buf)
        FfiConverterTypeAmount.write(value.trustedPending, into: &buf)
        FfiConverterTypeAmount.write(value.untrustedPending, into: &buf)
        FfiConverterTypeAmount.write(value.confirmed, into: &buf)
        FfiConverterTypeAmount.write(value.trustedSpendable, into: &buf)
        FfiConverterTypeAmount.write(value.total, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBalance_lift(_ buf: RustBuffer) throws -> Balance {
    return try FfiConverterTypeBalance.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBalance_lower(_ value: Balance) -> RustBuffer {
    return FfiConverterTypeBalance.lower(value)
}


/**
 * A reference to a block in the canonical chain.
 */
public struct BlockId {
    /**
     * The height of the block.
     */
    public var height: UInt32
    /**
     * The hash of the block.
     */
    public var hash: BlockHash

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The height of the block.
         */height: UInt32, 
        /**
         * The hash of the block.
         */hash: BlockHash) {
        self.height = height
        self.hash = hash
    }
}

#if compiler(>=6)
extension BlockId: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBlockId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlockId {
        return
            try BlockId(
                height: FfiConverterUInt32.read(from: &buf), 
                hash: FfiConverterTypeBlockHash.read(from: &buf)
        )
    }

    public static func write(_ value: BlockId, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.height, into: &buf)
        FfiConverterTypeBlockHash.write(value.hash, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlockId_lift(_ buf: RustBuffer) throws -> BlockId {
    return try FfiConverterTypeBlockId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlockId_lower(_ value: BlockId) -> RustBuffer {
    return FfiConverterTypeBlockId.lower(value)
}


/**
 * A transaction that is deemed to be part of the canonical history.
 */
public struct CanonicalTx {
    /**
     * The transaction.
     */
    public var transaction: Transaction
    /**
     * How the transaction is observed in the canonical chain (confirmed or unconfirmed).
     */
    public var chainPosition: ChainPosition

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The transaction.
         */transaction: Transaction, 
        /**
         * How the transaction is observed in the canonical chain (confirmed or unconfirmed).
         */chainPosition: ChainPosition) {
        self.transaction = transaction
        self.chainPosition = chainPosition
    }
}

#if compiler(>=6)
extension CanonicalTx: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCanonicalTx: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CanonicalTx {
        return
            try CanonicalTx(
                transaction: FfiConverterTypeTransaction.read(from: &buf), 
                chainPosition: FfiConverterTypeChainPosition.read(from: &buf)
        )
    }

    public static func write(_ value: CanonicalTx, into buf: inout [UInt8]) {
        FfiConverterTypeTransaction.write(value.transaction, into: &buf)
        FfiConverterTypeChainPosition.write(value.chainPosition, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCanonicalTx_lift(_ buf: RustBuffer) throws -> CanonicalTx {
    return try FfiConverterTypeCanonicalTx.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCanonicalTx_lower(_ value: CanonicalTx) -> RustBuffer {
    return FfiConverterTypeCanonicalTx.lower(value)
}


/**
 * Receive a [`CbfClient`] and [`CbfNode`].
 */
public struct CbfComponents {
    /**
     * Publish events to the node, like broadcasting transactions or adding scripts.
     */
    public var client: CbfClient
    /**
     * The node to run and fetch transactions for a [`Wallet`].
     */
    public var node: CbfNode

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Publish events to the node, like broadcasting transactions or adding scripts.
         */client: CbfClient, 
        /**
         * The node to run and fetch transactions for a [`Wallet`].
         */node: CbfNode) {
        self.client = client
        self.node = node
    }
}

#if compiler(>=6)
extension CbfComponents: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCbfComponents: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CbfComponents {
        return
            try CbfComponents(
                client: FfiConverterTypeCbfClient.read(from: &buf), 
                node: FfiConverterTypeCbfNode.read(from: &buf)
        )
    }

    public static func write(_ value: CbfComponents, into buf: inout [UInt8]) {
        FfiConverterTypeCbfClient.write(value.client, into: &buf)
        FfiConverterTypeCbfNode.write(value.node, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCbfComponents_lift(_ buf: RustBuffer) throws -> CbfComponents {
    return try FfiConverterTypeCbfComponents.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCbfComponents_lower(_ value: CbfComponents) -> RustBuffer {
    return FfiConverterTypeCbfComponents.lower(value)
}


/**
 * The hash added or removed at the given height.
 */
public struct ChainChange {
    /**
     * Effected height
     */
    public var height: UInt32
    /**
     * A hash was added or must be removed.
     */
    public var hash: BlockHash?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Effected height
         */height: UInt32, 
        /**
         * A hash was added or must be removed.
         */hash: BlockHash?) {
        self.height = height
        self.hash = hash
    }
}

#if compiler(>=6)
extension ChainChange: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeChainChange: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChainChange {
        return
            try ChainChange(
                height: FfiConverterUInt32.read(from: &buf), 
                hash: FfiConverterOptionTypeBlockHash.read(from: &buf)
        )
    }

    public static func write(_ value: ChainChange, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.height, into: &buf)
        FfiConverterOptionTypeBlockHash.write(value.hash, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChainChange_lift(_ buf: RustBuffer) throws -> ChainChange {
    return try FfiConverterTypeChainChange.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChainChange_lower(_ value: ChainChange) -> RustBuffer {
    return FfiConverterTypeChainChange.lower(value)
}


/**
 * An extra condition that must be satisfied but that is out of control of the user
 */
public struct Condition {
    /**
     * Optional CheckSequenceVerify condition
     */
    public var csv: UInt32?
    /**
     * Optional timelock condition
     */
    public var timelock: LockTime?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Optional CheckSequenceVerify condition
         */csv: UInt32?, 
        /**
         * Optional timelock condition
         */timelock: LockTime?) {
        self.csv = csv
        self.timelock = timelock
    }
}

#if compiler(>=6)
extension Condition: Sendable {}
#endif


extension Condition: Equatable, Hashable {
    public static func ==(lhs: Condition, rhs: Condition) -> Bool {
        if lhs.csv != rhs.csv {
            return false
        }
        if lhs.timelock != rhs.timelock {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(csv)
        hasher.combine(timelock)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCondition: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Condition {
        return
            try Condition(
                csv: FfiConverterOptionUInt32.read(from: &buf), 
                timelock: FfiConverterOptionTypeLockTime.read(from: &buf)
        )
    }

    public static func write(_ value: Condition, into buf: inout [UInt8]) {
        FfiConverterOptionUInt32.write(value.csv, into: &buf)
        FfiConverterOptionTypeLockTime.write(value.timelock, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCondition_lift(_ buf: RustBuffer) throws -> Condition {
    return try FfiConverterTypeCondition.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCondition_lower(_ value: Condition) -> RustBuffer {
    return FfiConverterTypeCondition.lower(value)
}


/**
 * Represents the confirmation block and time of a transaction.
 */
public struct ConfirmationBlockTime {
    /**
     * The anchor block.
     */
    public var blockId: BlockId
    /**
     * The confirmation time of the transaction being anchored.
     */
    public var confirmationTime: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The anchor block.
         */blockId: BlockId, 
        /**
         * The confirmation time of the transaction being anchored.
         */confirmationTime: UInt64) {
        self.blockId = blockId
        self.confirmationTime = confirmationTime
    }
}

#if compiler(>=6)
extension ConfirmationBlockTime: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConfirmationBlockTime: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfirmationBlockTime {
        return
            try ConfirmationBlockTime(
                blockId: FfiConverterTypeBlockId.read(from: &buf), 
                confirmationTime: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ConfirmationBlockTime, into buf: inout [UInt8]) {
        FfiConverterTypeBlockId.write(value.blockId, into: &buf)
        FfiConverterUInt64.write(value.confirmationTime, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfirmationBlockTime_lift(_ buf: RustBuffer) throws -> ConfirmationBlockTime {
    return try FfiConverterTypeConfirmationBlockTime.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfirmationBlockTime_lower(_ value: ConfirmationBlockTime) -> RustBuffer {
    return FfiConverterTypeConfirmationBlockTime.lower(value)
}


/**
 * This type replaces the Rust tuple `(txid, evicted_at)` used in the Wallet::apply_evicted_txs` method,
 * where `evicted_at` is the timestamp of when the transaction `txid` was evicted from the mempool.
 * Transactions may be evicted for paying a low fee rate or having invalid scripts.
 */
public struct EvictedTx {
    public var txid: Txid
    public var evictedAt: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txid: Txid, evictedAt: UInt64) {
        self.txid = txid
        self.evictedAt = evictedAt
    }
}

#if compiler(>=6)
extension EvictedTx: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEvictedTx: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EvictedTx {
        return
            try EvictedTx(
                txid: FfiConverterTypeTxid.read(from: &buf), 
                evictedAt: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: EvictedTx, into buf: inout [UInt8]) {
        FfiConverterTypeTxid.write(value.txid, into: &buf)
        FfiConverterUInt64.write(value.evictedAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEvictedTx_lift(_ buf: RustBuffer) throws -> EvictedTx {
    return try FfiConverterTypeEvictedTx.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEvictedTx_lower(_ value: EvictedTx) -> RustBuffer {
    return FfiConverterTypeEvictedTx.lower(value)
}


public struct FinalizedPsbtResult {
    public var psbt: Psbt
    public var couldFinalize: Bool
    public var errors: [PsbtFinalizeError]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(psbt: Psbt, couldFinalize: Bool, errors: [PsbtFinalizeError]?) {
        self.psbt = psbt
        self.couldFinalize = couldFinalize
        self.errors = errors
    }
}

#if compiler(>=6)
extension FinalizedPsbtResult: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFinalizedPsbtResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FinalizedPsbtResult {
        return
            try FinalizedPsbtResult(
                psbt: FfiConverterTypePsbt.read(from: &buf), 
                couldFinalize: FfiConverterBool.read(from: &buf), 
                errors: FfiConverterOptionSequenceTypePsbtFinalizeError.read(from: &buf)
        )
    }

    public static func write(_ value: FinalizedPsbtResult, into buf: inout [UInt8]) {
        FfiConverterTypePsbt.write(value.psbt, into: &buf)
        FfiConverterBool.write(value.couldFinalize, into: &buf)
        FfiConverterOptionSequenceTypePsbtFinalizeError.write(value.errors, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFinalizedPsbtResult_lift(_ buf: RustBuffer) throws -> FinalizedPsbtResult {
    return try FfiConverterTypeFinalizedPsbtResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFinalizedPsbtResult_lower(_ value: FinalizedPsbtResult) -> RustBuffer {
    return FfiConverterTypeFinalizedPsbtResult.lower(value)
}


/**
 * Bitcoin block header.
 * Contains all the block’s information except the actual transactions, but including a root of a merkle tree
 * committing to all transactions in the block.
 */
public struct Header {
    /**
     * Block version, now repurposed for soft fork signalling.
     */
    public var version: Int32
    /**
     * Reference to the previous block in the chain.
     */
    public var prevBlockhash: BlockHash
    /**
     * The root hash of the merkle tree of transactions in the block.
     */
    public var merkleRoot: TxMerkleNode
    /**
     * The timestamp of the block, as claimed by the miner.
     */
    public var time: UInt32
    /**
     * The target value below which the blockhash must lie.
     */
    public var bits: UInt32
    /**
     * The nonce, selected to obtain a low enough blockhash.
     */
    public var nonce: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Block version, now repurposed for soft fork signalling.
         */version: Int32, 
        /**
         * Reference to the previous block in the chain.
         */prevBlockhash: BlockHash, 
        /**
         * The root hash of the merkle tree of transactions in the block.
         */merkleRoot: TxMerkleNode, 
        /**
         * The timestamp of the block, as claimed by the miner.
         */time: UInt32, 
        /**
         * The target value below which the blockhash must lie.
         */bits: UInt32, 
        /**
         * The nonce, selected to obtain a low enough blockhash.
         */nonce: UInt32) {
        self.version = version
        self.prevBlockhash = prevBlockhash
        self.merkleRoot = merkleRoot
        self.time = time
        self.bits = bits
        self.nonce = nonce
    }
}

#if compiler(>=6)
extension Header: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHeader: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Header {
        return
            try Header(
                version: FfiConverterInt32.read(from: &buf), 
                prevBlockhash: FfiConverterTypeBlockHash.read(from: &buf), 
                merkleRoot: FfiConverterTypeTxMerkleNode.read(from: &buf), 
                time: FfiConverterUInt32.read(from: &buf), 
                bits: FfiConverterUInt32.read(from: &buf), 
                nonce: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: Header, into buf: inout [UInt8]) {
        FfiConverterInt32.write(value.version, into: &buf)
        FfiConverterTypeBlockHash.write(value.prevBlockhash, into: &buf)
        FfiConverterTypeTxMerkleNode.write(value.merkleRoot, into: &buf)
        FfiConverterUInt32.write(value.time, into: &buf)
        FfiConverterUInt32.write(value.bits, into: &buf)
        FfiConverterUInt32.write(value.nonce, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHeader_lift(_ buf: RustBuffer) throws -> Header {
    return try FfiConverterTypeHeader.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHeader_lower(_ value: Header) -> RustBuffer {
    return FfiConverterTypeHeader.lower(value)
}


/**
 * Notification of a new block header.
 */
public struct HeaderNotification {
    /**
     * New block height.
     */
    public var height: UInt64
    /**
     * Newly added header.
     */
    public var header: Header

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * New block height.
         */height: UInt64, 
        /**
         * Newly added header.
         */header: Header) {
        self.height = height
        self.header = header
    }
}

#if compiler(>=6)
extension HeaderNotification: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHeaderNotification: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HeaderNotification {
        return
            try HeaderNotification(
                height: FfiConverterUInt64.read(from: &buf), 
                header: FfiConverterTypeHeader.read(from: &buf)
        )
    }

    public static func write(_ value: HeaderNotification, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.height, into: &buf)
        FfiConverterTypeHeader.write(value.header, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHeaderNotification_lift(_ buf: RustBuffer) throws -> HeaderNotification {
    return try FfiConverterTypeHeaderNotification.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHeaderNotification_lower(_ value: HeaderNotification) -> RustBuffer {
    return FfiConverterTypeHeaderNotification.lower(value)
}


/**
 * Mapping of descriptors to their last revealed index.
 */
public struct IndexerChangeSet {
    public var lastRevealed: [DescriptorId: UInt32]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lastRevealed: [DescriptorId: UInt32]) {
        self.lastRevealed = lastRevealed
    }
}

#if compiler(>=6)
extension IndexerChangeSet: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIndexerChangeSet: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IndexerChangeSet {
        return
            try IndexerChangeSet(
                lastRevealed: FfiConverterDictionaryTypeDescriptorIdUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: IndexerChangeSet, into buf: inout [UInt8]) {
        FfiConverterDictionaryTypeDescriptorIdUInt32.write(value.lastRevealed, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIndexerChangeSet_lift(_ buf: RustBuffer) throws -> IndexerChangeSet {
    return try FfiConverterTypeIndexerChangeSet.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIndexerChangeSet_lower(_ value: IndexerChangeSet) -> RustBuffer {
    return FfiConverterTypeIndexerChangeSet.lower(value)
}


/**
 * The keychain kind and the index in that keychain.
 */
public struct KeychainAndIndex {
    /**
     * Type of keychains.
     */
    public var keychain: KeychainKind
    /**
     * The index in the keychain.
     */
    public var index: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Type of keychains.
         */keychain: KeychainKind, 
        /**
         * The index in the keychain.
         */index: UInt32) {
        self.keychain = keychain
        self.index = index
    }
}

#if compiler(>=6)
extension KeychainAndIndex: Sendable {}
#endif


extension KeychainAndIndex: Equatable, Hashable {
    public static func ==(lhs: KeychainAndIndex, rhs: KeychainAndIndex) -> Bool {
        if lhs.keychain != rhs.keychain {
            return false
        }
        if lhs.index != rhs.index {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(keychain)
        hasher.combine(index)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKeychainAndIndex: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeychainAndIndex {
        return
            try KeychainAndIndex(
                keychain: FfiConverterTypeKeychainKind.read(from: &buf), 
                index: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: KeychainAndIndex, into buf: inout [UInt8]) {
        FfiConverterTypeKeychainKind.write(value.keychain, into: &buf)
        FfiConverterUInt32.write(value.index, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeychainAndIndex_lift(_ buf: RustBuffer) throws -> KeychainAndIndex {
    return try FfiConverterTypeKeychainAndIndex.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeychainAndIndex_lower(_ value: KeychainAndIndex) -> RustBuffer {
    return FfiConverterTypeKeychainAndIndex.lower(value)
}


/**
 * Changes to the local chain
 */
public struct LocalChainChangeSet {
    public var changes: [ChainChange]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(changes: [ChainChange]) {
        self.changes = changes
    }
}

#if compiler(>=6)
extension LocalChainChangeSet: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLocalChainChangeSet: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocalChainChangeSet {
        return
            try LocalChainChangeSet(
                changes: FfiConverterSequenceTypeChainChange.read(from: &buf)
        )
    }

    public static func write(_ value: LocalChainChangeSet, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeChainChange.write(value.changes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLocalChainChangeSet_lift(_ buf: RustBuffer) throws -> LocalChainChangeSet {
    return try FfiConverterTypeLocalChainChangeSet.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLocalChainChangeSet_lower(_ value: LocalChainChangeSet) -> RustBuffer {
    return FfiConverterTypeLocalChainChangeSet.lower(value)
}


/**
 * An unspent output owned by a [`Wallet`].
 */
public struct LocalOutput {
    /**
     * Reference to a transaction output
     */
    public var outpoint: OutPoint
    /**
     * Transaction output
     */
    public var txout: TxOut
    /**
     * Type of keychain
     */
    public var keychain: KeychainKind
    /**
     * Whether this UTXO is spent or not
     */
    public var isSpent: Bool
    /**
     * The derivation index for the script pubkey in the wallet
     */
    public var derivationIndex: UInt32
    /**
     * The position of the output in the blockchain.
     */
    public var chainPosition: ChainPosition

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Reference to a transaction output
         */outpoint: OutPoint, 
        /**
         * Transaction output
         */txout: TxOut, 
        /**
         * Type of keychain
         */keychain: KeychainKind, 
        /**
         * Whether this UTXO is spent or not
         */isSpent: Bool, 
        /**
         * The derivation index for the script pubkey in the wallet
         */derivationIndex: UInt32, 
        /**
         * The position of the output in the blockchain.
         */chainPosition: ChainPosition) {
        self.outpoint = outpoint
        self.txout = txout
        self.keychain = keychain
        self.isSpent = isSpent
        self.derivationIndex = derivationIndex
        self.chainPosition = chainPosition
    }
}

#if compiler(>=6)
extension LocalOutput: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLocalOutput: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocalOutput {
        return
            try LocalOutput(
                outpoint: FfiConverterTypeOutPoint.read(from: &buf), 
                txout: FfiConverterTypeTxOut.read(from: &buf), 
                keychain: FfiConverterTypeKeychainKind.read(from: &buf), 
                isSpent: FfiConverterBool.read(from: &buf), 
                derivationIndex: FfiConverterUInt32.read(from: &buf), 
                chainPosition: FfiConverterTypeChainPosition.read(from: &buf)
        )
    }

    public static func write(_ value: LocalOutput, into buf: inout [UInt8]) {
        FfiConverterTypeOutPoint.write(value.outpoint, into: &buf)
        FfiConverterTypeTxOut.write(value.txout, into: &buf)
        FfiConverterTypeKeychainKind.write(value.keychain, into: &buf)
        FfiConverterBool.write(value.isSpent, into: &buf)
        FfiConverterUInt32.write(value.derivationIndex, into: &buf)
        FfiConverterTypeChainPosition.write(value.chainPosition, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLocalOutput_lift(_ buf: RustBuffer) throws -> LocalOutput {
    return try FfiConverterTypeLocalOutput.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLocalOutput_lower(_ value: LocalOutput) -> RustBuffer {
    return FfiConverterTypeLocalOutput.lower(value)
}


/**
 * A reference to an unspent output by TXID and output index.
 */
public struct OutPoint {
    /**
     * The transaction.
     */
    public var txid: Txid
    /**
     * The index of the output in the transaction.
     */
    public var vout: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The transaction.
         */txid: Txid, 
        /**
         * The index of the output in the transaction.
         */vout: UInt32) {
        self.txid = txid
        self.vout = vout
    }
}

#if compiler(>=6)
extension OutPoint: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOutPoint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OutPoint {
        return
            try OutPoint(
                txid: FfiConverterTypeTxid.read(from: &buf), 
                vout: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: OutPoint, into buf: inout [UInt8]) {
        FfiConverterTypeTxid.write(value.txid, into: &buf)
        FfiConverterUInt32.write(value.vout, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOutPoint_lift(_ buf: RustBuffer) throws -> OutPoint {
    return try FfiConverterTypeOutPoint.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOutPoint_lower(_ value: OutPoint) -> RustBuffer {
    return FfiConverterTypeOutPoint.lower(value)
}


/**
 * A peer to connect to over the Bitcoin peer-to-peer network.
 */
public struct Peer {
    /**
     * The IP address to reach the node.
     */
    public var address: IpAddress
    /**
     * The port to reach the node. If none is provided, the default
     * port for the selected network will be used.
     */
    public var port: UInt16?
    /**
     * Does the remote node offer encrypted peer-to-peer connection.
     */
    public var v2Transport: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The IP address to reach the node.
         */address: IpAddress, 
        /**
         * The port to reach the node. If none is provided, the default
         * port for the selected network will be used.
         */port: UInt16?, 
        /**
         * Does the remote node offer encrypted peer-to-peer connection.
         */v2Transport: Bool) {
        self.address = address
        self.port = port
        self.v2Transport = v2Transport
    }
}

#if compiler(>=6)
extension Peer: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePeer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Peer {
        return
            try Peer(
                address: FfiConverterTypeIpAddress.read(from: &buf), 
                port: FfiConverterOptionUInt16.read(from: &buf), 
                v2Transport: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: Peer, into buf: inout [UInt8]) {
        FfiConverterTypeIpAddress.write(value.address, into: &buf)
        FfiConverterOptionUInt16.write(value.port, into: &buf)
        FfiConverterBool.write(value.v2Transport, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePeer_lift(_ buf: RustBuffer) throws -> Peer {
    return try FfiConverterTypePeer.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePeer_lower(_ value: Peer) -> RustBuffer {
    return FfiConverterTypePeer.lower(value)
}


/**
 * A bitcoin script and associated amount.
 */
public struct ScriptAmount {
    /**
     * The underlying script.
     */
    public var script: Script
    /**
     * The amount owned by the script.
     */
    public var amount: Amount

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The underlying script.
         */script: Script, 
        /**
         * The amount owned by the script.
         */amount: Amount) {
        self.script = script
        self.amount = amount
    }
}

#if compiler(>=6)
extension ScriptAmount: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeScriptAmount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScriptAmount {
        return
            try ScriptAmount(
                script: FfiConverterTypeScript.read(from: &buf), 
                amount: FfiConverterTypeAmount.read(from: &buf)
        )
    }

    public static func write(_ value: ScriptAmount, into buf: inout [UInt8]) {
        FfiConverterTypeScript.write(value.script, into: &buf)
        FfiConverterTypeAmount.write(value.amount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeScriptAmount_lift(_ buf: RustBuffer) throws -> ScriptAmount {
    return try FfiConverterTypeScriptAmount.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeScriptAmount_lower(_ value: ScriptAmount) -> RustBuffer {
    return FfiConverterTypeScriptAmount.lower(value)
}


/**
 * The total value sent and received.
 */
public struct SentAndReceivedValues {
    /**
     * Amount sent in the transaction.
     */
    public var sent: Amount
    /**
     * The amount received in the transaction, possibly as a change output(s).
     */
    public var received: Amount

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Amount sent in the transaction.
         */sent: Amount, 
        /**
         * The amount received in the transaction, possibly as a change output(s).
         */received: Amount) {
        self.sent = sent
        self.received = received
    }
}

#if compiler(>=6)
extension SentAndReceivedValues: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSentAndReceivedValues: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SentAndReceivedValues {
        return
            try SentAndReceivedValues(
                sent: FfiConverterTypeAmount.read(from: &buf), 
                received: FfiConverterTypeAmount.read(from: &buf)
        )
    }

    public static func write(_ value: SentAndReceivedValues, into buf: inout [UInt8]) {
        FfiConverterTypeAmount.write(value.sent, into: &buf)
        FfiConverterTypeAmount.write(value.received, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSentAndReceivedValues_lift(_ buf: RustBuffer) throws -> SentAndReceivedValues {
    return try FfiConverterTypeSentAndReceivedValues.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSentAndReceivedValues_lower(_ value: SentAndReceivedValues) -> RustBuffer {
    return FfiConverterTypeSentAndReceivedValues.lower(value)
}


/**
 * Response to an ElectrumClient.server_features request.
 */
public struct ServerFeaturesRes {
    /**
     * Server version reported.
     */
    public var serverVersion: String
    /**
     * Hash of the genesis block.
     */
    public var genesisHash: BlockHash
    /**
     * Minimum supported version of the protocol.
     */
    public var protocolMin: String
    /**
     * Maximum supported version of the protocol.
     */
    public var protocolMax: String
    /**
     * Hash function used to create the `ScriptHash`.
     */
    public var hashFunction: String?
    /**
     * Pruned height of the server.
     */
    public var pruning: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Server version reported.
         */serverVersion: String, 
        /**
         * Hash of the genesis block.
         */genesisHash: BlockHash, 
        /**
         * Minimum supported version of the protocol.
         */protocolMin: String, 
        /**
         * Maximum supported version of the protocol.
         */protocolMax: String, 
        /**
         * Hash function used to create the `ScriptHash`.
         */hashFunction: String?, 
        /**
         * Pruned height of the server.
         */pruning: Int64?) {
        self.serverVersion = serverVersion
        self.genesisHash = genesisHash
        self.protocolMin = protocolMin
        self.protocolMax = protocolMax
        self.hashFunction = hashFunction
        self.pruning = pruning
    }
}

#if compiler(>=6)
extension ServerFeaturesRes: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeServerFeaturesRes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ServerFeaturesRes {
        return
            try ServerFeaturesRes(
                serverVersion: FfiConverterString.read(from: &buf), 
                genesisHash: FfiConverterTypeBlockHash.read(from: &buf), 
                protocolMin: FfiConverterString.read(from: &buf), 
                protocolMax: FfiConverterString.read(from: &buf), 
                hashFunction: FfiConverterOptionString.read(from: &buf), 
                pruning: FfiConverterOptionInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ServerFeaturesRes, into buf: inout [UInt8]) {
        FfiConverterString.write(value.serverVersion, into: &buf)
        FfiConverterTypeBlockHash.write(value.genesisHash, into: &buf)
        FfiConverterString.write(value.protocolMin, into: &buf)
        FfiConverterString.write(value.protocolMax, into: &buf)
        FfiConverterOptionString.write(value.hashFunction, into: &buf)
        FfiConverterOptionInt64.write(value.pruning, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeServerFeaturesRes_lift(_ buf: RustBuffer) throws -> ServerFeaturesRes {
    return try FfiConverterTypeServerFeaturesRes.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeServerFeaturesRes_lower(_ value: ServerFeaturesRes) -> RustBuffer {
    return FfiConverterTypeServerFeaturesRes.lower(value)
}


/**
 * Options for a software signer.
 *
 * Adjust the behavior of our software signers and the way a transaction is finalized.
 */
public struct SignOptions {
    /**
     * Whether the signer should trust the `witness_utxo`, if the `non_witness_utxo` hasn't been
     * provided
     *
     * Defaults to `false` to mitigate the "SegWit bug" which could trick the wallet into
     * paying a fee larger than expected.
     *
     * Some wallets, especially if relatively old, might not provide the `non_witness_utxo` for
     * SegWit transactions in the PSBT they generate: in those cases setting this to `true`
     * should correctly produce a signature, at the expense of an increased trust in the creator
     * of the PSBT.
     *
     * For more details see: <https://blog.trezor.io/details-of-firmware-updates-for-trezor-one-version-1-9-1-and-trezor-model-t-version-2-3-1-1eba8f60f2dd>
     */
    public var trustWitnessUtxo: Bool
    /**
     * Whether the wallet should assume a specific height has been reached when trying to finalize
     * a transaction
     *
     * The wallet will only "use" a timelock to satisfy the spending policy of an input if the
     * timelock height has already been reached. This option allows overriding the "current height" to let the
     * wallet use timelocks in the future to spend a coin.
     */
    public var assumeHeight: UInt32?
    /**
     * Whether the signer should use the `sighash_type` set in the PSBT when signing, no matter
     * what its value is
     *
     * Defaults to `false` which will only allow signing using `SIGHASH_ALL`.
     */
    public var allowAllSighashes: Bool
    /**
     * Whether to try finalizing the PSBT after the inputs are signed.
     *
     * Defaults to `true` which will try finalizing PSBT after inputs are signed.
     */
    public var tryFinalize: Bool
    /**
     * Whether we should try to sign a taproot transaction with the taproot internal key
     * or not. This option is ignored if we're signing a non-taproot PSBT.
     *
     * Defaults to `true`, i.e., we always try to sign with the taproot internal key.
     */
    public var signWithTapInternalKey: Bool
    /**
     * Whether we should grind ECDSA signature to ensure signing with low r
     * or not.
     * Defaults to `true`, i.e., we always grind ECDSA signature to sign with low r.
     */
    public var allowGrinding: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Whether the signer should trust the `witness_utxo`, if the `non_witness_utxo` hasn't been
         * provided
         *
         * Defaults to `false` to mitigate the "SegWit bug" which could trick the wallet into
         * paying a fee larger than expected.
         *
         * Some wallets, especially if relatively old, might not provide the `non_witness_utxo` for
         * SegWit transactions in the PSBT they generate: in those cases setting this to `true`
         * should correctly produce a signature, at the expense of an increased trust in the creator
         * of the PSBT.
         *
         * For more details see: <https://blog.trezor.io/details-of-firmware-updates-for-trezor-one-version-1-9-1-and-trezor-model-t-version-2-3-1-1eba8f60f2dd>
         */trustWitnessUtxo: Bool, 
        /**
         * Whether the wallet should assume a specific height has been reached when trying to finalize
         * a transaction
         *
         * The wallet will only "use" a timelock to satisfy the spending policy of an input if the
         * timelock height has already been reached. This option allows overriding the "current height" to let the
         * wallet use timelocks in the future to spend a coin.
         */assumeHeight: UInt32?, 
        /**
         * Whether the signer should use the `sighash_type` set in the PSBT when signing, no matter
         * what its value is
         *
         * Defaults to `false` which will only allow signing using `SIGHASH_ALL`.
         */allowAllSighashes: Bool, 
        /**
         * Whether to try finalizing the PSBT after the inputs are signed.
         *
         * Defaults to `true` which will try finalizing PSBT after inputs are signed.
         */tryFinalize: Bool, 
        /**
         * Whether we should try to sign a taproot transaction with the taproot internal key
         * or not. This option is ignored if we're signing a non-taproot PSBT.
         *
         * Defaults to `true`, i.e., we always try to sign with the taproot internal key.
         */signWithTapInternalKey: Bool, 
        /**
         * Whether we should grind ECDSA signature to ensure signing with low r
         * or not.
         * Defaults to `true`, i.e., we always grind ECDSA signature to sign with low r.
         */allowGrinding: Bool) {
        self.trustWitnessUtxo = trustWitnessUtxo
        self.assumeHeight = assumeHeight
        self.allowAllSighashes = allowAllSighashes
        self.tryFinalize = tryFinalize
        self.signWithTapInternalKey = signWithTapInternalKey
        self.allowGrinding = allowGrinding
    }
}

#if compiler(>=6)
extension SignOptions: Sendable {}
#endif


extension SignOptions: Equatable, Hashable {
    public static func ==(lhs: SignOptions, rhs: SignOptions) -> Bool {
        if lhs.trustWitnessUtxo != rhs.trustWitnessUtxo {
            return false
        }
        if lhs.assumeHeight != rhs.assumeHeight {
            return false
        }
        if lhs.allowAllSighashes != rhs.allowAllSighashes {
            return false
        }
        if lhs.tryFinalize != rhs.tryFinalize {
            return false
        }
        if lhs.signWithTapInternalKey != rhs.signWithTapInternalKey {
            return false
        }
        if lhs.allowGrinding != rhs.allowGrinding {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(trustWitnessUtxo)
        hasher.combine(assumeHeight)
        hasher.combine(allowAllSighashes)
        hasher.combine(tryFinalize)
        hasher.combine(signWithTapInternalKey)
        hasher.combine(allowGrinding)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignOptions {
        return
            try SignOptions(
                trustWitnessUtxo: FfiConverterBool.read(from: &buf), 
                assumeHeight: FfiConverterOptionUInt32.read(from: &buf), 
                allowAllSighashes: FfiConverterBool.read(from: &buf), 
                tryFinalize: FfiConverterBool.read(from: &buf), 
                signWithTapInternalKey: FfiConverterBool.read(from: &buf), 
                allowGrinding: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: SignOptions, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.trustWitnessUtxo, into: &buf)
        FfiConverterOptionUInt32.write(value.assumeHeight, into: &buf)
        FfiConverterBool.write(value.allowAllSighashes, into: &buf)
        FfiConverterBool.write(value.tryFinalize, into: &buf)
        FfiConverterBool.write(value.signWithTapInternalKey, into: &buf)
        FfiConverterBool.write(value.allowGrinding, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignOptions_lift(_ buf: RustBuffer) throws -> SignOptions {
    return try FfiConverterTypeSignOptions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignOptions_lower(_ value: SignOptions) -> RustBuffer {
    return FfiConverterTypeSignOptions.lower(value)
}


/**
 * A proxy to route network traffic, most likely through a Tor daemon. Normally this proxy is
 * exposed at 127.0.0.1:9050.
 */
public struct Socks5Proxy {
    /**
     * The IP address, likely `127.0.0.1`
     */
    public var address: IpAddress
    /**
     * The listening port, likely `9050`
     */
    public var port: UInt16

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The IP address, likely `127.0.0.1`
         */address: IpAddress, 
        /**
         * The listening port, likely `9050`
         */port: UInt16) {
        self.address = address
        self.port = port
    }
}

#if compiler(>=6)
extension Socks5Proxy: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSocks5Proxy: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Socks5Proxy {
        return
            try Socks5Proxy(
                address: FfiConverterTypeIpAddress.read(from: &buf), 
                port: FfiConverterUInt16.read(from: &buf)
        )
    }

    public static func write(_ value: Socks5Proxy, into buf: inout [UInt8]) {
        FfiConverterTypeIpAddress.write(value.address, into: &buf)
        FfiConverterUInt16.write(value.port, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSocks5Proxy_lift(_ buf: RustBuffer) throws -> Socks5Proxy {
    return try FfiConverterTypeSocks5Proxy.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSocks5Proxy_lower(_ value: Socks5Proxy) -> RustBuffer {
    return FfiConverterTypeSocks5Proxy.lower(value)
}


/**
 * Bitcoin transaction metadata.
 */
public struct Tx {
    /**
     * The transaction identifier.
     */
    public var txid: Txid
    /**
     * The transaction version, of which 0, 1, 2 are standard.
     */
    public var version: Int32
    /**
     * The block height or time restriction on the transaction.
     */
    public var locktime: UInt32
    /**
     * The size of the transaction in bytes.
     */
    public var size: UInt64
    /**
     * The weight units of this transaction.
     */
    public var weight: UInt64
    /**
     * The fee of this transaction in satoshis.
     */
    public var fee: UInt64
    /**
     * Confirmation status and data.
     */
    public var status: TxStatus

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The transaction identifier.
         */txid: Txid, 
        /**
         * The transaction version, of which 0, 1, 2 are standard.
         */version: Int32, 
        /**
         * The block height or time restriction on the transaction.
         */locktime: UInt32, 
        /**
         * The size of the transaction in bytes.
         */size: UInt64, 
        /**
         * The weight units of this transaction.
         */weight: UInt64, 
        /**
         * The fee of this transaction in satoshis.
         */fee: UInt64, 
        /**
         * Confirmation status and data.
         */status: TxStatus) {
        self.txid = txid
        self.version = version
        self.locktime = locktime
        self.size = size
        self.weight = weight
        self.fee = fee
        self.status = status
    }
}

#if compiler(>=6)
extension Tx: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTx: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Tx {
        return
            try Tx(
                txid: FfiConverterTypeTxid.read(from: &buf), 
                version: FfiConverterInt32.read(from: &buf), 
                locktime: FfiConverterUInt32.read(from: &buf), 
                size: FfiConverterUInt64.read(from: &buf), 
                weight: FfiConverterUInt64.read(from: &buf), 
                fee: FfiConverterUInt64.read(from: &buf), 
                status: FfiConverterTypeTxStatus.read(from: &buf)
        )
    }

    public static func write(_ value: Tx, into buf: inout [UInt8]) {
        FfiConverterTypeTxid.write(value.txid, into: &buf)
        FfiConverterInt32.write(value.version, into: &buf)
        FfiConverterUInt32.write(value.locktime, into: &buf)
        FfiConverterUInt64.write(value.size, into: &buf)
        FfiConverterUInt64.write(value.weight, into: &buf)
        FfiConverterUInt64.write(value.fee, into: &buf)
        FfiConverterTypeTxStatus.write(value.status, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTx_lift(_ buf: RustBuffer) throws -> Tx {
    return try FfiConverterTypeTx.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTx_lower(_ value: Tx) -> RustBuffer {
    return FfiConverterTypeTx.lower(value)
}


public struct TxDetails {
    public var txid: Txid
    public var sent: Amount
    public var received: Amount
    public var fee: Amount?
    public var feeRate: Float?
    public var balanceDelta: Int64
    public var chainPosition: ChainPosition
    public var tx: Transaction

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txid: Txid, sent: Amount, received: Amount, fee: Amount?, feeRate: Float?, balanceDelta: Int64, chainPosition: ChainPosition, tx: Transaction) {
        self.txid = txid
        self.sent = sent
        self.received = received
        self.fee = fee
        self.feeRate = feeRate
        self.balanceDelta = balanceDelta
        self.chainPosition = chainPosition
        self.tx = tx
    }
}

#if compiler(>=6)
extension TxDetails: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTxDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxDetails {
        return
            try TxDetails(
                txid: FfiConverterTypeTxid.read(from: &buf), 
                sent: FfiConverterTypeAmount.read(from: &buf), 
                received: FfiConverterTypeAmount.read(from: &buf), 
                fee: FfiConverterOptionTypeAmount.read(from: &buf), 
                feeRate: FfiConverterOptionFloat.read(from: &buf), 
                balanceDelta: FfiConverterInt64.read(from: &buf), 
                chainPosition: FfiConverterTypeChainPosition.read(from: &buf), 
                tx: FfiConverterTypeTransaction.read(from: &buf)
        )
    }

    public static func write(_ value: TxDetails, into buf: inout [UInt8]) {
        FfiConverterTypeTxid.write(value.txid, into: &buf)
        FfiConverterTypeAmount.write(value.sent, into: &buf)
        FfiConverterTypeAmount.write(value.received, into: &buf)
        FfiConverterOptionTypeAmount.write(value.fee, into: &buf)
        FfiConverterOptionFloat.write(value.feeRate, into: &buf)
        FfiConverterInt64.write(value.balanceDelta, into: &buf)
        FfiConverterTypeChainPosition.write(value.chainPosition, into: &buf)
        FfiConverterTypeTransaction.write(value.tx, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxDetails_lift(_ buf: RustBuffer) throws -> TxDetails {
    return try FfiConverterTypeTxDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxDetails_lower(_ value: TxDetails) -> RustBuffer {
    return FfiConverterTypeTxDetails.lower(value)
}


public struct TxGraphChangeSet {
    public var txs: [Transaction]
    public var txouts: [HashableOutPoint: TxOut]
    public var anchors: [Anchor]
    public var lastSeen: [Txid: UInt64]
    public var firstSeen: [Txid: UInt64]
    public var lastEvicted: [Txid: UInt64]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txs: [Transaction], txouts: [HashableOutPoint: TxOut], anchors: [Anchor], lastSeen: [Txid: UInt64], firstSeen: [Txid: UInt64], lastEvicted: [Txid: UInt64]) {
        self.txs = txs
        self.txouts = txouts
        self.anchors = anchors
        self.lastSeen = lastSeen
        self.firstSeen = firstSeen
        self.lastEvicted = lastEvicted
    }
}

#if compiler(>=6)
extension TxGraphChangeSet: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTxGraphChangeSet: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxGraphChangeSet {
        return
            try TxGraphChangeSet(
                txs: FfiConverterSequenceTypeTransaction.read(from: &buf), 
                txouts: FfiConverterDictionaryTypeHashableOutPointTypeTxOut.read(from: &buf), 
                anchors: FfiConverterSequenceTypeAnchor.read(from: &buf), 
                lastSeen: FfiConverterDictionaryTypeTxidUInt64.read(from: &buf), 
                firstSeen: FfiConverterDictionaryTypeTxidUInt64.read(from: &buf), 
                lastEvicted: FfiConverterDictionaryTypeTxidUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: TxGraphChangeSet, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeTransaction.write(value.txs, into: &buf)
        FfiConverterDictionaryTypeHashableOutPointTypeTxOut.write(value.txouts, into: &buf)
        FfiConverterSequenceTypeAnchor.write(value.anchors, into: &buf)
        FfiConverterDictionaryTypeTxidUInt64.write(value.lastSeen, into: &buf)
        FfiConverterDictionaryTypeTxidUInt64.write(value.firstSeen, into: &buf)
        FfiConverterDictionaryTypeTxidUInt64.write(value.lastEvicted, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxGraphChangeSet_lift(_ buf: RustBuffer) throws -> TxGraphChangeSet {
    return try FfiConverterTypeTxGraphChangeSet.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxGraphChangeSet_lower(_ value: TxGraphChangeSet) -> RustBuffer {
    return FfiConverterTypeTxGraphChangeSet.lower(value)
}


/**
 * A transcation input.
 */
public struct TxIn {
    /**
     * A pointer to the previous output this input spends from.
     */
    public var previousOutput: OutPoint
    /**
     * The script corresponding to the `scriptPubKey`, empty in SegWit transactions.
     */
    public var scriptSig: Script
    /**
     * https://bitcoin.stackexchange.com/questions/87372/what-does-the-sequence-in-a-transaction-input-mean
     */
    public var sequence: UInt32
    /**
     * A proof for the script that authorizes the spend of the output.
     */
    public var witness: [Data]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A pointer to the previous output this input spends from.
         */previousOutput: OutPoint, 
        /**
         * The script corresponding to the `scriptPubKey`, empty in SegWit transactions.
         */scriptSig: Script, 
        /**
         * https://bitcoin.stackexchange.com/questions/87372/what-does-the-sequence-in-a-transaction-input-mean
         */sequence: UInt32, 
        /**
         * A proof for the script that authorizes the spend of the output.
         */witness: [Data]) {
        self.previousOutput = previousOutput
        self.scriptSig = scriptSig
        self.sequence = sequence
        self.witness = witness
    }
}

#if compiler(>=6)
extension TxIn: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTxIn: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxIn {
        return
            try TxIn(
                previousOutput: FfiConverterTypeOutPoint.read(from: &buf), 
                scriptSig: FfiConverterTypeScript.read(from: &buf), 
                sequence: FfiConverterUInt32.read(from: &buf), 
                witness: FfiConverterSequenceData.read(from: &buf)
        )
    }

    public static func write(_ value: TxIn, into buf: inout [UInt8]) {
        FfiConverterTypeOutPoint.write(value.previousOutput, into: &buf)
        FfiConverterTypeScript.write(value.scriptSig, into: &buf)
        FfiConverterUInt32.write(value.sequence, into: &buf)
        FfiConverterSequenceData.write(value.witness, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxIn_lift(_ buf: RustBuffer) throws -> TxIn {
    return try FfiConverterTypeTxIn.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxIn_lower(_ value: TxIn) -> RustBuffer {
    return FfiConverterTypeTxIn.lower(value)
}


/**
 * Bitcoin transaction output.
 *
 * Defines new coins to be created as a result of the transaction,
 * along with spending conditions ("script", aka "output script"),
 * which an input spending it must satisfy.
 *
 * An output that is not yet spent by an input is called Unspent Transaction Output ("UTXO").
 */
public struct TxOut {
    /**
     * The value of the output, in satoshis.
     */
    public var value: Amount
    /**
     * The script which must be satisfied for the output to be spent.
     */
    public var scriptPubkey: Script

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The value of the output, in satoshis.
         */value: Amount, 
        /**
         * The script which must be satisfied for the output to be spent.
         */scriptPubkey: Script) {
        self.value = value
        self.scriptPubkey = scriptPubkey
    }
}

#if compiler(>=6)
extension TxOut: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTxOut: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxOut {
        return
            try TxOut(
                value: FfiConverterTypeAmount.read(from: &buf), 
                scriptPubkey: FfiConverterTypeScript.read(from: &buf)
        )
    }

    public static func write(_ value: TxOut, into buf: inout [UInt8]) {
        FfiConverterTypeAmount.write(value.value, into: &buf)
        FfiConverterTypeScript.write(value.scriptPubkey, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxOut_lift(_ buf: RustBuffer) throws -> TxOut {
    return try FfiConverterTypeTxOut.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxOut_lower(_ value: TxOut) -> RustBuffer {
    return FfiConverterTypeTxOut.lower(value)
}


/**
 * Transaction confirmation metadata.
 */
public struct TxStatus {
    /**
     * Is the transaction in a block.
     */
    public var confirmed: Bool
    /**
     * Height of the block this transaction was included.
     */
    public var blockHeight: UInt32?
    /**
     * Hash of the block.
     */
    public var blockHash: BlockHash?
    /**
     * The time shown in the block, not necessarily the same time as when the block was found.
     */
    public var blockTime: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Is the transaction in a block.
         */confirmed: Bool, 
        /**
         * Height of the block this transaction was included.
         */blockHeight: UInt32?, 
        /**
         * Hash of the block.
         */blockHash: BlockHash?, 
        /**
         * The time shown in the block, not necessarily the same time as when the block was found.
         */blockTime: UInt64?) {
        self.confirmed = confirmed
        self.blockHeight = blockHeight
        self.blockHash = blockHash
        self.blockTime = blockTime
    }
}

#if compiler(>=6)
extension TxStatus: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTxStatus: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxStatus {
        return
            try TxStatus(
                confirmed: FfiConverterBool.read(from: &buf), 
                blockHeight: FfiConverterOptionUInt32.read(from: &buf), 
                blockHash: FfiConverterOptionTypeBlockHash.read(from: &buf), 
                blockTime: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: TxStatus, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.confirmed, into: &buf)
        FfiConverterOptionUInt32.write(value.blockHeight, into: &buf)
        FfiConverterOptionTypeBlockHash.write(value.blockHash, into: &buf)
        FfiConverterOptionUInt64.write(value.blockTime, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxStatus_lift(_ buf: RustBuffer) throws -> TxStatus {
    return try FfiConverterTypeTxStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxStatus_lower(_ value: TxStatus) -> RustBuffer {
    return FfiConverterTypeTxStatus.lower(value)
}


/**
 * This type replaces the Rust tuple `(tx, last_seen)` used in the Wallet::apply_unconfirmed_txs` method,
 * where `last_seen` is the timestamp of when the transaction `tx` was last seen in the mempool.
 */
public struct UnconfirmedTx {
    public var tx: Transaction
    public var lastSeen: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(tx: Transaction, lastSeen: UInt64) {
        self.tx = tx
        self.lastSeen = lastSeen
    }
}

#if compiler(>=6)
extension UnconfirmedTx: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnconfirmedTx: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnconfirmedTx {
        return
            try UnconfirmedTx(
                tx: FfiConverterTypeTransaction.read(from: &buf), 
                lastSeen: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: UnconfirmedTx, into buf: inout [UInt8]) {
        FfiConverterTypeTransaction.write(value.tx, into: &buf)
        FfiConverterUInt64.write(value.lastSeen, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnconfirmedTx_lift(_ buf: RustBuffer) throws -> UnconfirmedTx {
    return try FfiConverterTypeUnconfirmedTx.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnconfirmedTx_lower(_ value: UnconfirmedTx) -> RustBuffer {
    return FfiConverterTypeUnconfirmedTx.lower(value)
}


/**
 * The version and program of a Segwit address.
 */
public struct WitnessProgram {
    /**
     * Version. For example 1 for Taproot.
     */
    public var version: UInt8
    /**
     * The witness program.
     */
    public var program: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Version. For example 1 for Taproot.
         */version: UInt8, 
        /**
         * The witness program.
         */program: Data) {
        self.version = version
        self.program = program
    }
}

#if compiler(>=6)
extension WitnessProgram: Sendable {}
#endif


extension WitnessProgram: Equatable, Hashable {
    public static func ==(lhs: WitnessProgram, rhs: WitnessProgram) -> Bool {
        if lhs.version != rhs.version {
            return false
        }
        if lhs.program != rhs.program {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(version)
        hasher.combine(program)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWitnessProgram: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WitnessProgram {
        return
            try WitnessProgram(
                version: FfiConverterUInt8.read(from: &buf), 
                program: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: WitnessProgram, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.version, into: &buf)
        FfiConverterData.write(value.program, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWitnessProgram_lift(_ buf: RustBuffer) throws -> WitnessProgram {
    return try FfiConverterTypeWitnessProgram.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWitnessProgram_lower(_ value: WitnessProgram) -> RustBuffer {
    return FfiConverterTypeWitnessProgram.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The type of address.
 */

public enum AddressData {
    
    /**
     * Legacy.
     */
    case p2pkh(pubkeyHash: String
    )
    /**
     * Wrapped Segwit
     */
    case p2sh(scriptHash: String
    )
    /**
     * Segwit
     */
    case segwit(witnessProgram: WitnessProgram
    )
}


#if compiler(>=6)
extension AddressData: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddressData: FfiConverterRustBuffer {
    typealias SwiftType = AddressData

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressData {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .p2pkh(pubkeyHash: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .p2sh(scriptHash: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .segwit(witnessProgram: try FfiConverterTypeWitnessProgram.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AddressData, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .p2pkh(pubkeyHash):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(pubkeyHash, into: &buf)
            
        
        case let .p2sh(scriptHash):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(scriptHash, into: &buf)
            
        
        case let .segwit(witnessProgram):
            writeInt(&buf, Int32(3))
            FfiConverterTypeWitnessProgram.write(witnessProgram, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressData_lift(_ buf: RustBuffer) throws -> AddressData {
    return try FfiConverterTypeAddressData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressData_lower(_ value: AddressData) -> RustBuffer {
    return FfiConverterTypeAddressData.lower(value)
}


extension AddressData: Equatable, Hashable {}







public enum AddressParseError: Swift.Error {

    
    
    case Base58
    case Bech32
    case WitnessVersion(errorMessage: String
    )
    case WitnessProgram(errorMessage: String
    )
    case UnknownHrp
    case LegacyAddressTooLong
    case InvalidBase58PayloadLength
    case InvalidLegacyPrefix
    case NetworkValidation
    case OtherAddressParseErr
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddressParseError: FfiConverterRustBuffer {
    typealias SwiftType = AddressParseError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressParseError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Base58
        case 2: return .Bech32
        case 3: return .WitnessVersion(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 4: return .WitnessProgram(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 5: return .UnknownHrp
        case 6: return .LegacyAddressTooLong
        case 7: return .InvalidBase58PayloadLength
        case 8: return .InvalidLegacyPrefix
        case 9: return .NetworkValidation
        case 10: return .OtherAddressParseErr

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AddressParseError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .Base58:
            writeInt(&buf, Int32(1))
        
        
        case .Bech32:
            writeInt(&buf, Int32(2))
        
        
        case let .WitnessVersion(errorMessage):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .WitnessProgram(errorMessage):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .UnknownHrp:
            writeInt(&buf, Int32(5))
        
        
        case .LegacyAddressTooLong:
            writeInt(&buf, Int32(6))
        
        
        case .InvalidBase58PayloadLength:
            writeInt(&buf, Int32(7))
        
        
        case .InvalidLegacyPrefix:
            writeInt(&buf, Int32(8))
        
        
        case .NetworkValidation:
            writeInt(&buf, Int32(9))
        
        
        case .OtherAddressParseErr:
            writeInt(&buf, Int32(10))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressParseError_lift(_ buf: RustBuffer) throws -> AddressParseError {
    return try FfiConverterTypeAddressParseError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressParseError_lower(_ value: AddressParseError) -> RustBuffer {
    return FfiConverterTypeAddressParseError.lower(value)
}


extension AddressParseError: Equatable, Hashable {}




extension AddressParseError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





public enum Bip32Error: Swift.Error {

    
    
    case CannotDeriveFromHardenedKey
    case Secp256k1(errorMessage: String
    )
    case InvalidChildNumber(childNumber: UInt32
    )
    case InvalidChildNumberFormat
    case InvalidDerivationPathFormat
    case UnknownVersion(version: String
    )
    case WrongExtendedKeyLength(length: UInt32
    )
    case Base58(errorMessage: String
    )
    case Hex(errorMessage: String
    )
    case InvalidPublicKeyHexLength(length: UInt32
    )
    case UnknownError(errorMessage: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBip32Error: FfiConverterRustBuffer {
    typealias SwiftType = Bip32Error

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip32Error {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .CannotDeriveFromHardenedKey
        case 2: return .Secp256k1(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 3: return .InvalidChildNumber(
            childNumber: try FfiConverterUInt32.read(from: &buf)
            )
        case 4: return .InvalidChildNumberFormat
        case 5: return .InvalidDerivationPathFormat
        case 6: return .UnknownVersion(
            version: try FfiConverterString.read(from: &buf)
            )
        case 7: return .WrongExtendedKeyLength(
            length: try FfiConverterUInt32.read(from: &buf)
            )
        case 8: return .Base58(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 9: return .Hex(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 10: return .InvalidPublicKeyHexLength(
            length: try FfiConverterUInt32.read(from: &buf)
            )
        case 11: return .UnknownError(
            errorMessage: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Bip32Error, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .CannotDeriveFromHardenedKey:
            writeInt(&buf, Int32(1))
        
        
        case let .Secp256k1(errorMessage):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .InvalidChildNumber(childNumber):
            writeInt(&buf, Int32(3))
            FfiConverterUInt32.write(childNumber, into: &buf)
            
        
        case .InvalidChildNumberFormat:
            writeInt(&buf, Int32(4))
        
        
        case .InvalidDerivationPathFormat:
            writeInt(&buf, Int32(5))
        
        
        case let .UnknownVersion(version):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(version, into: &buf)
            
        
        case let .WrongExtendedKeyLength(length):
            writeInt(&buf, Int32(7))
            FfiConverterUInt32.write(length, into: &buf)
            
        
        case let .Base58(errorMessage):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Hex(errorMessage):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .InvalidPublicKeyHexLength(length):
            writeInt(&buf, Int32(10))
            FfiConverterUInt32.write(length, into: &buf)
            
        
        case let .UnknownError(errorMessage):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(errorMessage, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBip32Error_lift(_ buf: RustBuffer) throws -> Bip32Error {
    return try FfiConverterTypeBip32Error.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBip32Error_lower(_ value: Bip32Error) -> RustBuffer {
    return FfiConverterTypeBip32Error.lower(value)
}


extension Bip32Error: Equatable, Hashable {}




extension Bip32Error: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





public enum Bip39Error: Swift.Error {

    
    
    case BadWordCount(wordCount: UInt64
    )
    case UnknownWord(index: UInt64
    )
    case BadEntropyBitCount(bitCount: UInt64
    )
    case InvalidChecksum
    case AmbiguousLanguages(languages: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBip39Error: FfiConverterRustBuffer {
    typealias SwiftType = Bip39Error

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39Error {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .BadWordCount(
            wordCount: try FfiConverterUInt64.read(from: &buf)
            )
        case 2: return .UnknownWord(
            index: try FfiConverterUInt64.read(from: &buf)
            )
        case 3: return .BadEntropyBitCount(
            bitCount: try FfiConverterUInt64.read(from: &buf)
            )
        case 4: return .InvalidChecksum
        case 5: return .AmbiguousLanguages(
            languages: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Bip39Error, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .BadWordCount(wordCount):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(wordCount, into: &buf)
            
        
        case let .UnknownWord(index):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(index, into: &buf)
            
        
        case let .BadEntropyBitCount(bitCount):
            writeInt(&buf, Int32(3))
            FfiConverterUInt64.write(bitCount, into: &buf)
            
        
        case .InvalidChecksum:
            writeInt(&buf, Int32(4))
        
        
        case let .AmbiguousLanguages(languages):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(languages, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBip39Error_lift(_ buf: RustBuffer) throws -> Bip39Error {
    return try FfiConverterTypeBip39Error.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBip39Error_lower(_ value: Bip39Error) -> RustBuffer {
    return FfiConverterTypeBip39Error.lower(value)
}


extension Bip39Error: Equatable, Hashable {}




extension Bip39Error: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





public enum CalculateFeeError: Swift.Error {

    
    
    case MissingTxOut(outPoints: [OutPoint]
    )
    case NegativeFee(amount: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCalculateFeeError: FfiConverterRustBuffer {
    typealias SwiftType = CalculateFeeError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CalculateFeeError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .MissingTxOut(
            outPoints: try FfiConverterSequenceTypeOutPoint.read(from: &buf)
            )
        case 2: return .NegativeFee(
            amount: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CalculateFeeError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .MissingTxOut(outPoints):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeOutPoint.write(outPoints, into: &buf)
            
        
        case let .NegativeFee(amount):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(amount, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCalculateFeeError_lift(_ buf: RustBuffer) throws -> CalculateFeeError {
    return try FfiConverterTypeCalculateFeeError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCalculateFeeError_lower(_ value: CalculateFeeError) -> RustBuffer {
    return FfiConverterTypeCalculateFeeError.lower(value)
}




extension CalculateFeeError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





public enum CannotConnectError: Swift.Error {

    
    
    case Include(height: UInt32
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCannotConnectError: FfiConverterRustBuffer {
    typealias SwiftType = CannotConnectError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CannotConnectError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Include(
            height: try FfiConverterUInt32.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CannotConnectError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Include(height):
            writeInt(&buf, Int32(1))
            FfiConverterUInt32.write(height, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCannotConnectError_lift(_ buf: RustBuffer) throws -> CannotConnectError {
    return try FfiConverterTypeCannotConnectError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCannotConnectError_lower(_ value: CannotConnectError) -> RustBuffer {
    return FfiConverterTypeCannotConnectError.lower(value)
}


extension CannotConnectError: Equatable, Hashable {}




extension CannotConnectError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





public enum CbfError: Swift.Error {

    
    
    case NodeStopped
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCbfError: FfiConverterRustBuffer {
    typealias SwiftType = CbfError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CbfError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .NodeStopped

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CbfError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .NodeStopped:
            writeInt(&buf, Int32(1))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCbfError_lift(_ buf: RustBuffer) throws -> CbfError {
    return try FfiConverterTypeCbfError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCbfError_lower(_ value: CbfError) -> RustBuffer {
    return FfiConverterTypeCbfError.lower(value)
}


extension CbfError: Equatable, Hashable {}




extension CbfError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Represents the observed position of some chain data.
 */

public enum ChainPosition {
    
    /**
     * The chain data is confirmed as it is anchored in the best chain by `A`.
     */
    case confirmed(confirmationBlockTime: ConfirmationBlockTime, 
        /**
         * A child transaction that has been confirmed. Due to incomplete information,
         * it is only known that this transaction is confirmed at a chain height less than
         * or equal to this child TXID.
         */transitively: Txid?
    )
    /**
     * The transaction was last seen in the mempool at this timestamp.
     */
    case unconfirmed(timestamp: UInt64?
    )
}


#if compiler(>=6)
extension ChainPosition: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeChainPosition: FfiConverterRustBuffer {
    typealias SwiftType = ChainPosition

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChainPosition {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .confirmed(confirmationBlockTime: try FfiConverterTypeConfirmationBlockTime.read(from: &buf), transitively: try FfiConverterOptionTypeTxid.read(from: &buf)
        )
        
        case 2: return .unconfirmed(timestamp: try FfiConverterOptionUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ChainPosition, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .confirmed(confirmationBlockTime,transitively):
            writeInt(&buf, Int32(1))
            FfiConverterTypeConfirmationBlockTime.write(confirmationBlockTime, into: &buf)
            FfiConverterOptionTypeTxid.write(transitively, into: &buf)
            
        
        case let .unconfirmed(timestamp):
            writeInt(&buf, Int32(2))
            FfiConverterOptionUInt64.write(timestamp, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChainPosition_lift(_ buf: RustBuffer) throws -> ChainPosition {
    return try FfiConverterTypeChainPosition.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChainPosition_lower(_ value: ChainPosition) -> RustBuffer {
    return FfiConverterTypeChainPosition.lower(value)
}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Policy regarding the use of change outputs when creating a transaction.
 */

public enum ChangeSpendPolicy {
    
    /**
     * Use both change and non-change outputs (default).
     */
    case changeAllowed
    /**
     * Only use change outputs (see [`bdk_wallet::TxBuilder::only_spend_change`]).
     */
    case onlyChange
    /**
     * Only use non-change outputs (see [`bdk_wallet::TxBuilder::do_not_spend_change`]).
     */
    case changeForbidden
}


#if compiler(>=6)
extension ChangeSpendPolicy: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeChangeSpendPolicy: FfiConverterRustBuffer {
    typealias SwiftType = ChangeSpendPolicy

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChangeSpendPolicy {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .changeAllowed
        
        case 2: return .onlyChange
        
        case 3: return .changeForbidden
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ChangeSpendPolicy, into buf: inout [UInt8]) {
        switch value {
        
        
        case .changeAllowed:
            writeInt(&buf, Int32(1))
        
        
        case .onlyChange:
            writeInt(&buf, Int32(2))
        
        
        case .changeForbidden:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChangeSpendPolicy_lift(_ buf: RustBuffer) throws -> ChangeSpendPolicy {
    return try FfiConverterTypeChangeSpendPolicy.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChangeSpendPolicy_lower(_ value: ChangeSpendPolicy) -> RustBuffer {
    return FfiConverterTypeChangeSpendPolicy.lower(value)
}


extension ChangeSpendPolicy: Equatable, Hashable {}







public enum CreateTxError: Swift.Error {

    
    
    case Descriptor(errorMessage: String
    )
    case Policy(errorMessage: String
    )
    case SpendingPolicyRequired(kind: String
    )
    case Version0
    case Version1Csv
    case LockTime(requested: String, required: String
    )
    case RbfSequenceCsv(sequence: String, csv: String
    )
    case FeeTooLow(required: String
    )
    case FeeRateTooLow(required: String
    )
    case NoUtxosSelected
    case OutputBelowDustLimit(index: UInt64
    )
    case ChangePolicyDescriptor
    case CoinSelection(errorMessage: String
    )
    case InsufficientFunds(needed: UInt64, available: UInt64
    )
    case NoRecipients
    case Psbt(errorMessage: String
    )
    case MissingKeyOrigin(key: String
    )
    case UnknownUtxo(outpoint: String
    )
    case MissingNonWitnessUtxo(outpoint: String
    )
    case MiniscriptPsbt(errorMessage: String
    )
    case PushBytesError
    case LockTimeConversionError
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCreateTxError: FfiConverterRustBuffer {
    typealias SwiftType = CreateTxError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CreateTxError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Descriptor(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 2: return .Policy(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 3: return .SpendingPolicyRequired(
            kind: try FfiConverterString.read(from: &buf)
            )
        case 4: return .Version0
        case 5: return .Version1Csv
        case 6: return .LockTime(
            requested: try FfiConverterString.read(from: &buf), 
            required: try FfiConverterString.read(from: &buf)
            )
        case 7: return .RbfSequenceCsv(
            sequence: try FfiConverterString.read(from: &buf), 
            csv: try FfiConverterString.read(from: &buf)
            )
        case 8: return .FeeTooLow(
            required: try FfiConverterString.read(from: &buf)
            )
        case 9: return .FeeRateTooLow(
            required: try FfiConverterString.read(from: &buf)
            )
        case 10: return .NoUtxosSelected
        case 11: return .OutputBelowDustLimit(
            index: try FfiConverterUInt64.read(from: &buf)
            )
        case 12: return .ChangePolicyDescriptor
        case 13: return .CoinSelection(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 14: return .InsufficientFunds(
            needed: try FfiConverterUInt64.read(from: &buf), 
            available: try FfiConverterUInt64.read(from: &buf)
            )
        case 15: return .NoRecipients
        case 16: return .Psbt(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 17: return .MissingKeyOrigin(
            key: try FfiConverterString.read(from: &buf)
            )
        case 18: return .UnknownUtxo(
            outpoint: try FfiConverterString.read(from: &buf)
            )
        case 19: return .MissingNonWitnessUtxo(
            outpoint: try FfiConverterString.read(from: &buf)
            )
        case 20: return .MiniscriptPsbt(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 21: return .PushBytesError
        case 22: return .LockTimeConversionError

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CreateTxError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Descriptor(errorMessage):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Policy(errorMessage):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .SpendingPolicyRequired(kind):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(kind, into: &buf)
            
        
        case .Version0:
            writeInt(&buf, Int32(4))
        
        
        case .Version1Csv:
            writeInt(&buf, Int32(5))
        
        
        case let .LockTime(requested,required):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(requested, into: &buf)
            FfiConverterString.write(required, into: &buf)
            
        
        case let .RbfSequenceCsv(sequence,csv):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(sequence, into: &buf)
            FfiConverterString.write(csv, into: &buf)
            
        
        case let .FeeTooLow(required):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(required, into: &buf)
            
        
        case let .FeeRateTooLow(required):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(required, into: &buf)
            
        
        case .NoUtxosSelected:
            writeInt(&buf, Int32(10))
        
        
        case let .OutputBelowDustLimit(index):
            writeInt(&buf, Int32(11))
            FfiConverterUInt64.write(index, into: &buf)
            
        
        case .ChangePolicyDescriptor:
            writeInt(&buf, Int32(12))
        
        
        case let .CoinSelection(errorMessage):
            writeInt(&buf, Int32(13))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .InsufficientFunds(needed,available):
            writeInt(&buf, Int32(14))
            FfiConverterUInt64.write(needed, into: &buf)
            FfiConverterUInt64.write(available, into: &buf)
            
        
        case .NoRecipients:
            writeInt(&buf, Int32(15))
        
        
        case let .Psbt(errorMessage):
            writeInt(&buf, Int32(16))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .MissingKeyOrigin(key):
            writeInt(&buf, Int32(17))
            FfiConverterString.write(key, into: &buf)
            
        
        case let .UnknownUtxo(outpoint):
            writeInt(&buf, Int32(18))
            FfiConverterString.write(outpoint, into: &buf)
            
        
        case let .MissingNonWitnessUtxo(outpoint):
            writeInt(&buf, Int32(19))
            FfiConverterString.write(outpoint, into: &buf)
            
        
        case let .MiniscriptPsbt(errorMessage):
            writeInt(&buf, Int32(20))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .PushBytesError:
            writeInt(&buf, Int32(21))
        
        
        case .LockTimeConversionError:
            writeInt(&buf, Int32(22))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCreateTxError_lift(_ buf: RustBuffer) throws -> CreateTxError {
    return try FfiConverterTypeCreateTxError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCreateTxError_lower(_ value: CreateTxError) -> RustBuffer {
    return FfiConverterTypeCreateTxError.lower(value)
}


extension CreateTxError: Equatable, Hashable {}




extension CreateTxError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





public enum CreateWithPersistError: Swift.Error {

    
    
    case Persist(errorMessage: String
    )
    case DataAlreadyExists
    case Descriptor(errorMessage: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCreateWithPersistError: FfiConverterRustBuffer {
    typealias SwiftType = CreateWithPersistError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CreateWithPersistError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Persist(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 2: return .DataAlreadyExists
        case 3: return .Descriptor(
            errorMessage: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CreateWithPersistError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Persist(errorMessage):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .DataAlreadyExists:
            writeInt(&buf, Int32(2))
        
        
        case let .Descriptor(errorMessage):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(errorMessage, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCreateWithPersistError_lift(_ buf: RustBuffer) throws -> CreateWithPersistError {
    return try FfiConverterTypeCreateWithPersistError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCreateWithPersistError_lower(_ value: CreateWithPersistError) -> RustBuffer {
    return FfiConverterTypeCreateWithPersistError.lower(value)
}


extension CreateWithPersistError: Equatable, Hashable {}




extension CreateWithPersistError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





public enum DescriptorError: Swift.Error {

    
    
    case InvalidHdKeyPath
    case InvalidDescriptorChecksum
    case HardenedDerivationXpub
    case MultiPath
    case Key(errorMessage: String
    )
    case Policy(errorMessage: String
    )
    case InvalidDescriptorCharacter(char: String
    )
    case Bip32(errorMessage: String
    )
    case Base58(errorMessage: String
    )
    case Pk(errorMessage: String
    )
    case Miniscript(errorMessage: String
    )
    case Hex(errorMessage: String
    )
    case ExternalAndInternalAreTheSame
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDescriptorError: FfiConverterRustBuffer {
    typealias SwiftType = DescriptorError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DescriptorError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidHdKeyPath
        case 2: return .InvalidDescriptorChecksum
        case 3: return .HardenedDerivationXpub
        case 4: return .MultiPath
        case 5: return .Key(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 6: return .Policy(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 7: return .InvalidDescriptorCharacter(
            char: try FfiConverterString.read(from: &buf)
            )
        case 8: return .Bip32(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 9: return .Base58(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 10: return .Pk(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 11: return .Miniscript(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 12: return .Hex(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 13: return .ExternalAndInternalAreTheSame

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DescriptorError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .InvalidHdKeyPath:
            writeInt(&buf, Int32(1))
        
        
        case .InvalidDescriptorChecksum:
            writeInt(&buf, Int32(2))
        
        
        case .HardenedDerivationXpub:
            writeInt(&buf, Int32(3))
        
        
        case .MultiPath:
            writeInt(&buf, Int32(4))
        
        
        case let .Key(errorMessage):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Policy(errorMessage):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .InvalidDescriptorCharacter(char):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(char, into: &buf)
            
        
        case let .Bip32(errorMessage):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Base58(errorMessage):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Pk(errorMessage):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Miniscript(errorMessage):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Hex(errorMessage):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .ExternalAndInternalAreTheSame:
            writeInt(&buf, Int32(13))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDescriptorError_lift(_ buf: RustBuffer) throws -> DescriptorError {
    return try FfiConverterTypeDescriptorError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDescriptorError_lower(_ value: DescriptorError) -> RustBuffer {
    return FfiConverterTypeDescriptorError.lower(value)
}


extension DescriptorError: Equatable, Hashable {}




extension DescriptorError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





public enum DescriptorKeyError: Swift.Error {

    
    
    case Parse(errorMessage: String
    )
    case InvalidKeyType
    case Bip32(errorMessage: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDescriptorKeyError: FfiConverterRustBuffer {
    typealias SwiftType = DescriptorKeyError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DescriptorKeyError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Parse(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 2: return .InvalidKeyType
        case 3: return .Bip32(
            errorMessage: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DescriptorKeyError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Parse(errorMessage):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .InvalidKeyType:
            writeInt(&buf, Int32(2))
        
        
        case let .Bip32(errorMessage):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(errorMessage, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDescriptorKeyError_lift(_ buf: RustBuffer) throws -> DescriptorKeyError {
    return try FfiConverterTypeDescriptorKeyError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDescriptorKeyError_lower(_ value: DescriptorKeyError) -> RustBuffer {
    return FfiConverterTypeDescriptorKeyError.lower(value)
}


extension DescriptorKeyError: Equatable, Hashable {}




extension DescriptorKeyError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Descriptor Type of the descriptor
 */

public enum DescriptorType {
    
    /**
     * Bare descriptor(Contains the native P2pk)
     */
    case bare
    /**
     * Pure Sh Descriptor. Does not contain nested Wsh/Wpkh
     */
    case sh
    /**
     * Pkh Descriptor
     */
    case pkh
    /**
     * Wpkh Descriptor
     */
    case wpkh
    /**
     * Wsh
     */
    case wsh
    /**
     * Sh Wrapped Wsh
     */
    case shWsh
    /**
     * Sh wrapped Wpkh
     */
    case shWpkh
    /**
     * Sh Sorted Multi
     */
    case shSortedMulti
    /**
     * Wsh Sorted Multi
     */
    case wshSortedMulti
    /**
     * Sh Wsh Sorted Multi
     */
    case shWshSortedMulti
    /**
     * Tr Descriptor
     */
    case tr
}


#if compiler(>=6)
extension DescriptorType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDescriptorType: FfiConverterRustBuffer {
    typealias SwiftType = DescriptorType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DescriptorType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bare
        
        case 2: return .sh
        
        case 3: return .pkh
        
        case 4: return .wpkh
        
        case 5: return .wsh
        
        case 6: return .shWsh
        
        case 7: return .shWpkh
        
        case 8: return .shSortedMulti
        
        case 9: return .wshSortedMulti
        
        case 10: return .shWshSortedMulti
        
        case 11: return .tr
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DescriptorType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .bare:
            writeInt(&buf, Int32(1))
        
        
        case .sh:
            writeInt(&buf, Int32(2))
        
        
        case .pkh:
            writeInt(&buf, Int32(3))
        
        
        case .wpkh:
            writeInt(&buf, Int32(4))
        
        
        case .wsh:
            writeInt(&buf, Int32(5))
        
        
        case .shWsh:
            writeInt(&buf, Int32(6))
        
        
        case .shWpkh:
            writeInt(&buf, Int32(7))
        
        
        case .shSortedMulti:
            writeInt(&buf, Int32(8))
        
        
        case .wshSortedMulti:
            writeInt(&buf, Int32(9))
        
        
        case .shWshSortedMulti:
            writeInt(&buf, Int32(10))
        
        
        case .tr:
            writeInt(&buf, Int32(11))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDescriptorType_lift(_ buf: RustBuffer) throws -> DescriptorType {
    return try FfiConverterTypeDescriptorType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDescriptorType_lower(_ value: DescriptorType) -> RustBuffer {
    return FfiConverterTypeDescriptorType.lower(value)
}


extension DescriptorType: Equatable, Hashable {}







public enum ElectrumError: Swift.Error {

    
    
    case IoError(errorMessage: String
    )
    case Json(errorMessage: String
    )
    case Hex(errorMessage: String
    )
    case Protocol(errorMessage: String
    )
    case Bitcoin(errorMessage: String
    )
    case AlreadySubscribed
    case NotSubscribed
    case InvalidResponse(errorMessage: String
    )
    case Message(errorMessage: String
    )
    case InvalidDnsNameError(domain: String
    )
    case MissingDomain
    case AllAttemptsErrored
    case SharedIoError(errorMessage: String
    )
    case CouldntLockReader
    case Mpsc
    case CouldNotCreateConnection(errorMessage: String
    )
    case RequestAlreadyConsumed
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeElectrumError: FfiConverterRustBuffer {
    typealias SwiftType = ElectrumError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ElectrumError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .IoError(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 2: return .Json(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 3: return .Hex(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 4: return .Protocol(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 5: return .Bitcoin(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 6: return .AlreadySubscribed
        case 7: return .NotSubscribed
        case 8: return .InvalidResponse(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 9: return .Message(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 10: return .InvalidDnsNameError(
            domain: try FfiConverterString.read(from: &buf)
            )
        case 11: return .MissingDomain
        case 12: return .AllAttemptsErrored
        case 13: return .SharedIoError(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 14: return .CouldntLockReader
        case 15: return .Mpsc
        case 16: return .CouldNotCreateConnection(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 17: return .RequestAlreadyConsumed

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ElectrumError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .IoError(errorMessage):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Json(errorMessage):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Hex(errorMessage):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Protocol(errorMessage):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Bitcoin(errorMessage):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .AlreadySubscribed:
            writeInt(&buf, Int32(6))
        
        
        case .NotSubscribed:
            writeInt(&buf, Int32(7))
        
        
        case let .InvalidResponse(errorMessage):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Message(errorMessage):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .InvalidDnsNameError(domain):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(domain, into: &buf)
            
        
        case .MissingDomain:
            writeInt(&buf, Int32(11))
        
        
        case .AllAttemptsErrored:
            writeInt(&buf, Int32(12))
        
        
        case let .SharedIoError(errorMessage):
            writeInt(&buf, Int32(13))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .CouldntLockReader:
            writeInt(&buf, Int32(14))
        
        
        case .Mpsc:
            writeInt(&buf, Int32(15))
        
        
        case let .CouldNotCreateConnection(errorMessage):
            writeInt(&buf, Int32(16))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .RequestAlreadyConsumed:
            writeInt(&buf, Int32(17))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeElectrumError_lift(_ buf: RustBuffer) throws -> ElectrumError {
    return try FfiConverterTypeElectrumError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeElectrumError_lower(_ value: ElectrumError) -> RustBuffer {
    return FfiConverterTypeElectrumError.lower(value)
}


extension ElectrumError: Equatable, Hashable {}




extension ElectrumError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





public enum EsploraError: Swift.Error {

    
    
    case Minreq(errorMessage: String
    )
    case HttpResponse(status: UInt16, errorMessage: String
    )
    case Parsing(errorMessage: String
    )
    case StatusCode(errorMessage: String
    )
    case BitcoinEncoding(errorMessage: String
    )
    case HexToArray(errorMessage: String
    )
    case HexToBytes(errorMessage: String
    )
    case TransactionNotFound
    case HeaderHeightNotFound(height: UInt32
    )
    case HeaderHashNotFound
    case InvalidHttpHeaderName(name: String
    )
    case InvalidHttpHeaderValue(value: String
    )
    case RequestAlreadyConsumed
    case InvalidResponse
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEsploraError: FfiConverterRustBuffer {
    typealias SwiftType = EsploraError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EsploraError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Minreq(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 2: return .HttpResponse(
            status: try FfiConverterUInt16.read(from: &buf), 
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 3: return .Parsing(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 4: return .StatusCode(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 5: return .BitcoinEncoding(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 6: return .HexToArray(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 7: return .HexToBytes(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 8: return .TransactionNotFound
        case 9: return .HeaderHeightNotFound(
            height: try FfiConverterUInt32.read(from: &buf)
            )
        case 10: return .HeaderHashNotFound
        case 11: return .InvalidHttpHeaderName(
            name: try FfiConverterString.read(from: &buf)
            )
        case 12: return .InvalidHttpHeaderValue(
            value: try FfiConverterString.read(from: &buf)
            )
        case 13: return .RequestAlreadyConsumed
        case 14: return .InvalidResponse

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EsploraError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Minreq(errorMessage):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .HttpResponse(status,errorMessage):
            writeInt(&buf, Int32(2))
            FfiConverterUInt16.write(status, into: &buf)
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Parsing(errorMessage):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .StatusCode(errorMessage):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .BitcoinEncoding(errorMessage):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .HexToArray(errorMessage):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .HexToBytes(errorMessage):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .TransactionNotFound:
            writeInt(&buf, Int32(8))
        
        
        case let .HeaderHeightNotFound(height):
            writeInt(&buf, Int32(9))
            FfiConverterUInt32.write(height, into: &buf)
            
        
        case .HeaderHashNotFound:
            writeInt(&buf, Int32(10))
        
        
        case let .InvalidHttpHeaderName(name):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(name, into: &buf)
            
        
        case let .InvalidHttpHeaderValue(value):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(value, into: &buf)
            
        
        case .RequestAlreadyConsumed:
            writeInt(&buf, Int32(13))
        
        
        case .InvalidResponse:
            writeInt(&buf, Int32(14))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEsploraError_lift(_ buf: RustBuffer) throws -> EsploraError {
    return try FfiConverterTypeEsploraError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEsploraError_lower(_ value: EsploraError) -> RustBuffer {
    return FfiConverterTypeEsploraError.lower(value)
}


extension EsploraError: Equatable, Hashable {}




extension EsploraError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





public enum ExtractTxError: Swift.Error {

    
    
    case AbsurdFeeRate(feeRate: UInt64
    )
    case MissingInputValue
    case SendingTooMuch
    case OtherExtractTxErr
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExtractTxError: FfiConverterRustBuffer {
    typealias SwiftType = ExtractTxError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExtractTxError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .AbsurdFeeRate(
            feeRate: try FfiConverterUInt64.read(from: &buf)
            )
        case 2: return .MissingInputValue
        case 3: return .SendingTooMuch
        case 4: return .OtherExtractTxErr

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ExtractTxError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .AbsurdFeeRate(feeRate):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(feeRate, into: &buf)
            
        
        case .MissingInputValue:
            writeInt(&buf, Int32(2))
        
        
        case .SendingTooMuch:
            writeInt(&buf, Int32(3))
        
        
        case .OtherExtractTxErr:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExtractTxError_lift(_ buf: RustBuffer) throws -> ExtractTxError {
    return try FfiConverterTypeExtractTxError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExtractTxError_lower(_ value: ExtractTxError) -> RustBuffer {
    return FfiConverterTypeExtractTxError.lower(value)
}


extension ExtractTxError: Equatable, Hashable {}




extension ExtractTxError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





public enum FeeRateError: Swift.Error {

    
    
    case ArithmeticOverflow
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFeeRateError: FfiConverterRustBuffer {
    typealias SwiftType = FeeRateError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeRateError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ArithmeticOverflow

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FeeRateError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .ArithmeticOverflow:
            writeInt(&buf, Int32(1))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRateError_lift(_ buf: RustBuffer) throws -> FeeRateError {
    return try FfiConverterTypeFeeRateError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRateError_lower(_ value: FeeRateError) -> RustBuffer {
    return FfiConverterTypeFeeRateError.lower(value)
}


extension FeeRateError: Equatable, Hashable {}




extension FeeRateError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





public enum FromScriptError: Swift.Error {

    
    
    case UnrecognizedScript
    case WitnessProgram(errorMessage: String
    )
    case WitnessVersion(errorMessage: String
    )
    case OtherFromScriptErr
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFromScriptError: FfiConverterRustBuffer {
    typealias SwiftType = FromScriptError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FromScriptError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .UnrecognizedScript
        case 2: return .WitnessProgram(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 3: return .WitnessVersion(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 4: return .OtherFromScriptErr

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FromScriptError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .UnrecognizedScript:
            writeInt(&buf, Int32(1))
        
        
        case let .WitnessProgram(errorMessage):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .WitnessVersion(errorMessage):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .OtherFromScriptErr:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFromScriptError_lift(_ buf: RustBuffer) throws -> FromScriptError {
    return try FfiConverterTypeFromScriptError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFromScriptError_lower(_ value: FromScriptError) -> RustBuffer {
    return FfiConverterTypeFromScriptError.lower(value)
}


extension FromScriptError: Equatable, Hashable {}




extension FromScriptError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





public enum HashParseError: Swift.Error {

    
    
    case InvalidHash(len: UInt32
    )
    case InvalidHexString(hex: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHashParseError: FfiConverterRustBuffer {
    typealias SwiftType = HashParseError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HashParseError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidHash(
            len: try FfiConverterUInt32.read(from: &buf)
            )
        case 2: return .InvalidHexString(
            hex: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HashParseError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidHash(len):
            writeInt(&buf, Int32(1))
            FfiConverterUInt32.write(len, into: &buf)
            
        
        case let .InvalidHexString(hex):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(hex, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHashParseError_lift(_ buf: RustBuffer) throws -> HashParseError {
    return try FfiConverterTypeHashParseError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHashParseError_lower(_ value: HashParseError) -> RustBuffer {
    return FfiConverterTypeHashParseError.lower(value)
}


extension HashParseError: Equatable, Hashable {}




extension HashParseError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A log message from the node.
 */

public enum Info {
    
    /**
     * All the required connections have been met. This is subject to change.
     */
    case connectionsMet
    /**
     * The node was able to successfully connect to a remote peer.
     */
    case successfulHandshake
    /**
     * A percentage value of filters that have been scanned.
     */
    case progress(
        /**
         * The height of the local block chain.
         */chainHeight: UInt32, 
        /**
         * The percent of filters downloaded.
         */filtersDownloadedPercent: Float
    )
    /**
     * A relevant block was downloaded from a peer.
     */
    case blockReceived(String
    )
}


#if compiler(>=6)
extension Info: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInfo: FfiConverterRustBuffer {
    typealias SwiftType = Info

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Info {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .connectionsMet
        
        case 2: return .successfulHandshake
        
        case 3: return .progress(chainHeight: try FfiConverterUInt32.read(from: &buf), filtersDownloadedPercent: try FfiConverterFloat.read(from: &buf)
        )
        
        case 4: return .blockReceived(try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Info, into buf: inout [UInt8]) {
        switch value {
        
        
        case .connectionsMet:
            writeInt(&buf, Int32(1))
        
        
        case .successfulHandshake:
            writeInt(&buf, Int32(2))
        
        
        case let .progress(chainHeight,filtersDownloadedPercent):
            writeInt(&buf, Int32(3))
            FfiConverterUInt32.write(chainHeight, into: &buf)
            FfiConverterFloat.write(filtersDownloadedPercent, into: &buf)
            
        
        case let .blockReceived(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInfo_lift(_ buf: RustBuffer) throws -> Info {
    return try FfiConverterTypeInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInfo_lower(_ value: Info) -> RustBuffer {
    return FfiConverterTypeInfo.lower(value)
}


extension Info: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Types of keychains.
 */

public enum KeychainKind {
    
    /**
     * External keychain, used for deriving recipient addresses.
     */
    case external
    /**
     * Internal keychain, used for deriving change addresses.
     */
    case `internal`
}


#if compiler(>=6)
extension KeychainKind: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKeychainKind: FfiConverterRustBuffer {
    typealias SwiftType = KeychainKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeychainKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .external
        
        case 2: return .`internal`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: KeychainKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .external:
            writeInt(&buf, Int32(1))
        
        
        case .`internal`:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeychainKind_lift(_ buf: RustBuffer) throws -> KeychainKind {
    return try FfiConverterTypeKeychainKind.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeychainKind_lower(_ value: KeychainKind) -> RustBuffer {
    return FfiConverterTypeKeychainKind.lower(value)
}


extension KeychainKind: Equatable, Hashable {}







public enum LoadWithPersistError: Swift.Error {

    
    
    case Persist(errorMessage: String
    )
    case InvalidChangeSet(errorMessage: String
    )
    case CouldNotLoad
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLoadWithPersistError: FfiConverterRustBuffer {
    typealias SwiftType = LoadWithPersistError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LoadWithPersistError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Persist(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 2: return .InvalidChangeSet(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 3: return .CouldNotLoad

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LoadWithPersistError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Persist(errorMessage):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .InvalidChangeSet(errorMessage):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .CouldNotLoad:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLoadWithPersistError_lift(_ buf: RustBuffer) throws -> LoadWithPersistError {
    return try FfiConverterTypeLoadWithPersistError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLoadWithPersistError_lower(_ value: LoadWithPersistError) -> RustBuffer {
    return FfiConverterTypeLoadWithPersistError.lower(value)
}


extension LoadWithPersistError: Equatable, Hashable {}




extension LoadWithPersistError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LockTime {
    
    case blocks(height: UInt32
    )
    case seconds(consensusTime: UInt32
    )
}


#if compiler(>=6)
extension LockTime: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLockTime: FfiConverterRustBuffer {
    typealias SwiftType = LockTime

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LockTime {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .blocks(height: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 2: return .seconds(consensusTime: try FfiConverterUInt32.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LockTime, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .blocks(height):
            writeInt(&buf, Int32(1))
            FfiConverterUInt32.write(height, into: &buf)
            
        
        case let .seconds(consensusTime):
            writeInt(&buf, Int32(2))
            FfiConverterUInt32.write(consensusTime, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLockTime_lift(_ buf: RustBuffer) throws -> LockTime {
    return try FfiConverterTypeLockTime.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLockTime_lower(_ value: LockTime) -> RustBuffer {
    return FfiConverterTypeLockTime.lower(value)
}


extension LockTime: Equatable, Hashable {}







public enum MiniscriptError: Swift.Error {

    
    
    case AbsoluteLockTime
    case AddrError(errorMessage: String
    )
    case AddrP2shError(errorMessage: String
    )
    case AnalysisError(errorMessage: String
    )
    case AtOutsideOr
    case BadDescriptor(errorMessage: String
    )
    case BareDescriptorAddr
    case CmsTooManyKeys(keys: UInt32
    )
    case ContextError(errorMessage: String
    )
    case CouldNotSatisfy
    case ExpectedChar(char: String
    )
    case ImpossibleSatisfaction
    case InvalidOpcode
    case InvalidPush
    case LiftError(errorMessage: String
    )
    case MaxRecursiveDepthExceeded
    case MissingSig
    case MultiATooManyKeys(keys: UInt64
    )
    case MultiColon
    case MultipathDescLenMismatch
    case NonMinimalVerify(errorMessage: String
    )
    case NonStandardBareScript
    case NonTopLevel(errorMessage: String
    )
    case ParseThreshold
    case PolicyError(errorMessage: String
    )
    case PubKeyCtxError
    case RelativeLockTime
    case Script(errorMessage: String
    )
    case Secp(errorMessage: String
    )
    case Threshold
    case TrNoScriptCode
    case Trailing(errorMessage: String
    )
    case TypeCheck(errorMessage: String
    )
    case Unexpected(errorMessage: String
    )
    case UnexpectedStart
    case UnknownWrapper(char: String
    )
    case Unprintable(byte: UInt8
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMiniscriptError: FfiConverterRustBuffer {
    typealias SwiftType = MiniscriptError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MiniscriptError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .AbsoluteLockTime
        case 2: return .AddrError(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 3: return .AddrP2shError(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 4: return .AnalysisError(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 5: return .AtOutsideOr
        case 6: return .BadDescriptor(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 7: return .BareDescriptorAddr
        case 8: return .CmsTooManyKeys(
            keys: try FfiConverterUInt32.read(from: &buf)
            )
        case 9: return .ContextError(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 10: return .CouldNotSatisfy
        case 11: return .ExpectedChar(
            char: try FfiConverterString.read(from: &buf)
            )
        case 12: return .ImpossibleSatisfaction
        case 13: return .InvalidOpcode
        case 14: return .InvalidPush
        case 15: return .LiftError(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 16: return .MaxRecursiveDepthExceeded
        case 17: return .MissingSig
        case 18: return .MultiATooManyKeys(
            keys: try FfiConverterUInt64.read(from: &buf)
            )
        case 19: return .MultiColon
        case 20: return .MultipathDescLenMismatch
        case 21: return .NonMinimalVerify(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 22: return .NonStandardBareScript
        case 23: return .NonTopLevel(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 24: return .ParseThreshold
        case 25: return .PolicyError(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 26: return .PubKeyCtxError
        case 27: return .RelativeLockTime
        case 28: return .Script(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 29: return .Secp(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 30: return .Threshold
        case 31: return .TrNoScriptCode
        case 32: return .Trailing(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 33: return .TypeCheck(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 34: return .Unexpected(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 35: return .UnexpectedStart
        case 36: return .UnknownWrapper(
            char: try FfiConverterString.read(from: &buf)
            )
        case 37: return .Unprintable(
            byte: try FfiConverterUInt8.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MiniscriptError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .AbsoluteLockTime:
            writeInt(&buf, Int32(1))
        
        
        case let .AddrError(errorMessage):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .AddrP2shError(errorMessage):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .AnalysisError(errorMessage):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .AtOutsideOr:
            writeInt(&buf, Int32(5))
        
        
        case let .BadDescriptor(errorMessage):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .BareDescriptorAddr:
            writeInt(&buf, Int32(7))
        
        
        case let .CmsTooManyKeys(keys):
            writeInt(&buf, Int32(8))
            FfiConverterUInt32.write(keys, into: &buf)
            
        
        case let .ContextError(errorMessage):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .CouldNotSatisfy:
            writeInt(&buf, Int32(10))
        
        
        case let .ExpectedChar(char):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(char, into: &buf)
            
        
        case .ImpossibleSatisfaction:
            writeInt(&buf, Int32(12))
        
        
        case .InvalidOpcode:
            writeInt(&buf, Int32(13))
        
        
        case .InvalidPush:
            writeInt(&buf, Int32(14))
        
        
        case let .LiftError(errorMessage):
            writeInt(&buf, Int32(15))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .MaxRecursiveDepthExceeded:
            writeInt(&buf, Int32(16))
        
        
        case .MissingSig:
            writeInt(&buf, Int32(17))
        
        
        case let .MultiATooManyKeys(keys):
            writeInt(&buf, Int32(18))
            FfiConverterUInt64.write(keys, into: &buf)
            
        
        case .MultiColon:
            writeInt(&buf, Int32(19))
        
        
        case .MultipathDescLenMismatch:
            writeInt(&buf, Int32(20))
        
        
        case let .NonMinimalVerify(errorMessage):
            writeInt(&buf, Int32(21))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .NonStandardBareScript:
            writeInt(&buf, Int32(22))
        
        
        case let .NonTopLevel(errorMessage):
            writeInt(&buf, Int32(23))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .ParseThreshold:
            writeInt(&buf, Int32(24))
        
        
        case let .PolicyError(errorMessage):
            writeInt(&buf, Int32(25))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .PubKeyCtxError:
            writeInt(&buf, Int32(26))
        
        
        case .RelativeLockTime:
            writeInt(&buf, Int32(27))
        
        
        case let .Script(errorMessage):
            writeInt(&buf, Int32(28))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Secp(errorMessage):
            writeInt(&buf, Int32(29))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .Threshold:
            writeInt(&buf, Int32(30))
        
        
        case .TrNoScriptCode:
            writeInt(&buf, Int32(31))
        
        
        case let .Trailing(errorMessage):
            writeInt(&buf, Int32(32))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .TypeCheck(errorMessage):
            writeInt(&buf, Int32(33))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Unexpected(errorMessage):
            writeInt(&buf, Int32(34))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .UnexpectedStart:
            writeInt(&buf, Int32(35))
        
        
        case let .UnknownWrapper(char):
            writeInt(&buf, Int32(36))
            FfiConverterString.write(char, into: &buf)
            
        
        case let .Unprintable(byte):
            writeInt(&buf, Int32(37))
            FfiConverterUInt8.write(byte, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMiniscriptError_lift(_ buf: RustBuffer) throws -> MiniscriptError {
    return try FfiConverterTypeMiniscriptError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMiniscriptError_lower(_ value: MiniscriptError) -> RustBuffer {
    return FfiConverterTypeMiniscriptError.lower(value)
}


extension MiniscriptError: Equatable, Hashable {}




extension MiniscriptError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The cryptocurrency network to act on.
 *
 * This is an exhaustive enum, meaning that we cannot add any future networks without defining a
 * new, incompatible version of this type. If you are using this type directly and wish to support
 * the new network, this will be a breaking change to your APIs and likely require changes in your
 * code.
 *
 * If you are concerned about forward compatibility, consider using T: Into<Params> instead of this
 * type as a parameter to functions in your public API, or directly using the Params type.
 */

public enum Network {
    
    case bitcoin
    case testnet
    case testnet4
    case signet
    case regtest
}


#if compiler(>=6)
extension Network: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = Network

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Network {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoin
        
        case 2: return .testnet
        
        case 3: return .testnet4
        
        case 4: return .signet
        
        case 5: return .regtest
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Network, into buf: inout [UInt8]) {
        switch value {
        
        
        case .bitcoin:
            writeInt(&buf, Int32(1))
        
        
        case .testnet:
            writeInt(&buf, Int32(2))
        
        
        case .testnet4:
            writeInt(&buf, Int32(3))
        
        
        case .signet:
            writeInt(&buf, Int32(4))
        
        
        case .regtest:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetwork_lift(_ buf: RustBuffer) throws -> Network {
    return try FfiConverterTypeNetwork.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetwork_lower(_ value: Network) -> RustBuffer {
    return FfiConverterTypeNetwork.lower(value)
}


extension Network: Equatable, Hashable {}







public enum ParseAmountError: Swift.Error {

    
    
    case OutOfRange
    case TooPrecise
    case MissingDigits
    case InputTooLarge
    case InvalidCharacter(errorMessage: String
    )
    case OtherParseAmountErr
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeParseAmountError: FfiConverterRustBuffer {
    typealias SwiftType = ParseAmountError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParseAmountError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .OutOfRange
        case 2: return .TooPrecise
        case 3: return .MissingDigits
        case 4: return .InputTooLarge
        case 5: return .InvalidCharacter(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 6: return .OtherParseAmountErr

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ParseAmountError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .OutOfRange:
            writeInt(&buf, Int32(1))
        
        
        case .TooPrecise:
            writeInt(&buf, Int32(2))
        
        
        case .MissingDigits:
            writeInt(&buf, Int32(3))
        
        
        case .InputTooLarge:
            writeInt(&buf, Int32(4))
        
        
        case let .InvalidCharacter(errorMessage):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .OtherParseAmountErr:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParseAmountError_lift(_ buf: RustBuffer) throws -> ParseAmountError {
    return try FfiConverterTypeParseAmountError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParseAmountError_lower(_ value: ParseAmountError) -> RustBuffer {
    return FfiConverterTypeParseAmountError.lower(value)
}


extension ParseAmountError: Equatable, Hashable {}




extension ParseAmountError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





public enum PersistenceError: Swift.Error {

    
    
    case Reason(errorMessage: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePersistenceError: FfiConverterRustBuffer {
    typealias SwiftType = PersistenceError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersistenceError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Reason(
            errorMessage: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PersistenceError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Reason(errorMessage):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(errorMessage, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePersistenceError_lift(_ buf: RustBuffer) throws -> PersistenceError {
    return try FfiConverterTypePersistenceError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePersistenceError_lower(_ value: PersistenceError) -> RustBuffer {
    return FfiConverterTypePersistenceError.lower(value)
}


extension PersistenceError: Equatable, Hashable {}




extension PersistenceError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PkOrF {
    
    case pubkey(value: String
    )
    case xOnlyPubkey(value: String
    )
    case fingerprint(value: String
    )
}


#if compiler(>=6)
extension PkOrF: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePkOrF: FfiConverterRustBuffer {
    typealias SwiftType = PkOrF

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PkOrF {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .pubkey(value: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .xOnlyPubkey(value: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .fingerprint(value: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PkOrF, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .pubkey(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .xOnlyPubkey(value):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .fingerprint(value):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePkOrF_lift(_ buf: RustBuffer) throws -> PkOrF {
    return try FfiConverterTypePkOrF.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePkOrF_lower(_ value: PkOrF) -> RustBuffer {
    return FfiConverterTypePkOrF.lower(value)
}


extension PkOrF: Equatable, Hashable {}







public enum PsbtError: Swift.Error {

    
    
    case InvalidMagic
    case MissingUtxo
    case InvalidSeparator
    case PsbtUtxoOutOfBounds
    case InvalidKey(key: String
    )
    case InvalidProprietaryKey
    case DuplicateKey(key: String
    )
    case UnsignedTxHasScriptSigs
    case UnsignedTxHasScriptWitnesses
    case MustHaveUnsignedTx
    case NoMorePairs
    case UnexpectedUnsignedTx
    case NonStandardSighashType(sighash: UInt32
    )
    case InvalidHash(hash: String
    )
    case InvalidPreimageHashPair
    case CombineInconsistentKeySources(xpub: String
    )
    case ConsensusEncoding(encodingError: String
    )
    case NegativeFee
    case FeeOverflow
    case InvalidPublicKey(errorMessage: String
    )
    case InvalidSecp256k1PublicKey(secp256k1Error: String
    )
    case InvalidXOnlyPublicKey
    case InvalidEcdsaSignature(errorMessage: String
    )
    case InvalidTaprootSignature(errorMessage: String
    )
    case InvalidControlBlock
    case InvalidLeafVersion
    case Taproot
    case TapTree(errorMessage: String
    )
    case XPubKey
    case Version(errorMessage: String
    )
    case PartialDataConsumption
    case Io(errorMessage: String
    )
    case OtherPsbtErr
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePsbtError: FfiConverterRustBuffer {
    typealias SwiftType = PsbtError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PsbtError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidMagic
        case 2: return .MissingUtxo
        case 3: return .InvalidSeparator
        case 4: return .PsbtUtxoOutOfBounds
        case 5: return .InvalidKey(
            key: try FfiConverterString.read(from: &buf)
            )
        case 6: return .InvalidProprietaryKey
        case 7: return .DuplicateKey(
            key: try FfiConverterString.read(from: &buf)
            )
        case 8: return .UnsignedTxHasScriptSigs
        case 9: return .UnsignedTxHasScriptWitnesses
        case 10: return .MustHaveUnsignedTx
        case 11: return .NoMorePairs
        case 12: return .UnexpectedUnsignedTx
        case 13: return .NonStandardSighashType(
            sighash: try FfiConverterUInt32.read(from: &buf)
            )
        case 14: return .InvalidHash(
            hash: try FfiConverterString.read(from: &buf)
            )
        case 15: return .InvalidPreimageHashPair
        case 16: return .CombineInconsistentKeySources(
            xpub: try FfiConverterString.read(from: &buf)
            )
        case 17: return .ConsensusEncoding(
            encodingError: try FfiConverterString.read(from: &buf)
            )
        case 18: return .NegativeFee
        case 19: return .FeeOverflow
        case 20: return .InvalidPublicKey(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 21: return .InvalidSecp256k1PublicKey(
            secp256k1Error: try FfiConverterString.read(from: &buf)
            )
        case 22: return .InvalidXOnlyPublicKey
        case 23: return .InvalidEcdsaSignature(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 24: return .InvalidTaprootSignature(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 25: return .InvalidControlBlock
        case 26: return .InvalidLeafVersion
        case 27: return .Taproot
        case 28: return .TapTree(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 29: return .XPubKey
        case 30: return .Version(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 31: return .PartialDataConsumption
        case 32: return .Io(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 33: return .OtherPsbtErr

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PsbtError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .InvalidMagic:
            writeInt(&buf, Int32(1))
        
        
        case .MissingUtxo:
            writeInt(&buf, Int32(2))
        
        
        case .InvalidSeparator:
            writeInt(&buf, Int32(3))
        
        
        case .PsbtUtxoOutOfBounds:
            writeInt(&buf, Int32(4))
        
        
        case let .InvalidKey(key):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(key, into: &buf)
            
        
        case .InvalidProprietaryKey:
            writeInt(&buf, Int32(6))
        
        
        case let .DuplicateKey(key):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(key, into: &buf)
            
        
        case .UnsignedTxHasScriptSigs:
            writeInt(&buf, Int32(8))
        
        
        case .UnsignedTxHasScriptWitnesses:
            writeInt(&buf, Int32(9))
        
        
        case .MustHaveUnsignedTx:
            writeInt(&buf, Int32(10))
        
        
        case .NoMorePairs:
            writeInt(&buf, Int32(11))
        
        
        case .UnexpectedUnsignedTx:
            writeInt(&buf, Int32(12))
        
        
        case let .NonStandardSighashType(sighash):
            writeInt(&buf, Int32(13))
            FfiConverterUInt32.write(sighash, into: &buf)
            
        
        case let .InvalidHash(hash):
            writeInt(&buf, Int32(14))
            FfiConverterString.write(hash, into: &buf)
            
        
        case .InvalidPreimageHashPair:
            writeInt(&buf, Int32(15))
        
        
        case let .CombineInconsistentKeySources(xpub):
            writeInt(&buf, Int32(16))
            FfiConverterString.write(xpub, into: &buf)
            
        
        case let .ConsensusEncoding(encodingError):
            writeInt(&buf, Int32(17))
            FfiConverterString.write(encodingError, into: &buf)
            
        
        case .NegativeFee:
            writeInt(&buf, Int32(18))
        
        
        case .FeeOverflow:
            writeInt(&buf, Int32(19))
        
        
        case let .InvalidPublicKey(errorMessage):
            writeInt(&buf, Int32(20))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .InvalidSecp256k1PublicKey(secp256k1Error):
            writeInt(&buf, Int32(21))
            FfiConverterString.write(secp256k1Error, into: &buf)
            
        
        case .InvalidXOnlyPublicKey:
            writeInt(&buf, Int32(22))
        
        
        case let .InvalidEcdsaSignature(errorMessage):
            writeInt(&buf, Int32(23))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .InvalidTaprootSignature(errorMessage):
            writeInt(&buf, Int32(24))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .InvalidControlBlock:
            writeInt(&buf, Int32(25))
        
        
        case .InvalidLeafVersion:
            writeInt(&buf, Int32(26))
        
        
        case .Taproot:
            writeInt(&buf, Int32(27))
        
        
        case let .TapTree(errorMessage):
            writeInt(&buf, Int32(28))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .XPubKey:
            writeInt(&buf, Int32(29))
        
        
        case let .Version(errorMessage):
            writeInt(&buf, Int32(30))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .PartialDataConsumption:
            writeInt(&buf, Int32(31))
        
        
        case let .Io(errorMessage):
            writeInt(&buf, Int32(32))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .OtherPsbtErr:
            writeInt(&buf, Int32(33))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePsbtError_lift(_ buf: RustBuffer) throws -> PsbtError {
    return try FfiConverterTypePsbtError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePsbtError_lower(_ value: PsbtError) -> RustBuffer {
    return FfiConverterTypePsbtError.lower(value)
}


extension PsbtError: Equatable, Hashable {}




extension PsbtError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





public enum PsbtFinalizeError: Swift.Error {

    
    
    case InputError(reason: String, index: UInt32
    )
    case WrongInputCount(inTx: UInt32, inMap: UInt32
    )
    case InputIdxOutofBounds(psbtInp: UInt32, requested: UInt32
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePsbtFinalizeError: FfiConverterRustBuffer {
    typealias SwiftType = PsbtFinalizeError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PsbtFinalizeError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InputError(
            reason: try FfiConverterString.read(from: &buf), 
            index: try FfiConverterUInt32.read(from: &buf)
            )
        case 2: return .WrongInputCount(
            inTx: try FfiConverterUInt32.read(from: &buf), 
            inMap: try FfiConverterUInt32.read(from: &buf)
            )
        case 3: return .InputIdxOutofBounds(
            psbtInp: try FfiConverterUInt32.read(from: &buf), 
            requested: try FfiConverterUInt32.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PsbtFinalizeError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InputError(reason,index):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(reason, into: &buf)
            FfiConverterUInt32.write(index, into: &buf)
            
        
        case let .WrongInputCount(inTx,inMap):
            writeInt(&buf, Int32(2))
            FfiConverterUInt32.write(inTx, into: &buf)
            FfiConverterUInt32.write(inMap, into: &buf)
            
        
        case let .InputIdxOutofBounds(psbtInp,requested):
            writeInt(&buf, Int32(3))
            FfiConverterUInt32.write(psbtInp, into: &buf)
            FfiConverterUInt32.write(requested, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePsbtFinalizeError_lift(_ buf: RustBuffer) throws -> PsbtFinalizeError {
    return try FfiConverterTypePsbtFinalizeError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePsbtFinalizeError_lower(_ value: PsbtFinalizeError) -> RustBuffer {
    return FfiConverterTypePsbtFinalizeError.lower(value)
}


extension PsbtFinalizeError: Equatable, Hashable {}




extension PsbtFinalizeError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





public enum PsbtParseError: Swift.Error {

    
    
    case PsbtEncoding(errorMessage: String
    )
    case Base64Encoding(errorMessage: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePsbtParseError: FfiConverterRustBuffer {
    typealias SwiftType = PsbtParseError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PsbtParseError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .PsbtEncoding(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 2: return .Base64Encoding(
            errorMessage: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PsbtParseError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .PsbtEncoding(errorMessage):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Base64Encoding(errorMessage):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(errorMessage, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePsbtParseError_lift(_ buf: RustBuffer) throws -> PsbtParseError {
    return try FfiConverterTypePsbtParseError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePsbtParseError_lower(_ value: PsbtParseError) -> RustBuffer {
    return FfiConverterTypePsbtParseError.lower(value)
}


extension PsbtParseError: Equatable, Hashable {}




extension PsbtParseError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RecoveryPoint {
    
    case genesisBlock
    case segwitActivation
    case taprootActivation
}


#if compiler(>=6)
extension RecoveryPoint: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRecoveryPoint: FfiConverterRustBuffer {
    typealias SwiftType = RecoveryPoint

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecoveryPoint {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .genesisBlock
        
        case 2: return .segwitActivation
        
        case 3: return .taprootActivation
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RecoveryPoint, into buf: inout [UInt8]) {
        switch value {
        
        
        case .genesisBlock:
            writeInt(&buf, Int32(1))
        
        
        case .segwitActivation:
            writeInt(&buf, Int32(2))
        
        
        case .taprootActivation:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecoveryPoint_lift(_ buf: RustBuffer) throws -> RecoveryPoint {
    return try FfiConverterTypeRecoveryPoint.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecoveryPoint_lower(_ value: RecoveryPoint) -> RustBuffer {
    return FfiConverterTypeRecoveryPoint.lower(value)
}


extension RecoveryPoint: Equatable, Hashable {}







public enum RequestBuilderError: Swift.Error {

    
    
    case RequestAlreadyConsumed
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRequestBuilderError: FfiConverterRustBuffer {
    typealias SwiftType = RequestBuilderError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestBuilderError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .RequestAlreadyConsumed

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RequestBuilderError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .RequestAlreadyConsumed:
            writeInt(&buf, Int32(1))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRequestBuilderError_lift(_ buf: RustBuffer) throws -> RequestBuilderError {
    return try FfiConverterTypeRequestBuilderError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRequestBuilderError_lower(_ value: RequestBuilderError) -> RustBuffer {
    return FfiConverterTypeRequestBuilderError.lower(value)
}


extension RequestBuilderError: Equatable, Hashable {}




extension RequestBuilderError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Satisfaction {
    
    case partial(n: UInt64, m: UInt64, items: [UInt64], sorted: Bool?, conditions: [UInt32: [Condition]]
    )
    case partialComplete(n: UInt64, m: UInt64, items: [UInt64], sorted: Bool?, conditions: [[UInt32]: [Condition]]
    )
    case complete(condition: Condition
    )
    case none(msg: String
    )
}


#if compiler(>=6)
extension Satisfaction: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSatisfaction: FfiConverterRustBuffer {
    typealias SwiftType = Satisfaction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Satisfaction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .partial(n: try FfiConverterUInt64.read(from: &buf), m: try FfiConverterUInt64.read(from: &buf), items: try FfiConverterSequenceUInt64.read(from: &buf), sorted: try FfiConverterOptionBool.read(from: &buf), conditions: try FfiConverterDictionaryUInt32SequenceTypeCondition.read(from: &buf)
        )
        
        case 2: return .partialComplete(n: try FfiConverterUInt64.read(from: &buf), m: try FfiConverterUInt64.read(from: &buf), items: try FfiConverterSequenceUInt64.read(from: &buf), sorted: try FfiConverterOptionBool.read(from: &buf), conditions: try FfiConverterDictionarySequenceUInt32SequenceTypeCondition.read(from: &buf)
        )
        
        case 3: return .complete(condition: try FfiConverterTypeCondition.read(from: &buf)
        )
        
        case 4: return .none(msg: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Satisfaction, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .partial(n,m,items,sorted,conditions):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(n, into: &buf)
            FfiConverterUInt64.write(m, into: &buf)
            FfiConverterSequenceUInt64.write(items, into: &buf)
            FfiConverterOptionBool.write(sorted, into: &buf)
            FfiConverterDictionaryUInt32SequenceTypeCondition.write(conditions, into: &buf)
            
        
        case let .partialComplete(n,m,items,sorted,conditions):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(n, into: &buf)
            FfiConverterUInt64.write(m, into: &buf)
            FfiConverterSequenceUInt64.write(items, into: &buf)
            FfiConverterOptionBool.write(sorted, into: &buf)
            FfiConverterDictionarySequenceUInt32SequenceTypeCondition.write(conditions, into: &buf)
            
        
        case let .complete(condition):
            writeInt(&buf, Int32(3))
            FfiConverterTypeCondition.write(condition, into: &buf)
            
        
        case let .none(msg):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(msg, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSatisfaction_lift(_ buf: RustBuffer) throws -> Satisfaction {
    return try FfiConverterTypeSatisfaction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSatisfaction_lower(_ value: Satisfaction) -> RustBuffer {
    return FfiConverterTypeSatisfaction.lower(value)
}


extension Satisfaction: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SatisfiableItem {
    
    case ecdsaSignature(key: PkOrF
    )
    case schnorrSignature(key: PkOrF
    )
    case sha256Preimage(hash: String
    )
    case hash256Preimage(hash: String
    )
    case ripemd160Preimage(hash: String
    )
    case hash160Preimage(hash: String
    )
    case absoluteTimelock(value: LockTime
    )
    case relativeTimelock(value: UInt32
    )
    case multisig(keys: [PkOrF], threshold: UInt64
    )
    case thresh(items: [Policy], threshold: UInt64
    )
}


#if compiler(>=6)
extension SatisfiableItem: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSatisfiableItem: FfiConverterRustBuffer {
    typealias SwiftType = SatisfiableItem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SatisfiableItem {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ecdsaSignature(key: try FfiConverterTypePkOrF.read(from: &buf)
        )
        
        case 2: return .schnorrSignature(key: try FfiConverterTypePkOrF.read(from: &buf)
        )
        
        case 3: return .sha256Preimage(hash: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .hash256Preimage(hash: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .ripemd160Preimage(hash: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .hash160Preimage(hash: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .absoluteTimelock(value: try FfiConverterTypeLockTime.read(from: &buf)
        )
        
        case 8: return .relativeTimelock(value: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 9: return .multisig(keys: try FfiConverterSequenceTypePkOrF.read(from: &buf), threshold: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 10: return .thresh(items: try FfiConverterSequenceTypePolicy.read(from: &buf), threshold: try FfiConverterUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SatisfiableItem, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .ecdsaSignature(key):
            writeInt(&buf, Int32(1))
            FfiConverterTypePkOrF.write(key, into: &buf)
            
        
        case let .schnorrSignature(key):
            writeInt(&buf, Int32(2))
            FfiConverterTypePkOrF.write(key, into: &buf)
            
        
        case let .sha256Preimage(hash):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(hash, into: &buf)
            
        
        case let .hash256Preimage(hash):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(hash, into: &buf)
            
        
        case let .ripemd160Preimage(hash):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(hash, into: &buf)
            
        
        case let .hash160Preimage(hash):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(hash, into: &buf)
            
        
        case let .absoluteTimelock(value):
            writeInt(&buf, Int32(7))
            FfiConverterTypeLockTime.write(value, into: &buf)
            
        
        case let .relativeTimelock(value):
            writeInt(&buf, Int32(8))
            FfiConverterUInt32.write(value, into: &buf)
            
        
        case let .multisig(keys,threshold):
            writeInt(&buf, Int32(9))
            FfiConverterSequenceTypePkOrF.write(keys, into: &buf)
            FfiConverterUInt64.write(threshold, into: &buf)
            
        
        case let .thresh(items,threshold):
            writeInt(&buf, Int32(10))
            FfiConverterSequenceTypePolicy.write(items, into: &buf)
            FfiConverterUInt64.write(threshold, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSatisfiableItem_lift(_ buf: RustBuffer) throws -> SatisfiableItem {
    return try FfiConverterTypeSatisfiableItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSatisfiableItem_lower(_ value: SatisfiableItem) -> RustBuffer {
    return FfiConverterTypeSatisfiableItem.lower(value)
}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Sync a wallet from the last known block hash or recover a wallet from a specified recovery
 * point.
 */

public enum ScanType {
    
    /**
     * Sync an existing wallet from the last stored chain checkpoint.
     */
    case sync
    /**
     * Recover an existing wallet by scanning from the specified height.
     */
    case recovery(
        /**
         * The estimated number of scripts the user has revealed for the wallet being recovered.
         * If unknown, a conservative estimate, say 1,000, could be used.
         */usedScriptIndex: UInt32, 
        /**
         * A relevant starting point or soft fork to start the sync.
         */checkpoint: RecoveryPoint
    )
}


#if compiler(>=6)
extension ScanType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeScanType: FfiConverterRustBuffer {
    typealias SwiftType = ScanType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScanType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .sync
        
        case 2: return .recovery(usedScriptIndex: try FfiConverterUInt32.read(from: &buf), checkpoint: try FfiConverterTypeRecoveryPoint.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ScanType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .sync:
            writeInt(&buf, Int32(1))
        
        
        case let .recovery(usedScriptIndex,checkpoint):
            writeInt(&buf, Int32(2))
            FfiConverterUInt32.write(usedScriptIndex, into: &buf)
            FfiConverterTypeRecoveryPoint.write(checkpoint, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeScanType_lift(_ buf: RustBuffer) throws -> ScanType {
    return try FfiConverterTypeScanType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeScanType_lower(_ value: ScanType) -> RustBuffer {
    return FfiConverterTypeScanType.lower(value)
}


extension ScanType: Equatable, Hashable {}







public enum SignerError: Swift.Error {

    
    
    case MissingKey
    case InvalidKey
    case UserCanceled
    case InputIndexOutOfRange
    case MissingNonWitnessUtxo
    case InvalidNonWitnessUtxo
    case MissingWitnessUtxo
    case MissingWitnessScript
    case MissingHdKeypath
    case NonStandardSighash
    case InvalidSighash
    case SighashP2wpkh(errorMessage: String
    )
    case SighashTaproot(errorMessage: String
    )
    case TxInputsIndexError(errorMessage: String
    )
    case MiniscriptPsbt(errorMessage: String
    )
    case External(errorMessage: String
    )
    case Psbt(errorMessage: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignerError: FfiConverterRustBuffer {
    typealias SwiftType = SignerError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignerError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .MissingKey
        case 2: return .InvalidKey
        case 3: return .UserCanceled
        case 4: return .InputIndexOutOfRange
        case 5: return .MissingNonWitnessUtxo
        case 6: return .InvalidNonWitnessUtxo
        case 7: return .MissingWitnessUtxo
        case 8: return .MissingWitnessScript
        case 9: return .MissingHdKeypath
        case 10: return .NonStandardSighash
        case 11: return .InvalidSighash
        case 12: return .SighashP2wpkh(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 13: return .SighashTaproot(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 14: return .TxInputsIndexError(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 15: return .MiniscriptPsbt(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 16: return .External(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 17: return .Psbt(
            errorMessage: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SignerError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .MissingKey:
            writeInt(&buf, Int32(1))
        
        
        case .InvalidKey:
            writeInt(&buf, Int32(2))
        
        
        case .UserCanceled:
            writeInt(&buf, Int32(3))
        
        
        case .InputIndexOutOfRange:
            writeInt(&buf, Int32(4))
        
        
        case .MissingNonWitnessUtxo:
            writeInt(&buf, Int32(5))
        
        
        case .InvalidNonWitnessUtxo:
            writeInt(&buf, Int32(6))
        
        
        case .MissingWitnessUtxo:
            writeInt(&buf, Int32(7))
        
        
        case .MissingWitnessScript:
            writeInt(&buf, Int32(8))
        
        
        case .MissingHdKeypath:
            writeInt(&buf, Int32(9))
        
        
        case .NonStandardSighash:
            writeInt(&buf, Int32(10))
        
        
        case .InvalidSighash:
            writeInt(&buf, Int32(11))
        
        
        case let .SighashP2wpkh(errorMessage):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .SighashTaproot(errorMessage):
            writeInt(&buf, Int32(13))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .TxInputsIndexError(errorMessage):
            writeInt(&buf, Int32(14))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .MiniscriptPsbt(errorMessage):
            writeInt(&buf, Int32(15))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .External(errorMessage):
            writeInt(&buf, Int32(16))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Psbt(errorMessage):
            writeInt(&buf, Int32(17))
            FfiConverterString.write(errorMessage, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignerError_lift(_ buf: RustBuffer) throws -> SignerError {
    return try FfiConverterTypeSignerError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignerError_lower(_ value: SignerError) -> RustBuffer {
    return FfiConverterTypeSignerError.lower(value)
}


extension SignerError: Equatable, Hashable {}




extension SignerError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





public enum TransactionError: Swift.Error {

    
    
    case Io
    case OversizedVectorAllocation
    case InvalidChecksum(expected: String, actual: String
    )
    case NonMinimalVarInt
    case ParseFailed
    case UnsupportedSegwitFlag(flag: UInt8
    )
    case OtherTransactionErr
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransactionError: FfiConverterRustBuffer {
    typealias SwiftType = TransactionError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Io
        case 2: return .OversizedVectorAllocation
        case 3: return .InvalidChecksum(
            expected: try FfiConverterString.read(from: &buf), 
            actual: try FfiConverterString.read(from: &buf)
            )
        case 4: return .NonMinimalVarInt
        case 5: return .ParseFailed
        case 6: return .UnsupportedSegwitFlag(
            flag: try FfiConverterUInt8.read(from: &buf)
            )
        case 7: return .OtherTransactionErr

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransactionError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .Io:
            writeInt(&buf, Int32(1))
        
        
        case .OversizedVectorAllocation:
            writeInt(&buf, Int32(2))
        
        
        case let .InvalidChecksum(expected,actual):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(expected, into: &buf)
            FfiConverterString.write(actual, into: &buf)
            
        
        case .NonMinimalVarInt:
            writeInt(&buf, Int32(4))
        
        
        case .ParseFailed:
            writeInt(&buf, Int32(5))
        
        
        case let .UnsupportedSegwitFlag(flag):
            writeInt(&buf, Int32(6))
            FfiConverterUInt8.write(flag, into: &buf)
            
        
        case .OtherTransactionErr:
            writeInt(&buf, Int32(7))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionError_lift(_ buf: RustBuffer) throws -> TransactionError {
    return try FfiConverterTypeTransactionError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionError_lower(_ value: TransactionError) -> RustBuffer {
    return FfiConverterTypeTransactionError.lower(value)
}


extension TransactionError: Equatable, Hashable {}




extension TransactionError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





public enum TxidParseError: Swift.Error {

    
    
    case InvalidTxid(txid: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTxidParseError: FfiConverterRustBuffer {
    typealias SwiftType = TxidParseError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxidParseError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidTxid(
            txid: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TxidParseError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidTxid(txid):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(txid, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxidParseError_lift(_ buf: RustBuffer) throws -> TxidParseError {
    return try FfiConverterTypeTxidParseError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxidParseError_lower(_ value: TxidParseError) -> RustBuffer {
    return FfiConverterTypeTxidParseError.lower(value)
}


extension TxidParseError: Equatable, Hashable {}




extension TxidParseError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Warnings a node may issue while running.
 */

public enum Warning {
    
    /**
     * The node is looking for connections to peers.
     */
    case needConnections
    /**
     * A connection to a peer timed out.
     */
    case peerTimedOut
    /**
     * The node was unable to connect to a peer in the database.
     */
    case couldNotConnect
    /**
     * A connection was maintained, but the peer does not signal for compact block filers.
     */
    case noCompactFilters
    /**
     * The node has been waiting for new inv and will find new peers to avoid block withholding.
     */
    case potentialStaleTip
    /**
     * A peer sent us a peer-to-peer message the node did not request.
     */
    case unsolicitedMessage
    /**
     * A transaction got rejected, likely for being an insufficient fee or non-standard transaction.
     */
    case transactionRejected(wtxid: String, reason: String?
    )
    /**
     * The peer sent us a potential fork.
     */
    case evaluatingFork
    /**
     * An unexpected error occurred processing a peer-to-peer message.
     */
    case unexpectedSyncError(warning: String
    )
    /**
     * The node failed to respond to a message sent from the client.
     */
    case requestFailed
}


#if compiler(>=6)
extension Warning: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWarning: FfiConverterRustBuffer {
    typealias SwiftType = Warning

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Warning {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .needConnections
        
        case 2: return .peerTimedOut
        
        case 3: return .couldNotConnect
        
        case 4: return .noCompactFilters
        
        case 5: return .potentialStaleTip
        
        case 6: return .unsolicitedMessage
        
        case 7: return .transactionRejected(wtxid: try FfiConverterString.read(from: &buf), reason: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 8: return .evaluatingFork
        
        case 9: return .unexpectedSyncError(warning: try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .requestFailed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Warning, into buf: inout [UInt8]) {
        switch value {
        
        
        case .needConnections:
            writeInt(&buf, Int32(1))
        
        
        case .peerTimedOut:
            writeInt(&buf, Int32(2))
        
        
        case .couldNotConnect:
            writeInt(&buf, Int32(3))
        
        
        case .noCompactFilters:
            writeInt(&buf, Int32(4))
        
        
        case .potentialStaleTip:
            writeInt(&buf, Int32(5))
        
        
        case .unsolicitedMessage:
            writeInt(&buf, Int32(6))
        
        
        case let .transactionRejected(wtxid,reason):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(wtxid, into: &buf)
            FfiConverterOptionString.write(reason, into: &buf)
            
        
        case .evaluatingFork:
            writeInt(&buf, Int32(8))
        
        
        case let .unexpectedSyncError(warning):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(warning, into: &buf)
            
        
        case .requestFailed:
            writeInt(&buf, Int32(10))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWarning_lift(_ buf: RustBuffer) throws -> Warning {
    return try FfiConverterTypeWarning.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWarning_lower(_ value: Warning) -> RustBuffer {
    return FfiConverterTypeWarning.lower(value)
}


extension Warning: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WordCount {
    
    case words12
    case words15
    case words18
    case words21
    case words24
}


#if compiler(>=6)
extension WordCount: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWordCount: FfiConverterRustBuffer {
    typealias SwiftType = WordCount

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WordCount {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .words12
        
        case 2: return .words15
        
        case 3: return .words18
        
        case 4: return .words21
        
        case 5: return .words24
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WordCount, into buf: inout [UInt8]) {
        switch value {
        
        
        case .words12:
            writeInt(&buf, Int32(1))
        
        
        case .words15:
            writeInt(&buf, Int32(2))
        
        
        case .words18:
            writeInt(&buf, Int32(3))
        
        
        case .words21:
            writeInt(&buf, Int32(4))
        
        
        case .words24:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWordCount_lift(_ buf: RustBuffer) throws -> WordCount {
    return try FfiConverterTypeWordCount.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWordCount_lower(_ value: WordCount) -> RustBuffer {
    return FfiConverterTypeWordCount.lower(value)
}


extension WordCount: Equatable, Hashable {}






#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt16: FfiConverterRustBuffer {
    typealias SwiftType = UInt16?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt16.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt16.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionFloat: FfiConverterRustBuffer {
    typealias SwiftType = Float?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterFloat.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterFloat.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeAmount: FfiConverterRustBuffer {
    typealias SwiftType = Amount?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAmount.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAmount.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeBlockHash: FfiConverterRustBuffer {
    typealias SwiftType = BlockHash?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBlockHash.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBlockHash.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeDescriptor: FfiConverterRustBuffer {
    typealias SwiftType = Descriptor?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDescriptor.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDescriptor.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypePolicy: FfiConverterRustBuffer {
    typealias SwiftType = Policy?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePolicy.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePolicy.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeTransaction: FfiConverterRustBuffer {
    typealias SwiftType = Transaction?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTransaction.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTransaction.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeTxid: FfiConverterRustBuffer {
    typealias SwiftType = Txid?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTxid.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTxid.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeCanonicalTx: FfiConverterRustBuffer {
    typealias SwiftType = CanonicalTx?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCanonicalTx.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCanonicalTx.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeKeychainAndIndex: FfiConverterRustBuffer {
    typealias SwiftType = KeychainAndIndex?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeKeychainAndIndex.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeKeychainAndIndex.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeLocalOutput: FfiConverterRustBuffer {
    typealias SwiftType = LocalOutput?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLocalOutput.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLocalOutput.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSignOptions: FfiConverterRustBuffer {
    typealias SwiftType = SignOptions?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSignOptions.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSignOptions.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeTx: FfiConverterRustBuffer {
    typealias SwiftType = Tx?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTx.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTx.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeTxDetails: FfiConverterRustBuffer {
    typealias SwiftType = TxDetails?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTxDetails.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTxDetails.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeLockTime: FfiConverterRustBuffer {
    typealias SwiftType = LockTime?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLockTime.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLockTime.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = Network?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeNetwork.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeNetwork.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypePsbtFinalizeError: FfiConverterRustBuffer {
    typealias SwiftType = [PsbtFinalizeError]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypePsbtFinalizeError.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypePsbtFinalizeError.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceUInt32: FfiConverterRustBuffer {
    typealias SwiftType = [UInt32]

    public static func write(_ value: [UInt32], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt32.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt32] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt32]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt32.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceUInt64: FfiConverterRustBuffer {
    typealias SwiftType = [UInt64]

    public static func write(_ value: [UInt64], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt64.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt64] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt64]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt64.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceData: FfiConverterRustBuffer {
    typealias SwiftType = [Data]

    public static func write(_ value: [Data], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterData.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Data] {
        let len: Int32 = try readInt(&buf)
        var seq = [Data]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterData.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeDescriptor: FfiConverterRustBuffer {
    typealias SwiftType = [Descriptor]

    public static func write(_ value: [Descriptor], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDescriptor.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Descriptor] {
        let len: Int32 = try readInt(&buf)
        var seq = [Descriptor]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeDescriptor.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeIpAddress: FfiConverterRustBuffer {
    typealias SwiftType = [IpAddress]

    public static func write(_ value: [IpAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeIpAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [IpAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [IpAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeIpAddress.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePolicy: FfiConverterRustBuffer {
    typealias SwiftType = [Policy]

    public static func write(_ value: [Policy], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePolicy.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Policy] {
        let len: Int32 = try readInt(&buf)
        var seq = [Policy]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePolicy.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTransaction: FfiConverterRustBuffer {
    typealias SwiftType = [Transaction]

    public static func write(_ value: [Transaction], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTransaction.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Transaction] {
        let len: Int32 = try readInt(&buf)
        var seq = [Transaction]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTransaction.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAddressInfo: FfiConverterRustBuffer {
    typealias SwiftType = [AddressInfo]

    public static func write(_ value: [AddressInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAddressInfo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AddressInfo] {
        let len: Int32 = try readInt(&buf)
        var seq = [AddressInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAddressInfo.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAnchor: FfiConverterRustBuffer {
    typealias SwiftType = [Anchor]

    public static func write(_ value: [Anchor], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAnchor.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Anchor] {
        let len: Int32 = try readInt(&buf)
        var seq = [Anchor]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAnchor.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeCanonicalTx: FfiConverterRustBuffer {
    typealias SwiftType = [CanonicalTx]

    public static func write(_ value: [CanonicalTx], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCanonicalTx.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [CanonicalTx] {
        let len: Int32 = try readInt(&buf)
        var seq = [CanonicalTx]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCanonicalTx.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeChainChange: FfiConverterRustBuffer {
    typealias SwiftType = [ChainChange]

    public static func write(_ value: [ChainChange], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeChainChange.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ChainChange] {
        let len: Int32 = try readInt(&buf)
        var seq = [ChainChange]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeChainChange.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeCondition: FfiConverterRustBuffer {
    typealias SwiftType = [Condition]

    public static func write(_ value: [Condition], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCondition.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Condition] {
        let len: Int32 = try readInt(&buf)
        var seq = [Condition]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCondition.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeEvictedTx: FfiConverterRustBuffer {
    typealias SwiftType = [EvictedTx]

    public static func write(_ value: [EvictedTx], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEvictedTx.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EvictedTx] {
        let len: Int32 = try readInt(&buf)
        var seq = [EvictedTx]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEvictedTx.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeLocalOutput: FfiConverterRustBuffer {
    typealias SwiftType = [LocalOutput]

    public static func write(_ value: [LocalOutput], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLocalOutput.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LocalOutput] {
        let len: Int32 = try readInt(&buf)
        var seq = [LocalOutput]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLocalOutput.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeOutPoint: FfiConverterRustBuffer {
    typealias SwiftType = [OutPoint]

    public static func write(_ value: [OutPoint], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeOutPoint.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [OutPoint] {
        let len: Int32 = try readInt(&buf)
        var seq = [OutPoint]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeOutPoint.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePeer: FfiConverterRustBuffer {
    typealias SwiftType = [Peer]

    public static func write(_ value: [Peer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePeer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Peer] {
        let len: Int32 = try readInt(&buf)
        var seq = [Peer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePeer.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeScriptAmount: FfiConverterRustBuffer {
    typealias SwiftType = [ScriptAmount]

    public static func write(_ value: [ScriptAmount], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeScriptAmount.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ScriptAmount] {
        let len: Int32 = try readInt(&buf)
        var seq = [ScriptAmount]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeScriptAmount.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTxIn: FfiConverterRustBuffer {
    typealias SwiftType = [TxIn]

    public static func write(_ value: [TxIn], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTxIn.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TxIn] {
        let len: Int32 = try readInt(&buf)
        var seq = [TxIn]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTxIn.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTxOut: FfiConverterRustBuffer {
    typealias SwiftType = [TxOut]

    public static func write(_ value: [TxOut], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTxOut.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TxOut] {
        let len: Int32 = try readInt(&buf)
        var seq = [TxOut]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTxOut.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeUnconfirmedTx: FfiConverterRustBuffer {
    typealias SwiftType = [UnconfirmedTx]

    public static func write(_ value: [UnconfirmedTx], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUnconfirmedTx.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UnconfirmedTx] {
        let len: Int32 = try readInt(&buf)
        var seq = [UnconfirmedTx]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUnconfirmedTx.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePkOrF: FfiConverterRustBuffer {
    typealias SwiftType = [PkOrF]

    public static func write(_ value: [PkOrF], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePkOrF.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PkOrF] {
        let len: Int32 = try readInt(&buf)
        var seq = [PkOrF]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePkOrF.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePsbtFinalizeError: FfiConverterRustBuffer {
    typealias SwiftType = [PsbtFinalizeError]

    public static func write(_ value: [PsbtFinalizeError], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePsbtFinalizeError.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PsbtFinalizeError] {
        let len: Int32 = try readInt(&buf)
        var seq = [PsbtFinalizeError]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePsbtFinalizeError.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryUInt16Double: FfiConverterRustBuffer {
    public static func write(_ value: [UInt16: Double], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterUInt16.write(key, into: &buf)
            FfiConverterDouble.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt16: Double] {
        let len: Int32 = try readInt(&buf)
        var dict = [UInt16: Double]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterUInt16.read(from: &buf)
            let value = try FfiConverterDouble.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryUInt32SequenceTypeCondition: FfiConverterRustBuffer {
    public static func write(_ value: [UInt32: [Condition]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterUInt32.write(key, into: &buf)
            FfiConverterSequenceTypeCondition.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt32: [Condition]] {
        let len: Int32 = try readInt(&buf)
        var dict = [UInt32: [Condition]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterUInt32.read(from: &buf)
            let value = try FfiConverterSequenceTypeCondition.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringSequenceUInt64: FfiConverterRustBuffer {
    public static func write(_ value: [String: [UInt64]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceUInt64.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [UInt64]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [UInt64]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceUInt64.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryTypeDescriptorIdUInt32: FfiConverterRustBuffer {
    public static func write(_ value: [DescriptorId: UInt32], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeDescriptorId.write(key, into: &buf)
            FfiConverterUInt32.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DescriptorId: UInt32] {
        let len: Int32 = try readInt(&buf)
        var dict = [DescriptorId: UInt32]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeDescriptorId.read(from: &buf)
            let value = try FfiConverterUInt32.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryTypeHashableOutPointTypeTxOut: FfiConverterRustBuffer {
    public static func write(_ value: [HashableOutPoint: TxOut], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeHashableOutPoint.write(key, into: &buf)
            FfiConverterTypeTxOut.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [HashableOutPoint: TxOut] {
        let len: Int32 = try readInt(&buf)
        var dict = [HashableOutPoint: TxOut]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeHashableOutPoint.read(from: &buf)
            let value = try FfiConverterTypeTxOut.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryTypeTxidUInt64: FfiConverterRustBuffer {
    public static func write(_ value: [Txid: UInt64], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeTxid.write(key, into: &buf)
            FfiConverterUInt64.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Txid: UInt64] {
        let len: Int32 = try readInt(&buf)
        var dict = [Txid: UInt64]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeTxid.read(from: &buf)
            let value = try FfiConverterUInt64.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionarySequenceUInt32SequenceTypeCondition: FfiConverterRustBuffer {
    public static func write(_ value: [[UInt32]: [Condition]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterSequenceUInt32.write(key, into: &buf)
            FfiConverterSequenceTypeCondition.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[UInt32]: [Condition]] {
        let len: Int32 = try readInt(&buf)
        var dict = [[UInt32]: [Condition]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterSequenceUInt32.read(from: &buf)
            let value = try FfiConverterSequenceTypeCondition.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}
private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call the ensure init function since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureBdkffiInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 29
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_bdkffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_bdkffi_checksum_method_address_is_valid_for_network() != 799) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_address_script_pubkey() != 23663) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_address_to_address_data() != 6766) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_address_to_qr_uri() != 60630) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_amount_to_btc() != 44112) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_amount_to_sat() != 2062) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_blockhash_serialize() != 58329) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_bumpfeetxbuilder_allow_dust() != 64834) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_bumpfeetxbuilder_current_height() != 25489) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_bumpfeetxbuilder_finish() != 36534) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_bumpfeetxbuilder_nlocktime() != 13924) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_bumpfeetxbuilder_set_exact_sequence() != 13533) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_bumpfeetxbuilder_version() != 18790) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfbuilder_build() != 4783) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfbuilder_configure_timeout_millis() != 41120) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfbuilder_connections() != 8040) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfbuilder_data_dir() != 31903) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfbuilder_peers() != 54701) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfbuilder_scan_type() != 58442) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfbuilder_socks5_proxy() != 50836) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfclient_average_fee_rate() != 26767) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfclient_broadcast() != 56213) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfclient_connect() != 2287) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfclient_is_running() != 22584) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfclient_lookup_host() != 27293) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfclient_min_broadcast_feerate() != 31908) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfclient_next_info() != 61206) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfclient_next_warning() != 38083) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfclient_shutdown() != 21067) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfclient_update() != 59279) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_cbfnode_run() != 61383) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_changeset_change_descriptor() != 60265) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_changeset_descriptor() != 8527) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_changeset_indexer_changeset() != 12024) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_changeset_localchain_changeset() != 8072) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_changeset_network() != 12695) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_changeset_tx_graph_changeset() != 51559) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptor_desc_type() != 22274) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptor_descriptor_id() != 35226) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptor_is_multipath() != 24851) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptor_max_weight_to_satisfy() != 27840) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptor_to_single_descriptors() != 24048) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptor_to_string_with_secret() != 44538) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptorid_serialize() != 36044) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptorpublickey_derive() != 53424) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptorpublickey_extend() != 11343) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptorpublickey_is_multipath() != 23614) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptorpublickey_master_fingerprint() != 43604) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptorsecretkey_as_public() != 40418) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptorsecretkey_derive() != 17313) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptorsecretkey_extend() != 24206) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_descriptorsecretkey_secret_bytes() != 44537) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_electrumclient_block_headers_subscribe() != 27583) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_electrumclient_estimate_fee() != 55819) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_electrumclient_full_scan() != 12661) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_electrumclient_ping() != 41284) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_electrumclient_server_features() != 31597) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_electrumclient_sync() != 55678) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_electrumclient_transaction_broadcast() != 24746) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_esploraclient_broadcast() != 45367) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_esploraclient_full_scan() != 19768) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_esploraclient_get_block_hash() != 37777) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_esploraclient_get_fee_estimates() != 62859) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_esploraclient_get_height() != 26148) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_esploraclient_get_tx() != 51222) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_esploraclient_get_tx_info() != 59479) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_esploraclient_get_tx_status() != 61956) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_esploraclient_sync() != 21097) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_feerate_to_sat_per_kwu() != 54539) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_feerate_to_sat_per_vb_ceil() != 34953) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_feerate_to_sat_per_vb_floor() != 29836) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_fullscanrequestbuilder_build() != 5585) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_fullscanrequestbuilder_inspect_spks_for_all_keychains() != 43667) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_fullscanscriptinspector_inspect() != 36414) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_hashableoutpoint_outpoint() != 21921) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_persistence_initialize() != 9283) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_persistence_persist() != 29474) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_policy_as_string() != 42734) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_policy_contribution() != 11262) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_policy_id() != 23964) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_policy_item() != 6003) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_policy_requires_path() != 4187) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_policy_satisfaction() != 46765) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_psbt_combine() != 42075) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_psbt_extract_tx() != 26653) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_psbt_fee() != 30353) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_psbt_finalize() != 51031) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_psbt_json_serialize() != 25111) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_psbt_serialize() != 9376) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_psbt_spend_utxo() != 12381) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_psbt_write_to_file() != 17670) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_script_to_bytes() != 64817) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_syncrequestbuilder_build() != 26747) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_syncrequestbuilder_inspect_spks() != 38063) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_syncscriptinspector_inspect() != 63115) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_compute_txid() != 4600) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_compute_wtxid() != 59414) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_input() != 17971) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_is_coinbase() != 52376) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_is_explicitly_rbf() != 33467) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_is_lock_time_enabled() != 17927) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_lock_time() != 11673) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_output() != 18641) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_serialize() != 63746) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_total_size() != 32499) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_version() != 57173) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_vsize() != 23751) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_transaction_weight() != 22642) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_add_data() != 3485) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_add_global_xpubs() != 60600) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_add_recipient() != 38261) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_add_unspendable() != 42556) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_add_utxo() != 55155) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_add_utxos() != 36635) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_allow_dust() != 36330) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_change_policy() != 33210) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_current_height() != 25990) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_do_not_spend_change() != 279) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_drain_to() != 19958) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_drain_wallet() != 21886) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_exclude_below_confirmations() != 24447) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_exclude_unconfirmed() != 30391) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_fee_absolute() != 6920) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_fee_rate() != 42880) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_finish() != 43504) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_manually_selected_only() != 17632) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_nlocktime() != 61968) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_only_spend_change() != 2625) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_policy_path() != 36425) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_set_exact_sequence() != 11338) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_set_recipients() != 8653) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_unspendable() != 59793) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txbuilder_version() != 12910) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txmerklenode_serialize() != 6758) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_txid_serialize() != 15501) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_apply_evicted_txs() != 47441) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_apply_unconfirmed_txs() != 61391) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_apply_update() != 14059) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_balance() != 1065) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_calculate_fee() != 62842) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_calculate_fee_rate() != 52109) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_cancel_tx() != 52250) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_derivation_index() != 17133) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_derivation_of_spk() != 57131) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_descriptor_checksum() != 65455) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_finalize_psbt() != 23125) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_get_tx() != 23045) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_get_utxo() != 31901) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_is_mine() != 12109) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_latest_checkpoint() != 15617) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_list_output() != 28293) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_list_unspent() != 38160) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_list_unused_addresses() != 43002) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_mark_used() != 53437) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_network() != 61015) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_next_derivation_index() != 54301) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_next_unused_address() != 64390) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_peek_address() != 33286) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_persist() != 45543) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_policies() != 10593) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_public_descriptor() != 58017) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_reveal_addresses_to() != 39125) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_reveal_next_address() != 21378) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_sent_and_received() != 55583) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_sign() != 16374) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_start_full_scan() != 29628) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_start_sync_with_revealed_spks() != 37305) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_transactions() != 45722) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wallet_tx_details() != 21865) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_method_wtxid_serialize() != 29733) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_address_from_script() != 63311) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_address_new() != 15543) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_amount_from_btc() != 43617) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_amount_from_sat() != 18287) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_blockhash_from_bytes() != 58986) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_blockhash_from_string() != 55044) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_bumpfeetxbuilder_new() != 17822) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_cbfbuilder_new() != 33361) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_changeset_from_aggregate() != 32936) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_changeset_from_descriptor_and_network() != 39614) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_changeset_from_indexer_changeset() != 52453) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_changeset_from_local_chain_changes() != 14452) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_changeset_from_merge() != 41467) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_changeset_from_tx_graph_changeset() != 31574) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_changeset_new() != 22000) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_derivationpath_new() != 30769) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptor_new() != 19141) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptor_new_bip44() != 3624) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptor_new_bip44_public() != 31153) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptor_new_bip49() != 25091) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptor_new_bip49_public() != 37536) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptor_new_bip84() != 64808) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptor_new_bip84_public() != 21895) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptor_new_bip86() != 29942) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptor_new_bip86_public() != 10777) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptorid_from_bytes() != 7595) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptorid_from_string() != 26289) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptorpublickey_from_string() != 45545) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptorsecretkey_from_string() != 11133) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_descriptorsecretkey_new() != 48188) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_electrumclient_new() != 2029) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_esploraclient_new() != 7406) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_feerate_from_sat_per_kwu() != 2730) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_feerate_from_sat_per_vb() != 6982) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_hashableoutpoint_new() != 16705) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_ipaddress_from_ipv4() != 14635) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_ipaddress_from_ipv6() != 31033) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_mnemonic_from_entropy() != 812) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_mnemonic_from_string() != 30002) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_mnemonic_new() != 11901) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_persister_custom() != 31182) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_persister_new_in_memory() != 62085) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_persister_new_sqlite() != 14945) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_psbt_from_file() != 48265) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_psbt_from_unsigned_tx() != 6265) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_psbt_new() != 6279) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_script_new() != 53899) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_transaction_new() != 50797) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_txbuilder_new() != 20554) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_txmerklenode_from_bytes() != 62268) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_txmerklenode_from_string() != 34111) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_txid_from_bytes() != 24877) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_txid_from_string() != 39405) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_wallet_create_from_two_path_descriptor() != 35837) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_wallet_create_single() != 50616) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_wallet_load() != 23009) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_wallet_new() != 39177) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_wtxid_from_bytes() != 34456) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bdkffi_checksum_constructor_wtxid_from_string() != 20341) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitFullScanScriptInspector()
    uniffiCallbackInitPersistence()
    uniffiCallbackInitSyncScriptInspector()
    return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
public func uniffiEnsureBdkffiInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all